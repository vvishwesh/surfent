var OV = (() => {
	var Mh = Object.defineProperty;
	var Y0 = Object.getOwnPropertyDescriptor;
	var K0 = Object.getOwnPropertyNames;
	var Z0 = Object.prototype.hasOwnProperty;
	var J0 = (r, e) => {
			for (var t in e) Mh(r, t, {
				get: e[t],
				enumerable: !0
			})
		},
		$0 = (r, e, t, n) => {
			if (e && typeof e == "object" || typeof e == "function")
				for (let i of K0(e)) !Z0.call(r, i) && i !== t && Mh(r, i, {
					get: () => e[i],
					enumerable: !(n = Y0(e, i)) || n.enumerable
				});
			return r
		};
	var Q0 = r => $0(Mh({}, "__esModule", {
		value: !0
	}), r);
	var nS = {};
	J0(nS, {
		AddCoord2D: () => dp,
		AddCoord3D: () => wc,
		AddDiv: () => N0,
		AddDomElement: () => Zd,
		ArrayBufferToAsciiString: () => xp,
		ArrayBufferToUtf8String: () => fn,
		ArrayToCoord3D: () => jr,
		ArrayToQuaternion: () => vo,
		ArrayToRGBColor: () => yp,
		AsciiStringToArrayBuffer: () => _p,
		Base64DataURIToArrayBuffer: () => As,
		BezierTweenFunction: () => Sp,
		BigEps: () => up,
		BinaryReader: () => Yn,
		BinaryWriter: () => Ni,
		BoundingBoxCalculator3D: () => So,
		Box3D: () => Rs,
		CalculateSurfaceArea: () => I0,
		CalculateTriangleNormal: () => Cs,
		CalculateVolume: () => Yd,
		Camera: () => yr,
		CameraIsEqual3D: () => hh,
		CameraMode: () => zn,
		CameraValidator: () => ac,
		CheckModel: () => Hg,
		ClearDomElement: () => O0,
		ClickDetector: () => oc,
		ColorComponentFromFloat: () => En,
		ColorComponentToFloat: () => bs,
		ColorToMaterialConverter: () => ti,
		ConvertColorToThreeColor: () => On,
		ConvertMeshToMeshBuffer: () => po,
		ConvertModelToThreeObject: () => dh,
		ConvertThreeColorToColor: () => Vl,
		ConvertThreeGeometryToMesh: () => Wi,
		Coord2D: () => wt,
		Coord3D: () => He,
		Coord4D: () => Oi,
		CoordDistance2D: () => el,
		CoordDistance3D: () => Wn,
		CoordIsEqual2D: () => Pi,
		CoordIsEqual3D: () => li,
		CopyObjectAttributes: () => oo,
		CreateDiv: () => H0,
		CreateDomElement: () => yh,
		CreateModelUrlParameters: () => L0,
		CreateObjectUrl: () => ws,
		CreateObjectUrlWithMimeType: () => Rc,
		CreateUrlBuilder: () => Kd,
		CreateUrlParser: () => P0,
		CrossVector3D: () => Li,
		DegRad: () => tr,
		Direction: () => ht,
		DisposeThreeObjects: () => Xu,
		DotVector3D: () => nl,
		EdgeSettings: () => eo,
		EmbeddedViewer: () => Ya,
		EnvironmentSettings: () => to,
		Eps: () => cp,
		EscapeHtmlChars: () => gc,
		EventNotifier: () => yc,
		ExportedFile: () => jt,
		Exporter: () => Dc,
		Exporter3dm: () => go,
		ExporterBase: () => bn,
		ExporterBim: () => yo,
		ExporterGltf: () => xo,
		ExporterModel: () => _o,
		ExporterObj: () => To,
		ExporterOff: () => Eo,
		ExporterPly: () => Mo,
		ExporterSettings: () => al,
		ExporterStl: () => bo,
		FaceMaterial: () => ho,
		FileFormat: () => nn,
		FileSource: () => Ii,
		FinalizeModel: () => qu,
		FlipMeshTrianglesOrientation: () => Oc,
		GenerateCone: () => Xd,
		GenerateCuboid: () => A0,
		GenerateCylinder: () => w0,
		GeneratePlatonicSolid: () => R0,
		GenerateSphere: () => C0,
		Generator: () => xs,
		GeneratorHelper: () => Ga,
		GeneratorParams: () => Ql,
		GetBoundingBox: () => Sh,
		GetDefaultCamera: () => vh,
		GetDomElementClientCoordinates: () => Wr,
		GetDomElementExternalHeight: () => mh,
		GetDomElementExternalWidth: () => ph,
		GetDomElementInnerDimensions: () => gh,
		GetDomElementOuterHeight: () => G0,
		GetDomElementOuterWidth: () => B0,
		GetExternalLibPath: () => Es,
		GetFileExtension: () => er,
		GetFileExtensionFromMimeType: () => Yr,
		GetFileName: () => vn,
		GetIntegerFromStyle: () => Cn,
		GetMeshType: () => Kr,
		GetShadingType: () => Wu,
		GetShadingTypeOfObject: () => Qd,
		GetTetrahedronSignedVolume: () => jd,
		GetTopology: () => Ah,
		GetTriangleArea: () => qd,
		HasDefaultMaterial: () => wp,
		HasHighpDriverIssue: () => Hu,
		HexStringToRGBAColor: () => gp,
		HexStringToRGBColor: () => mp,
		ImportError: () => vs,
		ImportErrorCode: () => gr,
		ImportResult: () => Zl,
		ImportSettings: () => ka,
		Importer: () => Ba,
		Importer3dm: () => xa,
		Importer3ds: () => _a,
		ImporterBase: () => Vt,
		ImporterBim: () => Ca,
		ImporterFcstd: () => Ua,
		ImporterFile: () => Is,
		ImporterFileAccessor: () => Jl,
		ImporterFileList: () => Ps,
		ImporterGltf: () => Ta,
		ImporterIfc: () => Ea,
		ImporterObj: () => Ma,
		ImporterOcct: () => Aa,
		ImporterOff: () => ba,
		ImporterPly: () => Sa,
		ImporterStl: () => wa,
		ImporterThree3mf: () => Oa,
		ImporterThreeAmf: () => Da,
		ImporterThreeBase: () => Zi,
		ImporterThreeDae: () => La,
		ImporterThreeFbx: () => Pa,
		ImporterThreeSvg: () => uh,
		ImporterThreeWrl: () => Na,
		Init3DViewerElements: () => X0,
		Init3DViewerFromFileList: () => W0,
		Init3DViewerFromUrlList: () => ep,
		InputFile: () => Co,
		InputFilesFromFileObjects: () => kc,
		InputFilesFromUrls: () => Uc,
		InsertDomElementAfter: () => F0,
		InsertDomElementBefore: () => D0,
		IntegerToHexString: () => xn,
		IsDefined: () => so,
		IsDomElementVisible: () => k0,
		IsEqual: () => It,
		IsEqualEps: () => fp,
		IsGreater: () => Sc,
		IsGreaterOrEqual: () => uo,
		IsLower: () => lo,
		IsLowerOrEqual: () => co,
		IsModelEmpty: () => Io,
		IsNegative: () => Tr,
		IsObjectEmpty: () => mc,
		IsPositive: () => gi,
		IsPowerOfTwo: () => rd,
		IsTwoManifold: () => wh,
		IsUrl: () => lp,
		IsZero: () => Ms,
		LinearToSRGB: () => Ss,
		LinearTweenFunction: () => Ap,
		LoadExternalLibrary: () => Qi,
		MaterialBase: () => tl,
		MaterialType: () => In,
		Matrix: () => ln,
		MatrixIsEqual: () => Nc,
		Mesh: () => $t,
		MeshBuffer: () => rl,
		MeshInstance: () => br,
		MeshInstanceId: () => yi,
		MeshPrimitiveBuffer: () => il,
		MeshType: () => ir,
		Model: () => or,
		ModelObject3D: () => sr,
		ModelToThreeConversionOutput: () => Ha,
		ModelToThreeConversionParams: () => za,
		MouseInteraction: () => rc,
		NameFromLine: () => Vr,
		Navigation: () => Xa,
		NavigationType: () => Kn,
		NextPowerOfTwo: () => Wg,
		Node: () => Sn,
		Object3D: () => sl,
		Octree: () => Ao,
		OctreeNode: () => ll,
		ParabolicTweenFunction: () => Fc,
		ParameterConverter: () => on,
		ParameterListBuilder: () => ec,
		ParameterListParser: () => tc,
		ParametersFromLine: () => Xi,
		PhongMaterial: () => hn,
		PhysicalMaterial: () => qr,
		Property: () => Jt,
		PropertyGroup: () => Fn,
		PropertyToString: () => Pc,
		PropertyType: () => Bt,
		Quaternion: () => Xn,
		QuaternionFromAxisAngle: () => Lc,
		QuaternionFromXYZ: () => Ep,
		QuaternionIsEqual: () => Tp,
		RGBAColor: () => Er,
		RGBAColorToHexString: () => pp,
		RGBColor: () => Et,
		RGBColorFromFloatComponents: () => ai,
		RGBColorIsEqual: () => Mr,
		RGBColorToHexString: () => Ac,
		RadDeg: () => hp,
		ReadFile: () => Mc,
		ReadLines: () => Si,
		ReplaceDefaultMaterialColor: () => Cp,
		RequestUrl: () => Ec,
		RevokeObjectUrl: () => Ic,
		RunTaskAsync: () => $a,
		RunTasks: () => vc,
		RunTasksBatch: () => xc,
		SRGBToLinear: () => nr,
		SetDomElementHeight: () => $d,
		SetDomElementOuterHeight: () => z0,
		SetDomElementOuterWidth: () => V0,
		SetDomElementWidth: () => Jd,
		SetExternalLibLocation: () => ap,
		SetThreeMeshPolygonOffset: () => fh,
		ShadingModel: () => qa,
		ShadingType: () => Vn,
		ShowDomElement: () => U0,
		SubCoord2D: () => Qa,
		SubCoord3D: () => Mn,
		TaskRunner: () => ao,
		TextWriter: () => $n,
		TextureIsEqual: () => vp,
		TextureMap: () => Jn,
		TextureMapIsEqual: () => Xr,
		ThreeColorConverter: () => ya,
		ThreeConversionStateHandler: () => nc,
		ThreeLinearToSRGBColorConverter: () => Js,
		ThreeModelLoader: () => Wa,
		ThreeNodeTree: () => ic,
		ThreeSRGBToLinearColorConverter: () => va,
		Topology: () => Ro,
		TopologyEdge: () => ul,
		TopologyTriangle: () => fl,
		TopologyTriangleEdge: () => hl,
		TopologyVertex: () => cl,
		TouchInteraction: () => sc,
		TransformFileHostUrls: () => bc,
		TransformMesh: () => rr,
		Transformation: () => rn,
		TransformationIsEqual: () => Mp,
		TraverseThreeObject: () => xh,
		Triangle: () => Ht,
		TweenCoord3D: () => wo,
		Unit: () => Zr,
		UpVector: () => lc,
		UpdateMaterialTransparency: () => ni,
		Utf8StringToArrayBuffer: () => mo,
		ValueOrDefault: () => sp,
		VectorAngle3D: () => Cc,
		VectorLength3D: () => fo,
		Viewer: () => ja,
		ViewerMainModel: () => Va,
		ViewerModel: () => _s,
		WaitWhile: () => _c
	});

	function so(r) {
		return r != null
	}

	function sp(r, e) {
		return r ?? e
	}

	function oo(r, e) {
		if (so(r))
			for (let t of Object.keys(r)) so(r[t]) && (e[t] = r[t])
	}

	function mc(r) {
		return Object.keys(r).length === 0
	}

	function gc(r) {
		return r.replace(/</g, "&lt;").replace(/>/g, "&gt;")
	}
	var yc = class {
		constructor() {
			this.eventListeners = new Map
		}
		AddEventListener(e, t) {
			this.eventListeners.has(e) || this.eventListeners.set(e, []), this.eventListeners.get(e).push(t)
		}
		HasEventListener(e) {
			return this.eventListeners.has(e)
		}
		GetEventNotifier(e) {
			return () => {
				this.NotifyEventListeners(e)
			}
		}
		NotifyEventListeners(e, ...t) {
			if (!this.eventListeners.has(e)) return;
			let n = this.eventListeners.get(e);
			for (let i of n) i(...t)
		}
	};
	var ao = class {
		constructor() {
			this.count = null, this.current = null, this.callbacks = null
		}
		Run(e, t) {
			this.count = e, this.current = 0, this.callbacks = t, e === 0 ? this.TaskReady() : this.RunOnce()
		}
		RunBatch(e, t, n) {
			let i = 0;
			e > 0 && (i = parseInt((e - 1) / t, 10) + 1), this.Run(i, {
				runTask: (s, o) => {
					let a = s * t,
						l = Math.min((s + 1) * t, e) - 1;
					n.runTask(a, l, o)
				},
				onReady: n.onReady
			})
		}
		RunOnce() {
			setTimeout(() => {
				this.callbacks.runTask(this.current, this.TaskReady.bind(this))
			}, 0)
		}
		TaskReady() {
			this.current += 1, this.current < this.count ? this.RunOnce() : this.callbacks.onReady && this.callbacks.onReady()
		}
	};

	function $a(r) {
		setTimeout(() => {
			r()
		}, 10)
	}

	function vc(r, e) {
		new ao().Run(r, e)
	}

	function xc(r, e, t) {
		new ao().RunBatch(r, e, t)
	}

	function _c(r) {
		function e(t) {
			t() && setTimeout(() => {
				e(t)
			}, 10)
		}
		e(r)
	}
	var Tc = null,
		op = new Set;

	function ap(r) {
		Tc = r
	}

	function Es(r) {
		return Tc === null ? null : Tc + "/" + r
	}

	function Qi(r) {
		return new Promise((e, t) => {
			if (Tc === null) {
				t();
				return
			}
			if (op.has(r)) {
				e();
				return
			}
			let n = document.createElement("script");
			n.type = "text/javascript", n.src = Es(r), n.onload = () => {
				op.add(r), e()
			}, n.onerror = () => {
				t()
			}, document.head.appendChild(n)
		})
	}
	var Ii = {
			Url: 1,
			File: 2,
			Decompressed: 3
		},
		nn = {
			Text: 1,
			Binary: 2
		};

	function vn(r) {
		let e = r,
			t = e.indexOf("?");
		t !== -1 && (e = e.substring(0, t));
		let n = e.lastIndexOf("/");
		return n === -1 && (n = e.lastIndexOf("\\")), n !== -1 && (e = e.substring(n + 1)), decodeURI(e)
	}

	function er(r) {
		let e = vn(r),
			t = e.lastIndexOf(".");
		return t === -1 ? "" : e.substring(t + 1).toLowerCase()
	}

	function Ec(r, e) {
		return new Promise((t, n) => {
			let i = new XMLHttpRequest;
			i.open("GET", r, !0), i.onprogress = s => {
				e(s.loaded, s.total)
			}, i.onload = () => {
				i.status === 200 ? t(i.response) : n()
			}, i.onerror = () => {
				n()
			}, i.responseType = "arraybuffer", i.send(null)
		})
	}

	function Mc(r, e) {
		return new Promise((t, n) => {
			let i = new FileReader;
			i.onprogress = s => {
				e(s.loaded, s.total)
			}, i.onloadend = s => {
				s.target.readyState === FileReader.DONE && t(s.target.result)
			}, i.onerror = () => {
				n()
			}, i.readAsArrayBuffer(r)
		})
	}

	function bc(r) {
		for (let e = 0; e < r.length; e++) {
			let t = r[e];
			t.indexOf("www.dropbox.com") !== -1 ? (t = t.replace("www.dropbox.com", "dl.dropbox.com"), r[e] = t) : t.indexOf("github.com") !== -1 && (t = t.replace("github.com", "raw.githubusercontent.com"), t = t.replace("/blob", ""), r[e] = t)
		}
	}

	function lp(r) {
		let e = /^https?:\/\/\S+$/g;
		return r.match(e) !== null
	}
	var cp = 1e-8,
		up = 1e-4,
		hp = 57.29577951308232,
		tr = .017453292519943;

	function Ms(r) {
		return Math.abs(r) < 1e-8
	}

	function lo(r, e) {
		return e - r > 1e-8
	}

	function Sc(r, e) {
		return r - e > 1e-8
	}

	function co(r, e) {
		return e - r > -1e-8
	}

	function uo(r, e) {
		return r - e > -1e-8
	}

	function It(r, e) {
		return Math.abs(e - r) < 1e-8
	}

	function fp(r, e, t) {
		return Math.abs(e - r) < t
	}

	function gi(r) {
		return r > 1e-8
	}

	function Tr(r) {
		return r < -1e-8
	}
	var ht = {
		X: 1,
		Y: 2,
		Z: 3
	};
	var wt = class r {
		constructor(e, t) {
			this.x = e, this.y = t
		}
		Clone() {
			return new r(this.x, this.y)
		}
	};

	function Pi(r, e) {
		return It(r.x, e.x) && It(r.y, e.y)
	}

	function dp(r, e) {
		return new wt(r.x + e.x, r.y + e.y)
	}

	function Qa(r, e) {
		return new wt(r.x - e.x, r.y - e.y)
	}

	function el(r, e) {
		return Math.sqrt((r.x - e.x) * (r.x - e.x) + (r.y - e.y) * (r.y - e.y))
	}
	var Et = class r {
			constructor(e, t, n) {
				this.r = e, this.g = t, this.b = n
			}
			Set(e, t, n) {
				this.r = e, this.g = t, this.b = n
			}
			Clone() {
				return new r(this.r, this.g, this.b)
			}
		},
		Er = class r {
			constructor(e, t, n, i) {
				this.r = e, this.g = t, this.b = n, this.a = i
			}
			Set(e, t, n, i) {
				this.r = e, this.g = t, this.b = n, this.a = i
			}
			Clone() {
				return new r(this.r, this.g, this.b, this.a)
			}
		};

	function En(r) {
		return parseInt(Math.round(r * 255), 10)
	}

	function bs(r) {
		return r / 255
	}

	function ai(r, e, t) {
		return new Et(En(r), En(e), En(t))
	}

	function nr(r) {
		return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
	}

	function Ss(r) {
		return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
	}

	function xn(r) {
		let e = parseInt(r, 10).toString(16);
		for (; e.length < 2;) e = "0" + e;
		return e
	}

	function Ac(r) {
		let e = xn(r.r),
			t = xn(r.g),
			n = xn(r.b);
		return e + t + n
	}

	function pp(r) {
		let e = xn(r.r),
			t = xn(r.g),
			n = xn(r.b),
			i = xn(r.a);
		return e + t + n + i
	}

	function mp(r) {
		if (r.length !== 6) return null;
		let e = parseInt(r.substring(0, 2), 16),
			t = parseInt(r.substring(2, 4), 16),
			n = parseInt(r.substring(4, 6), 16);
		return new Et(e, t, n)
	}

	function gp(r) {
		if (r.length !== 6 && r.length !== 8) return null;
		let e = parseInt(r.substring(0, 2), 16),
			t = parseInt(r.substring(2, 4), 16),
			n = parseInt(r.substring(4, 6), 16),
			i = 255;
		return r.length === 8 && (i = parseInt(r.substring(6, 8), 16)), new Er(e, t, n, i)
	}

	function yp(r) {
		return new Et(r[0], r[1], r[2])
	}

	function Mr(r, e) {
		return r.r === e.r && r.g === e.g && r.b === e.b
	}
	var Jn = class {
		constructor() {
			this.name = null, this.mimeType = null, this.buffer = null, this.offset = new wt(0, 0), this.scale = new wt(1, 1), this.rotation = 0
		}
		IsValid() {
			return this.name !== null && this.buffer !== null
		}
		HasTransformation() {
			return !Pi(this.offset, new wt(0, 0)) || !Pi(this.scale, new wt(1, 1)) || !It(this.rotation, 0)
		}
		IsEqual(e) {
			return !(this.name !== e.name || this.mimeType !== e.mimeType || !Pi(this.offset, e.offset) || !Pi(this.scale, e.scale) || !It(this.rotation, e.rotation))
		}
	};

	function Xr(r, e) {
		return r === null && e === null ? !0 : r === null || e === null ? !1 : r.IsEqual(e)
	}
	var In = {
			Phong: 1,
			Physical: 2
		},
		tl = class {
			constructor(e) {
				this.type = e, this.isDefault = !1, this.name = "", this.color = new Et(0, 0, 0), this.vertexColors = !1
			}
			IsEqual(e) {
				return !(this.type !== e.type || this.isDefault !== e.isDefault || this.name !== e.name || !Mr(this.color, e.color) || this.vertexColors !== e.vertexColors)
			}
		},
		ho = class extends tl {
			constructor(e) {
				super(e), this.emissive = new Et(0, 0, 0), this.opacity = 1, this.transparent = !1, this.diffuseMap = null, this.bumpMap = null, this.normalMap = null, this.emissiveMap = null, this.alphaTest = 0, this.multiplyDiffuseMap = !1
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !Mr(this.emissive, e.emissive) || !It(this.opacity, e.opacity) || this.transparent !== e.transparent || !Xr(this.diffuseMap, e.diffuseMap) || !Xr(this.bumpMap, e.bumpMap) || !Xr(this.normalMap, e.normalMap) || !Xr(this.emissiveMap, e.emissiveMap) || !It(this.alphaTest, e.alphaTest) || this.multiplyDiffuseMap !== e.multiplyDiffuseMap)
			}
		},
		hn = class extends ho {
			constructor() {
				super(In.Phong), this.ambient = new Et(0, 0, 0), this.specular = new Et(0, 0, 0), this.shininess = 0, this.specularMap = null
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !Mr(this.ambient, e.ambient) || !Mr(this.specular, e.specular) || !It(this.shininess, e.shininess) || !Xr(this.specularMap, e.specularMap))
			}
		},
		qr = class extends ho {
			constructor() {
				super(In.Physical), this.metalness = 0, this.roughness = 1, this.metalnessMap = null
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !It(this.metalness, e.metalness) || !It(this.roughness, e.roughness) || !Xr(this.metalnessMap, e.metalnessMap))
			}
		};

	function vp(r, e) {
		return !(r.name !== e.name || r.mimeType !== e.mimeType || !Pi(r.offset, e.offset) || !Pi(r.scale, e.scale) || !It(r.rotation, e.rotation))
	}
	var He = class r {
		constructor(e, t, n) {
			this.x = e, this.y = t, this.z = n
		}
		Length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		}
		MultiplyScalar(e) {
			return this.x *= e, this.y *= e, this.z *= e, this
		}
		Normalize() {
			let e = this.Length();
			return e > 0 && this.MultiplyScalar(1 / e), this
		}
		Offset(e, t) {
			let n = e.Clone().Normalize();
			return this.x += n.x * t, this.y += n.y * t, this.z += n.z * t, this
		}
		Rotate(e, t, n) {
			let i = e.Clone().Normalize(),
				s = i.x,
				o = i.y,
				a = i.z,
				l = this.x - n.x,
				c = this.y - n.y,
				u = this.z - n.z,
				h = Math.sin(t),
				f = Math.cos(t);
			return this.x = -s * (-s * l - o * c - a * u) * (1 - f) + l * f + (-a * c + o * u) * h, this.y = -o * (-s * l - o * c - a * u) * (1 - f) + c * f + (a * l - s * u) * h, this.z = -a * (-s * l - o * c - a * u) * (1 - f) + u * f + (-o * l + s * c) * h, this.x += n.x, this.y += n.y, this.z += n.z, this
		}
		Clone() {
			return new r(this.x, this.y, this.z)
		}
	};

	function li(r, e) {
		return It(r.x, e.x) && It(r.y, e.y) && It(r.z, e.z)
	}

	function wc(r, e) {
		return new He(r.x + e.x, r.y + e.y, r.z + e.z)
	}

	function Mn(r, e) {
		return new He(r.x - e.x, r.y - e.y, r.z - e.z)
	}

	function Wn(r, e) {
		return Math.sqrt((r.x - e.x) * (r.x - e.x) + (r.y - e.y) * (r.y - e.y) + (r.z - e.z) * (r.z - e.z))
	}

	function nl(r, e) {
		return r.x * e.x + r.y * e.y + r.z * e.z
	}

	function Cc(r, e) {
		let t = r.Clone().Normalize(),
			n = e.Clone().Normalize();
		if (li(t, n)) return 0;
		let i = nl(t, n);
		return Math.acos(i)
	}

	function Li(r, e) {
		let t = new He(0, 0, 0);
		return t.x = r.y * e.z - r.z * e.y, t.y = r.z * e.x - r.x * e.z, t.z = r.x * e.y - r.y * e.x, t
	}

	function fo(r, e, t) {
		return Math.sqrt(r * r + e * e + t * t)
	}

	function jr(r) {
		return new He(r[0], r[1], r[2])
	}
	var il = class {
			constructor() {
				this.indices = [], this.vertices = [], this.colors = [], this.normals = [], this.uvs = [], this.material = null
			}
			GetBounds() {
				let e = [1 / 0, 1 / 0, 1 / 0],
					t = [-1 / 0, -1 / 0, -1 / 0];
				for (let n = 0; n < this.vertices.length / 3; n++)
					for (let i = 0; i < 3; i++) e[i] = Math.min(e[i], this.vertices[n * 3 + i]), t[i] = Math.max(t[i], this.vertices[n * 3 + i]);
				return {
					min: e,
					max: t
				}
			}
			GetByteLength(e, t) {
				let n = this.indices.length,
					i = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;
				return n * e + i * t
			}
		},
		rl = class {
			constructor() {
				this.primitives = []
			}
			PrimitiveCount() {
				return this.primitives.length
			}
			GetPrimitive(e) {
				return this.primitives[e]
			}
			GetByteLength(e, t) {
				let n = 0;
				for (let i = 0; i < this.primitives.length; i++) {
					let s = this.primitives[i];
					n += s.GetByteLength(e, t)
				}
				return n
			}
		};

	function po(r) {
		function e(a, l, c, u) {
			function h(y, d, p) {
				return d !== null ? y.GetVertexColor(d) : p ? new Et(0, 0, 0) : null
			}

			function f(y, d, p) {
				return d !== null ? y.GetTextureUV(d) : p ? new wt(0, 0) : null
			}

			function m(y, d, p) {
				let _ = y.VertexColorCount() > 0,
					v = y.TextureUVCount() > 0,
					x = y.GetVertex(d.vertex),
					M = y.GetNormal(d.normal),
					I = p.vertices.length / 3;
				p.indices.push(I), p.vertices.push(x.x, x.y, x.z);
				let w = h(y, d.color, _);
				w !== null && p.colors.push(w.r / 255, w.g / 255, w.b / 255), p.normals.push(M.x, M.y, M.z);
				let L = f(y, d.uv, v);
				return L !== null && p.uvs.push(L.x, L.y), {
					index: I,
					color: w,
					normal: M,
					uv: L
				}
			}

			function g(y, d, p) {
				function _(M, I, w) {
					if (w === null && I === null) return !0;
					let L = h(M, I, !0);
					return Mr(w, L)
				}

				function v(M, I, w) {
					let L = M.GetNormal(I);
					return li(w, L)
				}

				function x(M, I, w) {
					if (w === null && I === null) return !0;
					let L = f(M, I, !0);
					return Pi(w, L)
				}
				for (let M = 0; M < d.length; M++) {
					let I = d[M],
						w = _(y, p.color, I.color),
						L = v(y, p.normal, I.normal),
						T = x(y, p.uv, I.uv);
					if (w && L && T) return I
				}
				return null
			}
			if (u.has(l.vertex)) {
				let y = u.get(l.vertex),
					d = g(a, y, l);
				if (d !== null) c.indices.push(d.index);
				else {
					let p = m(a, l, c);
					y.push(p)
				}
			} else {
				let y = m(a, l, c);
				u.set(l.vertex, [y])
			}
		}
		let t = new rl,
			n = r.TriangleCount();
		if (n === 0) return null;
		let i = [];
		for (let a = 0; a < n; a++) i.push(a);
		i.sort((a, l) => {
			let c = r.GetTriangle(a),
				u = r.GetTriangle(l);
			return c.mat - u.mat
		});
		let s = null,
			o = null;
		for (let a = 0; a < i.length; a++) {
			let l = i[a],
				c = r.GetTriangle(l);
			(s === null || s.material !== c.mat) && (s = new il, s.material = c.mat, o = new Map, t.primitives.push(s));
			let u = {
					vertex: c.v0,
					color: c.c0,
					normal: c.n0,
					uv: c.u0
				},
				h = {
					vertex: c.v1,
					color: c.c1,
					normal: c.n1,
					uv: c.u1
				},
				f = {
					vertex: c.v2,
					color: c.c2,
					normal: c.n2,
					uv: c.u2
				};
			e(r, u, s, o), e(r, h, s, o), e(r, f, s, o)
		}
		return t
	}

	function fn(r) {
		return new TextDecoder("utf-8").decode(r)
	}

	function xp(r) {
		let e = "",
			t = new Uint8Array(r);
		for (let n = 0; n < t.byteLength; n++) e += String.fromCharCode(t[n]);
		return e
	}

	function _p(r) {
		let e = new ArrayBuffer(r.length),
			t = new Uint8Array(e);
		for (let n = 0; n < r.length; n++) t[n] = r.charCodeAt(n);
		return e
	}

	function mo(r) {
		return new TextEncoder().encode(r).buffer
	}

	function As(r) {
		let e = "data:";
		if (!r.startsWith(e)) return null;
		let t = r.indexOf(";");
		if (t === -1) return null;
		let n = r.indexOf(",");
		if (n === -1) return null;
		let i = r.substring(e.length, e.length + t - 5),
			s = atob(r.substring(n + 1)),
			o = new ArrayBuffer(s.length),
			a = new Uint8Array(o);
		for (let l = 0; l < s.length; l++) a[l] = s.charCodeAt(l);
		return {
			mimeType: i,
			buffer: o
		}
	}

	function Yr(r) {
		if (r == null) return "";
		let e = r.split("/");
		return e.length === 0 ? "" : e[e.length - 1]
	}

	function ws(r) {
		let e = new Blob([r]);
		return URL.createObjectURL(e)
	}

	function Rc(r, e) {
		let t = new Blob([r], {
			type: e
		});
		return URL.createObjectURL(t)
	}

	function Ic(r) {
		URL.revokeObjectURL(r)
	}
	var jt = class {
			constructor(e) {
				this.name = e, this.content = null
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			GetTextContent() {
				return fn(this.content)
			}
			GetBufferContent() {
				return this.content
			}
			SetTextContent(e) {
				let t = mo(e);
				this.content = t
			}
			SetBufferContent(e) {
				this.content = e
			}
		},
		bn = class {
			constructor() {}
			CanExport(e, t) {
				return !1
			}
			Export(e, t, n) {
				let i = [];
				this.ExportContent(e, t, i, () => {
					n(i)
				})
			}
			ExportContent(e, t, n, i) {}
			GetExportedMaterialName(e) {
				return this.GetExportedName(e, "Material")
			}
			GetExportedMeshName(e) {
				return this.GetExportedName(e, "Mesh")
			}
			GetExportedName(e, t) {
				return e.length === 0 ? t : e
			}
		};
	var go = class extends bn {
		constructor() {
			super(), this.rhino = null
		}
		CanExport(e, t) {
			return e === nn.Binary && t === "3dm"
		}
		ExportContent(e, t, n, i) {
			this.rhino === null ? Qi("loaders/rhino3dm.min.js").then(() => {
				rhino3dm().then(s => {
					this.rhino = s, this.ExportRhinoContent(e, n, i)
				})
			}).catch(() => {
				i()
			}) : this.ExportRhinoContent(e, n, i)
		}
		ExportRhinoContent(e, t, n) {
			function i(c) {
				return {
					r: c.r,
					g: c.g,
					b: c.b,
					a: 255
				}
			}
			let s = new jt("model.3dm");
			t.push(s);
			let o = new this.rhino.File3dm;
			e.EnumerateTransformedMeshInstances(c => {
				let u = po(c);
				for (let h = 0; h < u.PrimitiveCount(); h++) {
					let f = u.GetPrimitive(h),
						m = {
							data: {
								attributes: {
									position: {
										itemSize: 3,
										type: "Float32Array",
										array: f.vertices
									},
									normal: {
										itemSize: 3,
										type: "Float32Array",
										array: f.normals
									}
								},
								index: {
									type: "Uint16Array",
									array: f.indices
								}
							}
						},
						g = e.GetMaterial(f.material),
						y = new this.rhino.Material;
					y.name = this.GetExportedMaterialName(g.name), g.type === In.Phong && (y.ambientColor = i(g.ambient), y.specularColor = i(g.specular)), y.diffuseColor = i(g.color), y.transparency = 1 - g.opacity;
					let d = o.materials().count();
					o.materials().add(y);
					let p = new this.rhino.Mesh.createFromThreejsJSON(m),
						_ = new this.rhino.ObjectAttributes;
					_.name = this.GetExportedMeshName(c.GetName()), _.materialSource = this.rhino.ObjectMaterialSource.MaterialFromObject, _.materialIndex = d, o.objects().add(p, _)
				}
			});
			let a = new this.rhino.File3dmWriteOptions;
			a.version = 6;
			let l = o.toByteArray(a);
			s.SetBufferContent(l), n()
		}
	};
	var Bt = {
			Text: 1,
			Integer: 2,
			Number: 3,
			Boolean: 4,
			Percent: 5,
			Color: 6
		},
		Jt = class r {
			constructor(e, t, n) {
				this.type = e, this.name = t, this.value = n
			}
			Clone() {
				return this.type === Bt.Color ? new r(this.type, this.name, this.value.Clone()) : new r(this.type, this.name, this.value)
			}
		},
		Fn = class r {
			constructor(e) {
				this.name = e, this.properties = []
			}
			PropertyCount() {
				return this.properties.length
			}
			AddProperty(e) {
				this.properties.push(e)
			}
			GetProperty(e) {
				return this.properties[e]
			}
			Clone() {
				let e = new r(this.name);
				for (let t of this.properties) e.AddProperty(t.Clone());
				return e
			}
		};

	function Pc(r) {
		return r.type === Bt.Text ? gc(r.value) : r.type === Bt.Integer ? r.value.toLocaleString() : r.type === Bt.Number ? r.value.toLocaleString(void 0, {
			minimumFractionDigits: 2,
			maximumFractionDigits: 2
		}) : r.type === Bt.Boolean ? r.value ? "True" : "False" : r.type === Bt.Percent ? parseInt(r.value * 100, 10).toString() + "%" : r.type === Bt.Color ? "#" + Ac(r.value) : null
	}

	function ey() {
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e => {
			let t = Math.random() * 16 | 0;
			return (e === "x" ? t : t & 3 | 8).toString(16)
		})
	}
	var yo = class extends bn {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === nn.Text && t === "bim"
		}
		ExportContent(e, t, n, i) {
			let s = {
				schema_version: "1.1.0",
				meshes: [],
				elements: [],
				info: {}
			};
			this.ExportProperties(e.GetModel(), s.info);
			let o = 0;
			e.EnumerateTransformedMeshInstances(l => {
				let c = {
					mesh_id: o,
					coordinates: [],
					indices: []
				};
				l.EnumerateVertices(g => {
					c.coordinates.push(g.x, g.y, g.z)
				}), l.EnumerateTriangleVertexIndices((g, y, d) => {
					c.indices.push(g, y, d)
				});
				let u = {
						mesh_id: o,
						type: "Other",
						color: {
							r: 200,
							g: 200,
							b: 200,
							a: 255
						},
						vector: {
							x: 0,
							y: 0,
							z: 0
						},
						rotation: {
							qx: 0,
							qy: 0,
							qz: 0,
							qw: 1
						},
						guid: ey(),
						info: {}
					},
					h = null,
					f = !0,
					m = [];
				for (let g = 0; g < l.TriangleCount(); g++) {
					let y = l.GetTriangle(g),
						d = e.GetMaterial(y.mat),
						p = {
							r: d.color.r,
							g: d.color.g,
							b: d.color.b,
							a: En(d.opacity)
						};
					m.push(p.r, p.g, p.b, p.a), f && (h === null ? h = p : (h.r !== p.r || h.g !== p.g || h.b !== p.b || h.a !== p.a) && (f = !1, h = null))
				}
				f ? u.color = h : u.face_colors = m, u.info.Name = l.GetName(), this.ExportProperties(l, u.info), s.meshes.push(c), s.elements.push(u), o += 1
			});
			let a = new jt("model.bim");
			a.SetTextContent(JSON.stringify(s, null, 4)), n.push(a), i()
		}
		ExportProperties(e, t) {
			for (let n = 0; n < e.PropertyGroupCount(); n++) {
				let i = e.GetPropertyGroup(n);
				for (let s = 0; s < i.PropertyCount(); s++) {
					let o = i.GetProperty(s);
					t[o.name] = Pc(o)
				}
			}
		}
	};
	var Ni = class {
		constructor(e, t) {
			this.arrayBuffer = new ArrayBuffer(e), this.dataView = new DataView(this.arrayBuffer), this.isLittleEndian = t, this.position = 0
		}
		GetPosition() {
			return this.position
		}
		SetPosition(e) {
			this.position = e
		}
		End() {
			return this.position >= this.arrayBuffer.byteLength
		}
		GetBuffer() {
			return this.arrayBuffer
		}
		WriteArrayBuffer(e) {
			let t = new Uint8Array(e);
			new Uint8Array(this.arrayBuffer).set(t, this.position), this.position += e.byteLength
		}
		WriteBoolean8(e) {
			this.dataView.setInt8(this.position, e ? 1 : 0), this.position = this.position + 1
		}
		WriteCharacter8(e) {
			this.dataView.setInt8(this.position, e), this.position = this.position + 1
		}
		WriteUnsignedCharacter8(e) {
			this.dataView.setUint8(this.position, e), this.position = this.position + 1
		}
		WriteInteger16(e) {
			this.dataView.setInt16(this.position, e, this.isLittleEndian), this.position = this.position + 2
		}
		WriteUnsignedInteger16(e) {
			this.dataView.setUint16(this.position, e, this.isLittleEndian), this.position = this.position + 2
		}
		WriteInteger32(e) {
			this.dataView.setInt32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteUnsignedInteger32(e) {
			this.dataView.setUint32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteFloat32(e) {
			this.dataView.setFloat32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteDouble64(e) {
			this.dataView.setFloat64(this.position, e, this.isLittleEndian), this.position = this.position + 8
		}
	};
	var Oi = class r {
		constructor(e, t, n, i) {
			this.x = e, this.y = t, this.z = n, this.w = i
		}
		Clone() {
			return new r(this.x, this.y, this.z, this.w)
		}
	};
	var Xn = class {
		constructor(e, t, n, i) {
			this.x = e, this.y = t, this.z = n, this.w = i
		}
	};

	function Tp(r, e) {
		return It(r.x, e.x) && It(r.y, e.y) && It(r.z, e.z) && It(r.w, e.w)
	}

	function vo(r) {
		return new Xn(r[0], r[1], r[2], r[3])
	}

	function Lc(r, e) {
		let t = e / 2,
			n = Math.sin(t);
		return new Xn(r.x * n, r.y * n, r.z * n, Math.cos(t))
	}

	function Ep(r, e, t, n) {
		let i = Math.cos(r / 2),
			s = Math.cos(e / 2),
			o = Math.cos(t / 2),
			a = Math.sin(r / 2),
			l = Math.sin(e / 2),
			c = Math.sin(t / 2),
			u = new Xn(0, 0, 0, 1);
		if (n === "XYZ") u.x = a * s * o + i * l * c, u.y = i * l * o - a * s * c, u.z = i * s * c + a * l * o, u.w = i * s * o - a * l * c;
		else if (n === "YXZ") u.x = a * s * o + i * l * c, u.y = i * l * o - a * s * c, u.z = i * s * c - a * l * o, u.w = i * s * o + a * l * c;
		else if (n === "ZXY") u.x = a * s * o - i * l * c, u.y = i * l * o + a * s * c, u.z = i * s * c + a * l * o, u.w = i * s * o - a * l * c;
		else if (n === "ZYX") u.x = a * s * o - i * l * c, u.y = i * l * o + a * s * c, u.z = i * s * c - a * l * o, u.w = i * s * o + a * l * c;
		else if (n === "YZX") u.x = a * s * o + i * l * c, u.y = i * l * o + a * s * c, u.z = i * s * c - a * l * o, u.w = i * s * o - a * l * c;
		else if (n === "XZY") u.x = a * s * o - i * l * c, u.y = i * l * o - a * s * c, u.z = i * s * c + a * l * o, u.w = i * s * o + a * l * c;
		else return null;
		return u
	}
	var ln = class r {
		constructor(e) {
			this.matrix = null, e != null && (this.matrix = e)
		}
		IsValid() {
			return this.matrix !== null
		}
		Set(e) {
			return this.matrix = e, this
		}
		Get() {
			return this.matrix
		}
		Clone() {
			let e = [this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], this.matrix[6], this.matrix[7], this.matrix[8], this.matrix[9], this.matrix[10], this.matrix[11], this.matrix[12], this.matrix[13], this.matrix[14], this.matrix[15]];
			return new r(e)
		}
		CreateIdentity() {
			return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this
		}
		IsIdentity() {
			let e = new r().CreateIdentity().Get();
			for (let t = 0; t < 16; t++)
				if (!It(this.matrix[t], e[t])) return !1;
			return !0
		}
		CreateTranslation(e, t, n) {
			return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, n, 1], this
		}
		CreateRotation(e, t, n, i) {
			let s = e + e,
				o = t + t,
				a = n + n,
				l = e * s,
				c = e * o,
				u = e * a,
				h = t * o,
				f = t * a,
				m = n * a,
				g = i * s,
				y = i * o,
				d = i * a;
			return this.matrix = [1 - (h + m), c + d, u - y, 0, c - d, 1 - (l + m), f + g, 0, u + y, f - g, 1 - (l + h), 0, 0, 0, 0, 1], this
		}
		CreateRotationAxisAngle(e, t) {
			let n = Lc(e, t);
			return this.CreateRotation(n.x, n.y, n.z, n.w)
		}
		CreateScale(e, t, n) {
			return this.matrix = [e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1], this
		}
		ComposeTRS(e, t, n) {
			let i = e.x,
				s = e.y,
				o = e.z,
				a = t.x,
				l = t.y,
				c = t.z,
				u = t.w,
				h = n.x,
				f = n.y,
				m = n.z,
				g = a + a,
				y = l + l,
				d = c + c,
				p = a * g,
				_ = a * y,
				v = a * d,
				x = l * y,
				M = l * d,
				I = c * d,
				w = u * g,
				L = u * y,
				T = u * d;
			return this.matrix = [(1 - (x + I)) * h, (_ + T) * h, (v - L) * h, 0, (_ - T) * f, (1 - (p + I)) * f, (M + w) * f, 0, (v + L) * m, (M - w) * m, (1 - (p + x)) * m, 0, i, s, o, 1], this
		}
		DecomposeTRS() {
			let e = new He(this.matrix[12], this.matrix[13], this.matrix[14]),
				t = fo(this.matrix[0], this.matrix[1], this.matrix[2]),
				n = fo(this.matrix[4], this.matrix[5], this.matrix[6]),
				i = fo(this.matrix[8], this.matrix[9], this.matrix[10]),
				s = this.Determinant();
			Tr(s) && (t *= -1);
			let o = new He(t, n, i),
				a = this.matrix[0] / t,
				l = this.matrix[4] / n,
				c = this.matrix[8] / i,
				u = this.matrix[1] / t,
				h = this.matrix[5] / n,
				f = this.matrix[9] / i,
				m = this.matrix[2] / t,
				g = this.matrix[6] / n,
				y = this.matrix[10] / i,
				d = null,
				p = a + h + y;
			if (p > 0) {
				let _ = Math.sqrt(p + 1) * 2;
				d = new Xn((g - f) / _, (c - m) / _, (u - l) / _, .25 * _)
			} else if (a > h && a > y) {
				let _ = Math.sqrt(1 + a - h - y) * 2;
				d = new Xn(.25 * _, (l + u) / _, (c + m) / _, (g - f) / _)
			} else if (h > y) {
				let _ = Math.sqrt(1 + h - a - y) * 2;
				d = new Xn((l + u) / _, .25 * _, (f + g) / _, (c - m) / _)
			} else {
				let _ = Math.sqrt(1 + y - a - h) * 2;
				d = new Xn((c + m) / _, (f + g) / _, .25 * _, (u - l) / _)
			}
			return {
				translation: e,
				rotation: d,
				scale: o
			}
		}
		Determinant() {
			let e = this.matrix[0],
				t = this.matrix[1],
				n = this.matrix[2],
				i = this.matrix[3],
				s = this.matrix[4],
				o = this.matrix[5],
				a = this.matrix[6],
				l = this.matrix[7],
				c = this.matrix[8],
				u = this.matrix[9],
				h = this.matrix[10],
				f = this.matrix[11],
				m = this.matrix[12],
				g = this.matrix[13],
				y = this.matrix[14],
				d = this.matrix[15],
				p = e * o - t * s,
				_ = e * a - n * s,
				v = e * l - i * s,
				x = t * a - n * o,
				M = t * l - i * o,
				I = n * l - i * a,
				w = c * g - u * m,
				L = c * y - h * m,
				T = c * d - f * m,
				C = u * y - h * g,
				V = u * d - f * g,
				k = h * d - f * y;
			return p * k - _ * V + v * C + x * T - M * L + I * w
		}
		Invert() {
			let e = this.matrix[0],
				t = this.matrix[1],
				n = this.matrix[2],
				i = this.matrix[3],
				s = this.matrix[4],
				o = this.matrix[5],
				a = this.matrix[6],
				l = this.matrix[7],
				c = this.matrix[8],
				u = this.matrix[9],
				h = this.matrix[10],
				f = this.matrix[11],
				m = this.matrix[12],
				g = this.matrix[13],
				y = this.matrix[14],
				d = this.matrix[15],
				p = e * o - t * s,
				_ = e * a - n * s,
				v = e * l - i * s,
				x = t * a - n * o,
				M = t * l - i * o,
				I = n * l - i * a,
				w = c * g - u * m,
				L = c * y - h * m,
				T = c * d - f * m,
				C = u * y - h * g,
				V = u * d - f * g,
				k = h * d - f * y,
				F = p * k - _ * V + v * C + x * T - M * L + I * w;
			if (It(F, 0)) return null;
			let U = [(o * k - a * V + l * C) / F, (n * V - t * k - i * C) / F, (g * I - y * M + d * x) / F, (h * M - u * I - f * x) / F, (a * T - s * k - l * L) / F, (e * k - n * T + i * L) / F, (y * v - m * I - d * _) / F, (c * I - h * v + f * _) / F, (s * V - o * T + l * w) / F, (t * T - e * V - i * w) / F, (m * M - g * v + d * p) / F, (u * v - c * M - f * p) / F, (o * L - s * C - a * w) / F, (e * C - t * L + n * w) / F, (g * _ - m * x - y * p) / F, (c * x - u * _ + h * p) / F];
			return new r(U)
		}
		Transpose() {
			let e = [this.matrix[0], this.matrix[4], this.matrix[8], this.matrix[12], this.matrix[1], this.matrix[5], this.matrix[9], this.matrix[13], this.matrix[2], this.matrix[6], this.matrix[10], this.matrix[14], this.matrix[3], this.matrix[7], this.matrix[11], this.matrix[15]];
			return new r(e)
		}
		InvertTranspose() {
			let e = this.Invert();
			return e === null ? null : e.Transpose()
		}
		MultiplyVector(e) {
			let t = e.x,
				n = e.y,
				i = e.z,
				s = e.w,
				o = this.matrix[0],
				a = this.matrix[1],
				l = this.matrix[2],
				c = this.matrix[3],
				u = this.matrix[4],
				h = this.matrix[5],
				f = this.matrix[6],
				m = this.matrix[7],
				g = this.matrix[8],
				y = this.matrix[9],
				d = this.matrix[10],
				p = this.matrix[11],
				_ = this.matrix[12],
				v = this.matrix[13],
				x = this.matrix[14],
				M = this.matrix[15];
			return new Oi(t * o + n * u + i * g + s * _, t * a + n * h + i * y + s * v, t * l + n * f + i * d + s * x, t * c + n * m + i * p + s * M)
		}
		MultiplyMatrix(e) {
			let t = this.matrix[0],
				n = this.matrix[1],
				i = this.matrix[2],
				s = this.matrix[3],
				o = this.matrix[4],
				a = this.matrix[5],
				l = this.matrix[6],
				c = this.matrix[7],
				u = this.matrix[8],
				h = this.matrix[9],
				f = this.matrix[10],
				m = this.matrix[11],
				g = this.matrix[12],
				y = this.matrix[13],
				d = this.matrix[14],
				p = this.matrix[15],
				_ = e.matrix[0],
				v = e.matrix[1],
				x = e.matrix[2],
				M = e.matrix[3],
				I = e.matrix[4],
				w = e.matrix[5],
				L = e.matrix[6],
				T = e.matrix[7],
				C = e.matrix[8],
				V = e.matrix[9],
				k = e.matrix[10],
				F = e.matrix[11],
				U = e.matrix[12],
				K = e.matrix[13],
				Z = e.matrix[14],
				Y = e.matrix[15],
				H = [t * _ + n * I + i * C + s * U, t * v + n * w + i * V + s * K, t * x + n * L + i * k + s * Z, t * M + n * T + i * F + s * Y, o * _ + a * I + l * C + c * U, o * v + a * w + l * V + c * K, o * x + a * L + l * k + c * Z, o * M + a * T + l * F + c * Y, u * _ + h * I + f * C + m * U, u * v + h * w + f * V + m * K, u * x + h * L + f * k + m * Z, u * M + h * T + f * F + m * Y, g * _ + y * I + d * C + p * U, g * v + y * w + d * V + p * K, g * x + y * L + d * k + p * Z, g * M + y * T + d * F + p * Y];
			return new r(H)
		}
	};

	function Nc(r, e) {
		let t = r.Get(),
			n = e.Get();
		for (let i = 0; i < 16; i++)
			if (!It(t[i], n[i])) return !1;
		return !0
	}
	var rn = class r {
		constructor(e) {
			e != null ? this.matrix = e : (this.matrix = new ln, this.matrix.CreateIdentity())
		}
		SetMatrix(e) {
			return this.matrix = e, this
		}
		GetMatrix() {
			return this.matrix
		}
		IsIdentity() {
			return this.matrix.IsIdentity()
		}
		AppendMatrix(e) {
			return this.matrix = this.matrix.MultiplyMatrix(e), this
		}
		Append(e) {
			return this.AppendMatrix(e.GetMatrix()), this
		}
		TransformCoord3D(e) {
			let t = new Oi(e.x, e.y, e.z, 1),
				n = this.matrix.MultiplyVector(t);
			return new He(n.x, n.y, n.z)
		}
		Clone() {
			let e = this.matrix.Clone();
			return new r(e)
		}
	};

	function Mp(r, e) {
		return Nc(r.GetMatrix(), e.GetMatrix())
	}
	var ir = {
		Empty: 0,
		TriangleMesh: 1
	};

	function Kr(r) {
		return r.TriangleCount() > 0 ? ir.TriangleMesh : ir.Empty
	}

	function Cs(r, e, t) {
		let n = Mn(e, r),
			i = Mn(t, r),
			s = Li(n, i);
		return s.Normalize(), s
	}

	function rr(r, e) {
		if (!e.IsIdentity()) {
			for (let t = 0; t < r.VertexCount(); t++) {
				let n = r.GetVertex(t),
					i = e.TransformCoord3D(n);
				n.x = i.x, n.y = i.y, n.z = i.z
			}
			if (r.NormalCount() > 0) {
				let t = e.GetMatrix().InvertTranspose();
				if (t !== null) {
					let n = new rn(t);
					for (let i = 0; i < r.NormalCount(); i++) {
						let s = r.GetNormal(i),
							o = n.TransformCoord3D(s);
						s.x = o.x, s.y = o.y, s.z = o.z
					}
				}
			}
		}
	}

	function Oc(r) {
		for (let e = 0; e < r.TriangleCount(); e++) {
			let t = r.GetTriangle(e),
				n = t.v1;
			t.v1 = t.v2, t.v2 = n
		}
	}
	var sl = class {
			constructor() {}
			VertexCount() {
				return 0
			}
			VertexColorCount() {
				return 0
			}
			NormalCount() {
				return 0
			}
			TextureUVCount() {
				return 0
			}
			TriangleCount() {
				return 0
			}
			EnumerateVertices(e) {}
			EnumerateTriangleVertexIndices(e) {}
			EnumerateTriangleVertices(e) {}
		},
		sr = class extends sl {
			constructor() {
				super(), this.name = "", this.propertyGroups = []
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			PropertyGroupCount() {
				return this.propertyGroups.length
			}
			AddPropertyGroup(e) {
				return this.propertyGroups.push(e), this.propertyGroups.length - 1
			}
			GetPropertyGroup(e) {
				return this.propertyGroups[e]
			}
			CloneProperties(e) {
				for (let t of this.propertyGroups) e.AddPropertyGroup(t.Clone())
			}
		};
	var yi = class {
			constructor(e, t) {
				this.nodeId = e, this.meshIndex = t
			}
			IsEqual(e) {
				return this.nodeId === e.nodeId && this.meshIndex === e.meshIndex
			}
			GetKey() {
				return this.nodeId.toString() + ":" + this.meshIndex.toString()
			}
		},
		br = class extends sr {
			constructor(e, t, n) {
				super(), this.id = e, this.node = t, this.mesh = n
			}
			GetId() {
				return this.id
			}
			GetTransformation() {
				return this.node.GetWorldTransformation()
			}
			GetMesh() {
				return this.mesh
			}
			VertexCount() {
				return this.mesh.VertexCount()
			}
			VertexColorCount() {
				return this.mesh.VertexColorCount()
			}
			NormalCount() {
				return this.mesh.NormalCount()
			}
			TextureUVCount() {
				return this.mesh.TextureUVCount()
			}
			TriangleCount() {
				return this.mesh.TriangleCount()
			}
			EnumerateVertices(e) {
				let t = this.node.GetWorldTransformation();
				t.IsIdentity() ? this.mesh.EnumerateVertices(e) : this.mesh.EnumerateVertices(n => {
					let i = t.TransformCoord3D(n);
					e(i)
				})
			}
			EnumerateTriangleVertexIndices(e) {
				this.mesh.EnumerateTriangleVertexIndices(e)
			}
			EnumerateTriangleVertices(e) {
				let t = this.node.GetWorldTransformation();
				t.IsIdentity() ? this.mesh.EnumerateTriangleVertices(e) : this.mesh.EnumerateTriangleVertices((n, i, s) => {
					let o = t.TransformCoord3D(n),
						a = t.TransformCoord3D(i),
						l = t.TransformCoord3D(s);
					e(o, a, l)
				})
			}
			PropertyGroupCount() {
				return this.mesh.PropertyGroupCount()
			}
			AddPropertyGroup(e) {
				return this.mesh.AddPropertyGroup(e)
			}
			GetPropertyGroup(e) {
				return this.mesh.GetPropertyGroup(e)
			}
			GetTransformedMesh() {
				let e = this.node.GetWorldTransformation(),
					t = this.mesh.Clone();
				return rr(t, e), t
			}
		};
	var bp = {
			UNSIGNED_INT: 5125,
			FLOAT: 5126
		},
		ol = {
			ARRAY_BUFFER: 34962,
			ELEMENT_ARRAY_BUFFER: 34963
		},
		xo = class extends bn {
			constructor() {
				super(), this.components = {
					index: {
						type: bp.UNSIGNED_INT,
						size: 4
					},
					number: {
						type: bp.FLOAT,
						size: 4
					}
				}
			}
			CanExport(e, t) {
				return e === nn.Text && t === "gltf" || e === nn.Binary && t === "glb"
			}
			ExportContent(e, t, n, i) {
				t === nn.Text ? this.ExportAsciiContent(e, n) : t === nn.Binary && this.ExportBinaryContent(e, n), i()
			}
			ExportAsciiContent(e, t) {
				let n = new jt("model.gltf"),
					i = new jt("model.bin");
				t.push(n), t.push(i);
				let s = this.GetMeshData(e),
					o = this.GetMainBuffer(s),
					a = this.GetMainJson(e, s);
				a.buffers.push({
					uri: i.GetName(),
					byteLength: o.byteLength
				});
				let l = new Map;
				this.ExportMaterials(e, a, c => {
					let u = vn(c.name);
					if (l.has(u)) return l.get(u);
					{
						let h = new jt(u);
						h.SetBufferContent(c.buffer), t.push(h);
						let f = a.textures.length;
						return l.set(u, f), a.images.push({
							uri: u
						}), a.textures.push({
							source: f
						}), f
					}
				}), n.SetTextContent(JSON.stringify(a, null, 4)), i.SetBufferContent(o)
			}
			ExportBinaryContent(e, t) {
				function n(x) {
					let M = x % 4;
					return M === 0 ? x : x + (4 - M)
				}

				function i(x, M, I) {
					for (let w = 0; w < I; w++) x.WriteUnsignedCharacter8(M)
				}
				let s = new jt("model.glb");
				t.push(s);
				let o = this.GetMeshData(e),
					a = this.GetMainBuffer(o),
					l = this.GetMainJson(e, o),
					c = [],
					u = a.byteLength,
					h = new Map;
				this.ExportMaterials(e, l, x => {
					let M = vn(x.name),
						I = er(x.name);
					if (h.has(M)) return h.get(M);
					{
						let w = l.bufferViews.length,
							L = l.textures.length;
						h.set(M, L);
						let T = x.buffer;
						return c.push(T), l.bufferViews.push({
							buffer: 0,
							byteOffset: u,
							byteLength: T.byteLength
						}), u += T.byteLength, l.images.push({
							bufferView: w,
							mimeType: "image/" + I
						}), l.textures.push({
							source: L
						}), L
					}
				});
				let f = a.byteLength;
				for (let x = 0; x < c.length; x++) {
					let M = c[x];
					f += M.byteLength
				}
				let m = n(f);
				l.buffers.push({
					byteLength: m
				});
				let g = JSON.stringify(l),
					y = mo(g),
					d = y.byteLength,
					p = n(d),
					_ = 12 + 8 + p + 8 + m,
					v = new Ni(_, !0);
				v.WriteUnsignedInteger32(1179937895), v.WriteUnsignedInteger32(2), v.WriteUnsignedInteger32(_), v.WriteUnsignedInteger32(p), v.WriteUnsignedInteger32(1313821514), v.WriteArrayBuffer(y), i(v, 32, p - d), v.WriteUnsignedInteger32(m), v.WriteUnsignedInteger32(5130562), v.WriteArrayBuffer(a);
				for (let x = 0; x < c.length; x++) {
					let M = c[x];
					v.WriteArrayBuffer(M)
				}
				i(v, 0, m - f), s.SetBufferContent(v.GetBuffer())
			}
			GetMeshData(e) {
				let t = [];
				return e.EnumerateMeshes(n => {
					let i = po(n);
					t.push({
						name: n.GetName(),
						buffer: i,
						offsets: [],
						sizes: []
					})
				}), t
			}
			GetMainBuffer(e) {
				let t = 0;
				for (let i of e) t += i.buffer.GetByteLength(this.components.index.size, this.components.number.size);
				let n = new Ni(t, !0);
				for (let i of e)
					for (let s = 0; s < i.buffer.PrimitiveCount(); s++) {
						let o = i.buffer.GetPrimitive(s),
							a = n.GetPosition();
						for (let l = 0; l < o.indices.length; l++) n.WriteUnsignedInteger32(o.indices[l]);
						for (let l = 0; l < o.vertices.length; l++) n.WriteFloat32(o.vertices[l]);
						for (let l = 0; l < o.colors.length; l++) n.WriteFloat32(nr(o.colors[l]));
						for (let l = 0; l < o.normals.length; l++) n.WriteFloat32(o.normals[l]);
						for (let l = 0; l < o.uvs.length; l++) {
							let c = o.uvs[l];
							l % 2 === 1 && (c *= -1), n.WriteFloat32(c)
						}
						i.offsets.push(a), i.sizes.push(n.GetPosition() - a)
					}
				return n.GetBuffer()
			}
			GetMainJson(e, t) {
				class n {
					constructor(h, f) {
						this.mainJson = h, this.byteOffset = f
					}
					AddBufferView(h, f) {
						let m = {
							buffer: 0,
							byteOffset: this.byteOffset,
							byteLength: h,
							target: f
						};
						return this.mainJson.bufferViews.push(m), this.byteOffset += h, this.mainJson.bufferViews.length - 1
					}
				}

				function i(u, h) {
					for (let f of h.GetMeshIndices()) {
						let m = new yi(h.GetId(), f);
						if (u.IsMeshInstanceVisible(m)) return !0
					}
					for (let f of h.GetChildNodes())
						if (i(u, f)) return !0;
					return !1
				}

				function s(u, h, f, m) {
					if (m.IsMeshNode())
						for (let g of m.GetMeshIndices()) o(u, h, f, m, g, !0);
					else if (i(u, m)) {
						let g = {},
							y = m.GetName();
						y.length > 0 && (g.name = y), m.GetTransformation().IsIdentity() || (g.matrix = m.GetTransformation().GetMatrix().Get()), f.push(g), h.push(f.length - 1), g.children = [], a(u, g.children, f, m)
					}
				}

				function o(u, h, f, m, g, y) {
					let d = new yi(m.GetId(), g);
					if (!u.IsMeshInstanceVisible(d)) return;
					let p = {
						mesh: u.MapMeshIndex(g)
					};
					y && (m.GetTransformation().IsIdentity() || (p.matrix = m.GetTransformation().GetMatrix().Get())), f.push(p), h.push(f.length - 1)
				}

				function a(u, h, f, m) {
					for (let g of m.GetChildNodes()) s(u, h, f, g);
					for (let g of m.GetMeshIndices()) o(u, h, f, m, g, !1)
				}
				let l = {
						asset: {
							generator: "https://3dviewer.net",
							version: "2.0"
						},
						scene: 0,
						scenes: [{
							nodes: []
						}],
						nodes: [],
						materials: [],
						meshes: [],
						buffers: [],
						bufferViews: [],
						accessors: []
					},
					c = e.GetModel().GetRootNode();
				a(e, l.scenes[0].nodes, l.nodes, c);
				for (let u of t) {
					let h = {
							name: this.GetExportedMeshName(u.name),
							primitives: []
						},
						f = u.buffer.primitives;
					for (let m = 0; m < f.length; m++) {
						let g = f[m],
							y = new n(l, u.offsets[m]),
							d = y.AddBufferView(g.indices.length * this.components.index.size, ol.ELEMENT_ARRAY_BUFFER),
							p = y.AddBufferView(g.vertices.length * this.components.number.size, ol.ARRAY_BUFFER),
							_ = null;
						g.colors.length > 0 && (_ = y.AddBufferView(g.colors.length * this.components.number.size, ol.ARRAY_BUFFER));
						let v = y.AddBufferView(g.normals.length * this.components.number.size, ol.ARRAY_BUFFER),
							x = null;
						g.uvs.length > 0 && (x = y.AddBufferView(g.uvs.length * this.components.number.size, ol.ARRAY_BUFFER));
						let M = {
								attributes: {},
								mode: 4,
								material: g.material
							},
							I = g.GetBounds();
						l.accessors.push({
							bufferView: d,
							byteOffset: 0,
							componentType: this.components.index.type,
							count: g.indices.length,
							type: "SCALAR"
						}), M.indices = l.accessors.length - 1, l.accessors.push({
							bufferView: p,
							byteOffset: 0,
							componentType: this.components.number.type,
							count: g.vertices.length / 3,
							min: I.min,
							max: I.max,
							type: "VEC3"
						}), M.attributes.POSITION = l.accessors.length - 1, _ !== null && (l.accessors.push({
							bufferView: _,
							byteOffset: 0,
							componentType: this.components.number.type,
							count: g.colors.length / 3,
							type: "VEC3"
						}), M.attributes.COLOR_0 = l.accessors.length - 1), l.accessors.push({
							bufferView: v,
							byteOffset: 0,
							componentType: this.components.number.type,
							count: g.normals.length / 3,
							type: "VEC3"
						}), M.attributes.NORMAL = l.accessors.length - 1, x !== null && (l.accessors.push({
							bufferView: x,
							byteOffset: 0,
							componentType: this.components.number.type,
							count: g.uvs.length / 2,
							type: "VEC2"
						}), M.attributes.TEXCOORD_0 = l.accessors.length - 1), h.primitives.push(M)
					}
					l.meshes.push(h)
				}
				return l
			}
			ExportMaterials(e, t, n) {
				function i(s, o, a, l) {
					function c(d, p) {
						return [nr(d.r / 255), nr(d.g / 255), nr(d.b / 255), p]
					}

					function u(d) {
						return [nr(d.r / 255), nr(d.g / 255), nr(d.b / 255)]
					}

					function h(d, p, _) {
						if (p === null || !p.IsValid()) return null;
						d.images === void 0 && (d.images = []), d.textures === void 0 && (d.textures = []);
						let x = {
							index: _(p)
						};
						if (p.HasTransformation()) {
							let M = "KHR_texture_transform";
							d.extensionsUsed === void 0 && (d.extensionsUsed = []), d.extensionsUsed.indexOf(M) === -1 && d.extensionsUsed.push(M), x.extensions = {
								KHR_texture_transform: {
									offset: [p.offset.x, -p.offset.y],
									scale: [p.scale.x, p.scale.y],
									rotation: -p.rotation
								}
							}
						}
						return x
					}
					let f = {
						name: s.GetExportedMaterialName(a.name),
						pbrMetallicRoughness: {
							baseColorFactor: c(a.color, a.opacity)
						},
						emissiveFactor: u(a.emissive),
						doubleSided: !0,
						alphaMode: "OPAQUE"
					};
					a.transparent && (f.alphaMode = "BLEND");
					let m = h(o, a.diffuseMap, l);
					if (m !== null && (a.multiplyDiffuseMap || (f.pbrMetallicRoughness.baseColorFactor = c(new Et(255, 255, 255), a.opacity)), f.pbrMetallicRoughness.baseColorTexture = m), a.type === In.Physical) {
						let d = h(o, a.metalnessMap, l);
						d !== null ? f.pbrMetallicRoughness.metallicRoughnessTexture = d : (f.pbrMetallicRoughness.metallicFactor = a.metalness, f.pbrMetallicRoughness.roughnessFactor = a.roughness)
					}
					let g = h(o, a.normalMap, l);
					g !== null && (f.normalTexture = g);
					let y = h(o, a.emissiveMap, l);
					y !== null && (f.emissiveTexture = y), o.materials.push(f)
				}
				for (let s = 0; s < e.MaterialCount(); s++) {
					let o = e.GetMaterial(s);
					i(this, t, o, n)
				}
			}
		};
	var al = class {
			constructor(e) {
				this.transformation = new rn, this.isMeshVisible = t => !0, oo(e, this)
			}
		},
		_o = class {
			constructor(e, t) {
				this.model = e, this.settings = t || new al, this.visibleMeshes = null, this.meshToVisibleMeshIndex = null
			}
			GetModel() {
				return this.model
			}
			MaterialCount() {
				return this.model.MaterialCount()
			}
			GetMaterial(e) {
				return this.model.GetMaterial(e)
			}
			VertexCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += t.VertexCount()
				}), e
			}
			TriangleCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += t.TriangleCount()
				}), e
			}
			MeshCount() {
				let e = 0;
				return this.EnumerateMeshes(t => {
					e += 1
				}), e
			}
			EnumerateMeshes(e) {
				this.FillVisibleMeshCache();
				for (let t = 0; t < this.model.MeshCount(); t++)
					if (this.visibleMeshes.has(t)) {
						let n = this.model.GetMesh(t);
						e(n)
					}
			}
			MapMeshIndex(e) {
				return this.FillVisibleMeshCache(), this.meshToVisibleMeshIndex.get(e)
			}
			IsMeshInstanceVisible(e) {
				return this.settings.isMeshVisible(e)
			}
			MeshInstanceCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += 1
				}), e
			}
			EnumerateMeshInstances(e) {
				this.model.EnumerateMeshInstances(t => {
					this.settings.isMeshVisible(t.GetId()) && e(t)
				})
			}
			EnumerateTransformedMeshInstances(e) {
				this.EnumerateMeshInstances(t => {
					let n = t.GetTransformation();
					this.settings.transformation.IsIdentity() || n.Append(this.settings.transformation);
					let s = t.GetMesh().Clone();
					n.IsIdentity() || rr(s, n), e(s)
				})
			}
			EnumerateVerticesAndTriangles(e) {
				let t = [];
				this.EnumerateTransformedMeshInstances(i => {
					t.push(i)
				});
				for (let i of t) i.EnumerateVertices(s => {
					e.onVertex(s.x, s.y, s.z)
				});
				let n = 0;
				for (let i of t) i.EnumerateTriangleVertexIndices((s, o, a) => {
					e.onTriangle(s + n, o + n, a + n)
				}), n += i.VertexCount()
			}
			EnumerateTrianglesWithNormals(e) {
				this.EnumerateTransformedMeshInstances(t => {
					t.EnumerateTriangleVertices((n, i, s) => {
						let o = Cs(n, i, s);
						e(n, i, s, o)
					})
				})
			}
			FillVisibleMeshCache() {
				if (this.visibleMeshes !== null && this.meshToVisibleMeshIndex !== null) return;
				this.visibleMeshes = new Set, this.model.EnumerateMeshInstances(t => {
					let n = t.GetId();
					this.settings.isMeshVisible(n) && this.visibleMeshes.add(n.meshIndex)
				}), this.meshToVisibleMeshIndex = new Map;
				let e = 0;
				for (let t = 0; t < this.model.MeshCount(); t++) this.visibleMeshes.has(t) && (this.meshToVisibleMeshIndex.set(t, e), e += 1)
			}
		};
	var $n = class {
		constructor() {
			this.text = "", this.indentation = 0
		}
		GetText() {
			return this.text
		}
		Indent(e) {
			this.indentation += e
		}
		WriteArrayLine(e) {
			this.WriteLine(e.join(" "))
		}
		WriteLine(e) {
			this.WriteIndentation(), this.Write(e + `
`)
		}
		WriteIndentation() {
			for (let e = 0; e < this.indentation; e++) this.Write("  ")
		}
		Write(e) {
			this.text += e
		}
	};
	var To = class extends bn {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === nn.Text && t === "obj"
		}
		ExportContent(e, t, n, i) {
			function s(g, y, d, p) {
				if (d === null || !d.IsValid()) return;
				let _ = vn(d.name);
				if (g.WriteArrayLine([y, _]), p.findIndex(x => x.GetName() === _) === -1) {
					let x = new jt(_);
					x.SetBufferContent(d.buffer), p.push(x)
				}
			}
			let o = new jt("model.mtl"),
				a = new jt("model.obj");
			n.push(o), n.push(a);
			let l = new $n;
			l.WriteLine(this.GetHeaderText());
			for (let g = 0; g < e.MaterialCount(); g++) {
				let y = e.GetMaterial(g);
				l.WriteArrayLine(["newmtl", this.GetExportedMaterialName(y.name)]), l.WriteArrayLine(["Kd", y.color.r / 255, y.color.g / 255, y.color.b / 255]), l.WriteArrayLine(["d", y.opacity]), y.type === In.Phong && (l.WriteArrayLine(["Ka", y.ambient.r / 255, y.ambient.g / 255, y.ambient.b / 255]), l.WriteArrayLine(["Ks", y.specular.r / 255, y.specular.g / 255, y.specular.b / 255]), l.WriteArrayLine(["Ns", y.shininess * 1e3])), s(l, "map_Kd", y.diffuseMap, n), y.type === In.Phong && s(l, "map_Ks", y.specularMap, n), s(l, "bump", y.bumpMap, n)
			}
			o.SetTextContent(l.GetText());
			let c = new $n;
			c.WriteLine(this.GetHeaderText()), c.WriteArrayLine(["mtllib", o.GetName()]);
			let u = 0,
				h = 0,
				f = 0,
				m = null;
			e.EnumerateTransformedMeshInstances(g => {
				c.WriteArrayLine(["g", this.GetExportedMeshName(g.GetName())]);
				for (let y = 0; y < g.VertexCount(); y++) {
					let d = g.GetVertex(y);
					c.WriteArrayLine(["v", d.x, d.y, d.z])
				}
				for (let y = 0; y < g.NormalCount(); y++) {
					let d = g.GetNormal(y);
					c.WriteArrayLine(["vn", d.x, d.y, d.z])
				}
				for (let y = 0; y < g.TextureUVCount(); y++) {
					let d = g.GetTextureUV(y);
					c.WriteArrayLine(["vt", d.x, d.y])
				}
				for (let y = 0; y < g.TriangleCount(); y++) {
					let d = g.GetTriangle(y),
						p = d.v0 + u + 1,
						_ = d.v1 + u + 1,
						v = d.v2 + u + 1,
						x = d.n0 + h + 1,
						M = d.n1 + h + 1,
						I = d.n2 + h + 1;
					if (d.mat !== null) {
						let C = e.GetMaterial(d.mat),
							V = this.GetExportedMaterialName(C.name);
						V !== m && (c.WriteArrayLine(["usemtl", V]), m = V)
					}
					let w = "",
						L = "",
						T = "";
					d.HasTextureUVs() && (w = d.u0 + f + 1, L = d.u1 + f + 1, T = d.u2 + f + 1), c.WriteArrayLine(["f", [p, w, x].join("/"), [_, L, M].join("/"), [v, T, I].join("/")])
				}
				u += g.VertexCount(), h += g.NormalCount(), f += g.TextureUVCount()
			}), a.SetTextContent(c.GetText()), i()
		}
		GetHeaderText() {
			return "# exported by https://3dviewer.net"
		}
	};
	var Eo = class extends bn {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === nn.Text && t === "off"
		}
		ExportContent(e, t, n, i) {
			let s = new jt("model.off");
			n.push(s);
			let o = new $n;
			o.WriteLine("OFF"), o.WriteArrayLine([e.VertexCount(), e.TriangleCount(), 0]), e.EnumerateVerticesAndTriangles({
				onVertex: function(a, l, c) {
					o.WriteArrayLine([a, l, c])
				},
				onTriangle: function(a, l, c) {
					o.WriteArrayLine([3, a, l, c])
				}
			}), s.SetTextContent(o.GetText()), i()
		}
	};
	var Mo = class extends bn {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return (e === nn.Text || e === nn.Binary) && t === "ply"
		}
		ExportContent(e, t, n, i) {
			t === nn.Text ? this.ExportText(e, n) : this.ExportBinary(e, n), i()
		}
		ExportText(e, t) {
			let n = new jt("model.ply");
			t.push(n);
			let i = new $n,
				s = e.VertexCount(),
				o = e.TriangleCount(),
				a = this.GetHeaderText("ascii", s, o);
			i.Write(a), e.EnumerateVerticesAndTriangles({
				onVertex: function(l, c, u) {
					i.WriteArrayLine([l, c, u])
				},
				onTriangle: function(l, c, u) {
					i.WriteArrayLine([3, l, c, u])
				}
			}), n.SetTextContent(i.GetText())
		}
		ExportBinary(e, t) {
			let n = new jt("model.ply");
			t.push(n);
			let i = e.VertexCount(),
				s = e.TriangleCount(),
				o = this.GetHeaderText("binary_little_endian", i, s),
				a = o.length + i * 3 * 4 + s * (1 + 3 * 4),
				l = new Ni(a, !0);
			for (let c = 0; c < o.length; c++) l.WriteUnsignedCharacter8(o.charCodeAt(c));
			e.EnumerateVerticesAndTriangles({
				onVertex: function(c, u, h) {
					l.WriteFloat32(c), l.WriteFloat32(u), l.WriteFloat32(h)
				},
				onTriangle: function(c, u, h) {
					l.WriteUnsignedCharacter8(3), l.WriteInteger32(c), l.WriteInteger32(u), l.WriteInteger32(h)
				}
			}), n.SetBufferContent(l.GetBuffer())
		}
		GetHeaderText(e, t, n) {
			let i = new $n;
			return i.WriteLine("ply"), i.WriteLine("format " + e + " 1.0"), i.WriteLine("element vertex " + t), i.WriteLine("property float x"), i.WriteLine("property float y"), i.WriteLine("property float z"), i.WriteLine("element face " + n), i.WriteLine("property list uchar int vertex_index"), i.WriteLine("end_header"), i.GetText()
		}
	};
	var bo = class extends bn {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return (e === nn.Text || e === nn.Binary) && t === "stl"
		}
		ExportContent(e, t, n, i) {
			t === nn.Text ? this.ExportText(e, n) : this.ExportBinary(e, n), i()
		}
		ExportText(e, t) {
			let n = new jt("model.stl");
			t.push(n);
			let i = new $n;
			i.WriteLine("solid Model"), e.EnumerateTrianglesWithNormals((s, o, a, l) => {
				i.WriteArrayLine(["facet", "normal", l.x, l.y, l.z]), i.Indent(1), i.WriteLine("outer loop"), i.Indent(1), i.WriteArrayLine(["vertex", s.x, s.y, s.z]), i.WriteArrayLine(["vertex", o.x, o.y, o.z]), i.WriteArrayLine(["vertex", a.x, a.y, a.z]), i.Indent(-1), i.WriteLine("endloop"), i.Indent(-1), i.WriteLine("endfacet")
			}), i.WriteLine("endsolid Model"), n.SetTextContent(i.GetText())
		}
		ExportBinary(e, t) {
			let n = new jt("model.stl");
			t.push(n);
			let i = e.TriangleCount(),
				s = 80,
				o = s + 4 + i * 50,
				a = new Ni(o, !0);
			for (let l = 0; l < s; l++) a.WriteUnsignedCharacter8(0);
			a.WriteUnsignedInteger32(i), e.EnumerateTrianglesWithNormals((l, c, u, h) => {
				a.WriteFloat32(h.x), a.WriteFloat32(h.y), a.WriteFloat32(h.z), a.WriteFloat32(l.x), a.WriteFloat32(l.y), a.WriteFloat32(l.z), a.WriteFloat32(c.x), a.WriteFloat32(c.y), a.WriteFloat32(c.z), a.WriteFloat32(u.x), a.WriteFloat32(u.y), a.WriteFloat32(u.z), a.WriteUnsignedInteger16(0)
			}), n.SetBufferContent(a.GetBuffer())
		}
	};
	var Dc = class {
		constructor() {
			this.exporters = [new To, new bo, new Mo, new Eo, new xo, new go, new yo]
		}
		AddExporter(e) {
			this.exporters.push(e)
		}
		Export(e, t, n, i, s) {
			let o = null;
			for (let l = 0; l < this.exporters.length; l++) {
				let c = this.exporters[l];
				if (c.CanExport(n, i)) {
					o = c;
					break
				}
			}
			if (o === null) {
				s.onError();
				return
			}
			let a = new _o(e, t);
			o.Export(a, n, l => {
				l.length === 0 ? s.onError() : s.onSuccess(l)
			})
		}
	};
	var Rs = class {
			constructor(e, t) {
				this.min = e, this.max = t
			}
			GetMin() {
				return this.min
			}
			GetMax() {
				return this.max
			}
			GetCenter() {
				return new He((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, (this.min.z + this.max.z) / 2)
			}
		},
		So = class {
			constructor() {
				this.box = new Rs(new He(1 / 0, 1 / 0, 1 / 0), new He(-1 / 0, -1 / 0, -1 / 0)), this.isValid = !1
			}
			GetBox() {
				return this.isValid ? this.box : null
			}
			AddPoint(e) {
				this.box.min.x = Math.min(this.box.min.x, e.x), this.box.min.y = Math.min(this.box.min.y, e.y), this.box.min.z = Math.min(this.box.min.z, e.z), this.box.max.x = Math.max(this.box.max.x, e.x), this.box.max.y = Math.max(this.box.max.y, e.y), this.box.max.z = Math.max(this.box.max.z, e.z), this.isValid = !0
			}
		};
	var ll = class r {
			constructor(e, t) {
				this.boundingBox = e, this.level = t, this.pointItems = [], this.childNodes = []
			}
			AddPoint(e, t, n) {
				let i = this.FindNodeForPoint(e);
				if (i === null || i.FindPointDirectly(e) !== null) return !1;
				if (i.pointItems.length < n.maxPointsPerNode || i.level >= n.maxTreeDepth) return i.AddPointDirectly(e, t), !0;
				{
					i.CreateChildNodes();
					let s = i.pointItems;
					i.pointItems = [];
					for (let o = 0; o < s.length; o++) {
						let a = s[o];
						if (!i.AddPoint(a.point, a.data, n)) return !1
					}
					return i.AddPoint(e, t, n)
				}
			}
			FindPoint(e) {
				let t = this.FindNodeForPoint(e);
				return t === null ? null : t.FindPointDirectly(e)
			}
			AddPointDirectly(e, t) {
				this.pointItems.push({
					point: e,
					data: t
				})
			}
			FindPointDirectly(e) {
				for (let t = 0; t < this.pointItems.length; t++) {
					let n = this.pointItems[t];
					if (li(e, n.point)) return n.data
				}
				return null
			}
			FindNodeForPoint(e) {
				if (!this.IsPointInBounds(e)) return null;
				if (this.childNodes.length === 0) return this;
				for (let t = 0; t < this.childNodes.length; t++) {
					let i = this.childNodes[t].FindNodeForPoint(e);
					if (i !== null) return i
				}
				return null
			}
			CreateChildNodes() {
				function e(a, l, c, u, h, f, m) {
					let g = new Rs(new He(l, c, u), new He(l + h, c + f, u + m));
					a.childNodes.push(new r(g, a.level + 1))
				}
				let t = this.boundingBox.min,
					n = this.boundingBox.GetCenter(),
					i = (this.boundingBox.max.x - this.boundingBox.min.x) / 2,
					s = (this.boundingBox.max.y - this.boundingBox.min.y) / 2,
					o = (this.boundingBox.max.z - this.boundingBox.min.z) / 2;
				e(this, t.x, t.y, t.z, i, s, o), e(this, n.x, t.y, t.z, i, s, o), e(this, t.x, n.y, t.z, i, s, o), e(this, n.x, n.y, t.z, i, s, o), e(this, t.x, t.y, n.z, i, s, o), e(this, n.x, t.y, n.z, i, s, o), e(this, t.x, n.y, n.z, i, s, o), e(this, n.x, n.y, n.z, i, s, o)
			}
			IsPointInBounds(e) {
				return uo(e.x, this.boundingBox.min.x) && uo(e.y, this.boundingBox.min.y) && uo(e.z, this.boundingBox.min.z) && co(e.x, this.boundingBox.max.x) && co(e.y, this.boundingBox.max.y) && co(e.z, this.boundingBox.max.z)
			}
		},
		Ao = class {
			constructor(e, t) {
				this.options = {
					maxPointsPerNode: 10,
					maxTreeDepth: 10
				}, t !== void 0 && (t.maxPointsPerNode !== void 0 && (this.options.maxPointsPerNode = t.maxPointsPerNode), t.maxTreeDepth !== void 0 && (this.options.maxTreeDepth = t.maxTreeDepth)), this.rootNode = new ll(e, 0)
			}
			AddPoint(e, t) {
				return this.rootNode.AddPoint(e, t, this.options)
			}
			FindPoint(e) {
				return this.rootNode.FindPoint(e)
			}
		};

	function Sp(r, e, t) {
		let n = e / t;
		return r * (n * n * (3 - 2 * n))
	}

	function Ap(r, e, t) {
		return e * r / t
	}

	function Fc(r, e, t) {
		let n = e / t,
			i = n * n;
		return r * (i / (2 * (i - n) + 1))
	}

	function wo(r, e, t, n) {
		let i = Mn(e, r).Normalize(),
			s = Wn(r, e),
			o = [];
		for (let a = 0; a < t; a++) {
			let l = n(s, a, t - 1);
			o.push(r.Clone().Offset(i, l))
		}
		return o
	}
	var Co = class {
		constructor(e, t, n) {
			this.name = e, this.source = t, this.data = n
		}
	};

	function Uc(r) {
		let e = [];
		for (let t of r) {
			let n = vn(t);
			e.push(new Co(n, Ii.Url, t))
		}
		return e
	}

	function kc(r) {
		let e = [];
		for (let t of r) {
			let n = vn(t.name);
			e.push(new Co(n, Ii.File, t))
		}
		return e
	}
	var Is = class {
			constructor(e, t, n) {
				this.name = vn(e), this.extension = er(e), this.source = t, this.data = n, this.content = null
			}
			SetContent(e) {
				this.content = e
			}
		},
		Ps = class {
			constructor() {
				this.files = []
			}
			FillFromInputFiles(e) {
				this.files = [];
				for (let t of e) {
					let n = new Is(t.name, t.source, t.data);
					this.files.push(n)
				}
			}
			ExtendFromFileList(e) {
				let t = e.GetFiles();
				for (let n = 0; n < t.length; n++) {
					let i = t[n];
					this.ContainsFileByPath(i.name) || this.files.push(i)
				}
			}
			GetFiles() {
				return this.files
			}
			GetContent(e) {
				vc(this.files.length, {
					runTask: (t, n) => {
						e.onFileListProgress(t, this.files.length), this.GetFileContent(this.files[t], {
							onReady: n,
							onProgress: e.onFileLoadProgress
						})
					},
					onReady: e.onReady
				})
			}
			ContainsFileByPath(e) {
				return this.FindFileByPath(e) !== null
			}
			FindFileByPath(e) {
				let t = vn(e).toLowerCase();
				for (let n = 0; n < this.files.length; n++) {
					let i = this.files[n];
					if (i.name.toLowerCase() === t) return i
				}
				return null
			}
			IsOnlyUrlSource() {
				if (this.files.length === 0) return !1;
				for (let e = 0; e < this.files.length; e++) {
					let t = this.files[e];
					if (t.source !== Ii.Url && t.source !== Ii.Decompressed) return !1
				}
				return !0
			}
			AddFile(e) {
				this.files.push(e)
			}
			GetFileContent(e, t) {
				if (e.content !== null) {
					t.onReady();
					return
				}
				let n = null;
				if (e.source === Ii.Url) n = Ec(e.data, t.onProgress);
				else if (e.source === Ii.File) n = Mc(e.data, t.onProgress);
				else {
					t.onReady();
					return
				}
				n.then(i => {
					e.SetContent(i)
				}).catch(() => {}).finally(() => {
					t.onReady()
				})
			}
		};
	var bh = class {
			constructor() {
				this.nextId = 0
			}
			GenerateId() {
				let e = this.nextId;
				return this.nextId += 1, e
			}
		},
		Sn = class {
			constructor() {
				this.name = "", this.parent = null, this.transformation = new rn, this.childNodes = [], this.meshIndices = [], this.idGenerator = new bh, this.id = this.idGenerator.GenerateId()
			}
			IsEmpty() {
				return this.childNodes.length === 0 && this.meshIndices.length === 0
			}
			IsMeshNode() {
				return this.childNodes.length === 0 && this.meshIndices.length === 1
			}
			GetId() {
				return this.id
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			HasParent() {
				return this.parent !== null
			}
			GetParent() {
				return this.parent
			}
			GetTransformation() {
				return this.transformation
			}
			GetWorldTransformation() {
				let e = this.transformation.Clone(),
					t = this.parent;
				for (; t !== null;) e.Append(t.transformation), t = t.parent;
				return e
			}
			SetTransformation(e) {
				this.transformation = e
			}
			AddChildNode(e) {
				return e.parent = this, e.idGenerator = this.idGenerator, e.id = e.idGenerator.GenerateId(), this.childNodes.push(e), this.childNodes.length - 1
			}
			RemoveChildNode(e) {
				e.parent = null;
				let t = this.childNodes.indexOf(e);
				this.childNodes.splice(t, 1)
			}
			GetChildNodes() {
				return this.childNodes
			}
			ChildNodeCount() {
				return this.childNodes.length
			}
			GetChildNode(e) {
				return this.childNodes[e]
			}
			AddMeshIndex(e) {
				return this.meshIndices.push(e), this.meshIndices.length - 1
			}
			MeshIndexCount() {
				return this.meshIndices.length
			}
			GetMeshIndex(e) {
				return this.meshIndices[e]
			}
			GetMeshIndices() {
				return this.meshIndices
			}
			Enumerate(e) {
				e(this);
				for (let t of this.childNodes) t.Enumerate(e)
			}
			EnumerateChildren(e) {
				for (let t of this.childNodes) e(t), t.EnumerateChildren(e)
			}
			EnumerateMeshIndices(e) {
				for (let t of this.meshIndices) e(t);
				for (let t of this.childNodes) t.EnumerateMeshIndices(e)
			}
		};
	var Zr = {
		Unknown: 0,
		Millimeter: 1,
		Centimeter: 2,
		Meter: 3,
		Inch: 4,
		Foot: 5
	};
	var or = class extends sr {
		constructor() {
			super(), this.unit = Zr.Unknown, this.root = new Sn, this.materials = [], this.meshes = []
		}
		GetUnit() {
			return this.unit
		}
		SetUnit(e) {
			this.unit = e
		}
		GetRootNode() {
			return this.root
		}
		NodeCount() {
			let e = 0;
			return this.root.Enumerate(t => {
				e += 1
			}), e - 1
		}
		MaterialCount() {
			return this.materials.length
		}
		MeshCount() {
			return this.meshes.length
		}
		MeshInstanceCount() {
			let e = 0;
			return this.root.Enumerate(t => {
				e += t.MeshIndexCount()
			}), e
		}
		VertexCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.VertexCount()
			}), e
		}
		VertexColorCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.VertexColorCount()
			}), e
		}
		NormalCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.NormalCount()
			}), e
		}
		TextureUVCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.TextureUVCount()
			}), e
		}
		TriangleCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.TriangleCount()
			}), e
		}
		AddMaterial(e) {
			return this.materials.push(e), this.materials.length - 1
		}
		GetMaterial(e) {
			return this.materials[e]
		}
		AddMesh(e) {
			return this.meshes.push(e), this.meshes.length - 1
		}
		AddMeshToRootNode(e) {
			let t = this.AddMesh(e);
			return this.root.AddMeshIndex(t), t
		}
		RemoveMesh(e) {
			this.meshes.splice(e, 1), this.root.Enumerate(t => {
				for (let n = 0; n < t.meshIndices.length; n++) t.meshIndices[n] === e ? (t.meshIndices.splice(n, 1), n -= 1) : t.meshIndices[n] > e && (t.meshIndices[n] -= 1)
			})
		}
		GetMesh(e) {
			return this.meshes[e]
		}
		GetMeshInstance(e) {
			let t = null;
			if (this.root.Enumerate(o => {
					o.GetId() === e.nodeId && (t = o)
				}), t === null || t.GetMeshIndices().indexOf(e.meshIndex) === -1) return null;
			let i = this.GetMesh(e.meshIndex),
				s = new yi(t.GetId(), e.meshIndex);
			return new br(s, t, i)
		}
		EnumerateMeshes(e) {
			for (let t of this.meshes) e(t)
		}
		EnumerateMeshInstances(e) {
			this.root.Enumerate(t => {
				for (let n of t.GetMeshIndices()) {
					let i = new yi(t.GetId(), n),
						s = this.GetMesh(n),
						o = new br(i, t, s);
					e(o)
				}
			})
		}
		EnumerateTransformedMeshInstances(e) {
			this.EnumerateMeshInstances(t => {
				let n = t.GetTransformedMesh();
				e(n)
			})
		}
		EnumerateVertices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateVertices(e)
			})
		}
		EnumerateTriangleVertexIndices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateTriangleVertexIndices(e)
			})
		}
		EnumerateTriangleVertices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateTriangleVertices(e)
			})
		}
	};
	var cl = class {
			constructor() {
				this.edges = [], this.triangles = []
			}
		},
		ul = class {
			constructor(e, t) {
				this.vertex1 = e, this.vertex2 = t, this.triangles = []
			}
		},
		hl = class {
			constructor(e, t) {
				this.edge = e, this.reversed = t
			}
		},
		fl = class {
			constructor() {
				this.triEdge1 = null, this.triEdge2 = null, this.triEdge3 = null
			}
		},
		Ro = class {
			constructor() {
				this.vertices = [], this.edges = [], this.triangleEdges = [], this.triangles = [], this.edgeStartToEndVertexMap = new Map
			}
			AddVertex() {
				return this.vertices.push(new cl), this.vertices.length - 1
			}
			AddTriangle(e, t, n) {
				function i(c, u, h) {
					c[u].triangles.push(h)
				}

				function s(c, u, h, f) {
					let m = c[h],
						g = u[f];
					m.edges.push(g.edge)
				}

				function o(c, u, h, f) {
					let m = u[h];
					c[m.edge].triangles.push(f)
				}
				let a = this.triangles.length,
					l = new fl;
				l.triEdge1 = this.AddTriangleEdge(e, t), l.triEdge2 = this.AddTriangleEdge(t, n), l.triEdge3 = this.AddTriangleEdge(n, e), i(this.vertices, e, a), i(this.vertices, t, a), i(this.vertices, n, a), s(this.vertices, this.triangleEdges, e, l.triEdge1), s(this.vertices, this.triangleEdges, t, l.triEdge2), s(this.vertices, this.triangleEdges, n, l.triEdge3), o(this.edges, this.triangleEdges, l.triEdge1, a), o(this.edges, this.triangleEdges, l.triEdge2, a), o(this.edges, this.triangleEdges, l.triEdge3, a), this.triangles.push(l)
			}
			AddTriangleEdge(e, t) {
				let n = e,
					i = t,
					s = !1;
				t < e && (n = t, i = e, s = !0);
				let o = this.AddEdge(n, i);
				return this.triangleEdges.push(new hl(o, s)), this.triangleEdges.length - 1
			}
			AddEdge(e, t) {
				this.edgeStartToEndVertexMap.has(e) || this.edgeStartToEndVertexMap.set(e, []);
				let n = this.edgeStartToEndVertexMap.get(e);
				for (let s = 0; s < n.length; s++) {
					let o = n[s];
					if (o.endVertex === t) return o.edgeIndex
				}
				let i = this.edges.length;
				return n.push({
					endVertex: t,
					edgeIndex: i
				}), this.edges.push(new ul(e, t)), i
			}
		};

	function Io(r) {
		let e = !0;
		return r.EnumerateMeshInstances(t => {
			Kr(t) !== ir.Empty && (e = !1)
		}), e
	}

	function Sh(r) {
		let e = new So;
		return r.EnumerateVertices(t => {
			e.AddPoint(t)
		}), e.GetBox()
	}

	function Ah(r) {
		function e(s, o, a) {
			let l = o.FindPoint(s);
			return l === null && (l = a.AddVertex(), o.AddPoint(s, l)), l
		}
		let t = Sh(r),
			n = new Ao(t),
			i = new Ro;
		return r.EnumerateTriangleVertices((s, o, a) => {
			let l = e(s, n, i),
				c = e(o, n, i),
				u = e(a, n, i);
			i.AddTriangle(l, c, u)
		}), i
	}

	function wh(r) {
		function e(t, n, i) {
			let s = t.triangles[n],
				o = t.triangleEdges[s.triEdge1],
				a = t.triangleEdges[s.triEdge2],
				l = t.triangleEdges[s.triEdge3];
			return o.edge === i ? o.reversed : a.edge === i ? a.reversed : l.edge === i ? l.reversed : null
		}
		if (r instanceof or) {
			let t = !0;
			return r.EnumerateMeshInstances(n => {
				t && (t = wh(n))
			}), t
		} else {
			let t = Ah(r);
			for (let n = 0; n < t.edges.length; n++) {
				let i = t.edges[n];
				if (i.triangles.length !== 2) return !1;
				let s = e(t, i.triangles[0], n),
					o = e(t, i.triangles[1], n);
				if (s === null || o === null || s === o) return !1
			}
			return !0
		}
	}

	function wp(r) {
		for (let e = 0; e < r.MaterialCount(); e++) {
			let t = r.GetMaterial(e);
			if (t.isDefault && !t.vertexColors) return !0
		}
		return !1
	}

	function Cp(r, e) {
		for (let t = 0; t < r.MaterialCount(); t++) {
			let n = r.GetMaterial(t);
			n.isDefault && (n.color = e)
		}
	}
	var $t = class r extends sr {
		constructor() {
			super(), this.vertices = [], this.vertexColors = [], this.normals = [], this.uvs = [], this.triangles = []
		}
		VertexCount() {
			return this.vertices.length
		}
		VertexColorCount() {
			return this.vertexColors.length
		}
		NormalCount() {
			return this.normals.length
		}
		TextureUVCount() {
			return this.uvs.length
		}
		TriangleCount() {
			return this.triangles.length
		}
		AddVertex(e) {
			return this.vertices.push(e), this.vertices.length - 1
		}
		SetVertex(e, t) {
			this.vertices[e] = t
		}
		GetVertex(e) {
			return this.vertices[e]
		}
		AddVertexColor(e) {
			return this.vertexColors.push(e), this.vertexColors.length - 1
		}
		SetVertexColor(e, t) {
			this.vertexColors[e] = t
		}
		GetVertexColor(e) {
			return this.vertexColors[e]
		}
		AddNormal(e) {
			return this.normals.push(e), this.normals.length - 1
		}
		SetNormal(e, t) {
			this.normals[e] = t
		}
		GetNormal(e) {
			return this.normals[e]
		}
		AddTextureUV(e) {
			return this.uvs.push(e), this.uvs.length - 1
		}
		SetTextureUV(e, t) {
			this.uvs[e] = t
		}
		GetTextureUV(e) {
			return this.uvs[e]
		}
		AddTriangle(e) {
			return this.triangles.push(e), this.triangles.length - 1
		}
		GetTriangle(e) {
			return this.triangles[e]
		}
		EnumerateVertices(e) {
			for (let t of this.vertices) e(t)
		}
		EnumerateTriangleVertexIndices(e) {
			for (let t of this.triangles) e(t.v0, t.v1, t.v2)
		}
		EnumerateTriangleVertices(e) {
			for (let t of this.triangles) {
				let n = this.vertices[t.v0],
					i = this.vertices[t.v1],
					s = this.vertices[t.v2];
				e(n, i, s)
			}
		}
		Clone() {
			let e = new r;
			e.SetName(this.GetName()), this.CloneProperties(e);
			for (let t = 0; t < this.VertexCount(); t++) {
				let n = this.GetVertex(t);
				e.AddVertex(n.Clone())
			}
			for (let t = 0; t < this.VertexColorCount(); t++) {
				let n = this.GetVertexColor(t);
				e.AddVertexColor(n.Clone())
			}
			for (let t = 0; t < this.NormalCount(); t++) {
				let n = this.GetNormal(t);
				e.AddNormal(n.Clone())
			}
			for (let t = 0; t < this.TextureUVCount(); t++) {
				let n = this.GetTextureUV(t);
				e.AddTextureUV(n.Clone())
			}
			for (let t = 0; t < this.TriangleCount(); t++) {
				let n = this.GetTriangle(t);
				e.AddTriangle(n.Clone())
			}
			return e
		}
	};
	var Ht = class r {
		constructor(e, t, n) {
			this.v0 = e, this.v1 = t, this.v2 = n, this.c0 = null, this.c1 = null, this.c2 = null, this.n0 = null, this.n1 = null, this.n2 = null, this.u0 = null, this.u1 = null, this.u2 = null, this.mat = null, this.curve = null
		}
		HasVertices() {
			return this.v0 !== null && this.v1 !== null && this.v2 !== null
		}
		HasVertexColors() {
			return this.c0 !== null && this.c1 !== null && this.c2 !== null
		}
		HasNormals() {
			return this.n0 !== null && this.n1 !== null && this.n2 !== null
		}
		HasTextureUVs() {
			return this.u0 !== null && this.u1 !== null && this.u2 !== null
		}
		SetVertices(e, t, n) {
			return this.v0 = e, this.v1 = t, this.v2 = n, this
		}
		SetVertexColors(e, t, n) {
			return this.c0 = e, this.c1 = t, this.c2 = n, this
		}
		SetNormals(e, t, n) {
			return this.n0 = e, this.n1 = t, this.n2 = n, this
		}
		SetTextureUVs(e, t, n) {
			return this.u0 = e, this.u1 = t, this.u2 = n, this
		}
		SetMaterial(e) {
			return this.mat = e, this
		}
		SetCurve(e) {
			return this.curve = e, this
		}
		Clone() {
			let e = new r(this.v0, this.v1, this.v2);
			return e.SetVertexColors(this.c0, this.c1, this.c2), e.SetNormals(this.n0, this.n1, this.n2), e.SetTextureUVs(this.u0, this.u1, this.u2), e.SetMaterial(this.mat), e.SetCurve(this.curve), e
		}
	};
	var Zf = "154";
	var ty = 0,
		Rp = 1,
		ny = 2;
	var gg = 1,
		iy = 2,
		Lr = 3,
		_i = 0,
		gn = 1,
		wn = 2;
	var is = 0,
		Jo = 1,
		Ip = 2,
		Pp = 3,
		Lp = 4,
		ry = 5,
		Yo = 100,
		sy = 101,
		oy = 102,
		Np = 103,
		Op = 104,
		ay = 200,
		ly = 201,
		cy = 202,
		uy = 203,
		yg = 204,
		vg = 205,
		hy = 206,
		fy = 207,
		dy = 208,
		py = 209,
		my = 210,
		gy = 0,
		yy = 1,
		vy = 2,
		ff = 3,
		xy = 4,
		_y = 5,
		Ty = 6,
		Ey = 7,
		ku = 0,
		My = 1,
		by = 2,
		Fr = 0,
		Sy = 1,
		Ay = 2,
		wy = 3,
		Cy = 4,
		Ry = 5,
		xg = 300,
		ta = 301,
		na = 302,
		Sl = 303,
		df = 304,
		Bu = 306,
		Qt = 1e3,
		Wt = 1001,
		ia = 1002,
		pn = 1003,
		Dp = 1004;
	var Ch = 1005;
	var mn = 1006,
		Iy = 1007;
	var ki = 1008;
	var rs = 1009,
		Py = 1010,
		Ly = 1011,
		Jf = 1012,
		_g = 1013,
		ns = 1014,
		Or = 1015,
		Al = 1016,
		Tg = 1017,
		Eg = 1018,
		Bs = 1020,
		Ny = 1021,
		xi = 1023,
		Oy = 1024,
		Dy = 1025,
		Gs = 1026,
		ra = 1027,
		Fy = 1028,
		Mg = 1029,
		Uy = 1030,
		bg = 1031,
		Sg = 1033,
		Rh = 33776,
		Ih = 33777,
		Ph = 33778,
		Lh = 33779,
		Fp = 35840,
		Up = 35841,
		kp = 35842,
		Bp = 35843,
		ky = 36196,
		Gp = 37492,
		Vp = 37496,
		zp = 37808,
		Hp = 37809,
		Wp = 37810,
		Xp = 37811,
		qp = 37812,
		jp = 37813,
		Yp = 37814,
		Kp = 37815,
		Zp = 37816,
		Jp = 37817,
		$p = 37818,
		Qp = 37819,
		em = 37820,
		tm = 37821,
		Nh = 36492,
		By = 36283,
		nm = 36284,
		im = 36285,
		rm = 36286;
	var mu = 2300,
		gu = 2301,
		Oh = 2302,
		sm = 2400,
		om = 2401,
		am = 2402,
		Gy = 2500;
	var Ag = 3e3,
		Vs = 3001,
		Vy = 3200,
		zy = 3201,
		Gu = 0,
		Hy = 1,
		zs = "",
		ot = "srgb",
		Bn = "srgb-linear",
		wg = "display-p3";
	var Dh = 7680;
	var Wy = 519,
		Xy = 512,
		qy = 513,
		jy = 514,
		Yy = 515,
		Ky = 516,
		Zy = 517,
		Jy = 518,
		$y = 519,
		lm = 35044;
	var cm = "300 es",
		pf = 1035,
		Dr = 2e3,
		yu = 2001,
		os = class {
			addEventListener(e, t) {
				this._listeners === void 0 && (this._listeners = {});
				let n = this._listeners;
				n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
			}
			hasEventListener(e, t) {
				if (this._listeners === void 0) return !1;
				let n = this._listeners;
				return n[e] !== void 0 && n[e].indexOf(t) !== -1
			}
			removeEventListener(e, t) {
				if (this._listeners === void 0) return;
				let i = this._listeners[e];
				if (i !== void 0) {
					let s = i.indexOf(t);
					s !== -1 && i.splice(s, 1)
				}
			}
			dispatchEvent(e) {
				if (this._listeners === void 0) return;
				let n = this._listeners[e.type];
				if (n !== void 0) {
					e.target = this;
					let i = n.slice(0);
					for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
					e.target = null
				}
			}
		},
		Un = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
		um = 1234567,
		$o = Math.PI / 180,
		sa = 180 / Math.PI;

	function Gr() {
		let r = Math.random() * 4294967295 | 0,
			e = Math.random() * 4294967295 | 0,
			t = Math.random() * 4294967295 | 0,
			n = Math.random() * 4294967295 | 0;
		return (Un[r & 255] + Un[r >> 8 & 255] + Un[r >> 16 & 255] + Un[r >> 24 & 255] + "-" + Un[e & 255] + Un[e >> 8 & 255] + "-" + Un[e >> 16 & 15 | 64] + Un[e >> 24 & 255] + "-" + Un[t & 63 | 128] + Un[t >> 8 & 255] + "-" + Un[t >> 16 & 255] + Un[t >> 24 & 255] + Un[n & 255] + Un[n >> 8 & 255] + Un[n >> 16 & 255] + Un[n >> 24 & 255]).toLowerCase()
	}

	function Pn(r, e, t) {
		return Math.max(e, Math.min(t, r))
	}

	function $f(r, e) {
		return (r % e + e) % e
	}

	function Qy(r, e, t, n, i) {
		return n + (r - e) * (i - n) / (t - e)
	}

	function ev(r, e, t) {
		return r !== e ? (t - r) / (e - r) : 0
	}

	function _l(r, e, t) {
		return (1 - t) * r + t * e
	}

	function tv(r, e, t, n) {
		return _l(r, e, 1 - Math.exp(-t * n))
	}

	function nv(r, e = 1) {
		return e - Math.abs($f(r, e * 2) - e)
	}

	function iv(r, e, t) {
		return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r))
	}

	function rv(r, e, t) {
		return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10))
	}

	function sv(r, e) {
		return r + Math.floor(Math.random() * (e - r + 1))
	}

	function ov(r, e) {
		return r + Math.random() * (e - r)
	}

	function av(r) {
		return r * (.5 - Math.random())
	}

	function lv(r) {
		r !== void 0 && (um = r);
		let e = um += 1831565813;
		return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
	}

	function cv(r) {
		return r * $o
	}

	function uv(r) {
		return r * sa
	}

	function mf(r) {
		return (r & r - 1) === 0 && r !== 0
	}

	function Cg(r) {
		return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
	}

	function vu(r) {
		return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
	}

	function hv(r, e, t, n, i) {
		let s = Math.cos,
			o = Math.sin,
			a = s(t / 2),
			l = o(t / 2),
			c = s((e + n) / 2),
			u = o((e + n) / 2),
			h = s((e - n) / 2),
			f = o((e - n) / 2),
			m = s((n - e) / 2),
			g = o((n - e) / 2);
		switch (i) {
			case "XYX":
				r.set(a * u, l * h, l * f, a * c);
				break;
			case "YZY":
				r.set(l * f, a * u, l * h, a * c);
				break;
			case "ZXZ":
				r.set(l * h, l * f, a * u, a * c);
				break;
			case "XZX":
				r.set(a * u, l * g, l * m, a * c);
				break;
			case "YXY":
				r.set(l * m, a * u, l * g, a * c);
				break;
			case "ZYZ":
				r.set(l * g, l * m, a * u, a * c);
				break;
			default:
				console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
		}
	}

	function vl(r, e) {
		switch (e.constructor) {
			case Float32Array:
				return r;
			case Uint32Array:
				return r / 4294967295;
			case Uint16Array:
				return r / 65535;
			case Uint8Array:
				return r / 255;
			case Int32Array:
				return Math.max(r / 2147483647, -1);
			case Int16Array:
				return Math.max(r / 32767, -1);
			case Int8Array:
				return Math.max(r / 127, -1);
			default:
				throw new Error("Invalid component type.")
		}
	}

	function Qn(r, e) {
		switch (e.constructor) {
			case Float32Array:
				return r;
			case Uint32Array:
				return Math.round(r * 4294967295);
			case Uint16Array:
				return Math.round(r * 65535);
			case Uint8Array:
				return Math.round(r * 255);
			case Int32Array:
				return Math.round(r * 2147483647);
			case Int16Array:
				return Math.round(r * 32767);
			case Int8Array:
				return Math.round(r * 127);
			default:
				throw new Error("Invalid component type.")
		}
	}
	var Nn = {
			DEG2RAD: $o,
			RAD2DEG: sa,
			generateUUID: Gr,
			clamp: Pn,
			euclideanModulo: $f,
			mapLinear: Qy,
			inverseLerp: ev,
			lerp: _l,
			damp: tv,
			pingpong: nv,
			smoothstep: iv,
			smootherstep: rv,
			randInt: sv,
			randFloat: ov,
			randFloatSpread: av,
			seededRandom: lv,
			degToRad: cv,
			radToDeg: uv,
			isPowerOfTwo: mf,
			ceilPowerOfTwo: Cg,
			floorPowerOfTwo: vu,
			setQuaternionFromProperEuler: hv,
			normalize: Qn,
			denormalize: vl
		},
		Ce = class r {
			constructor(e = 0, t = 0) {
				r.prototype.isVector2 = !0, this.x = e, this.y = t
			}
			get width() {
				return this.x
			}
			set width(e) {
				this.x = e
			}
			get height() {
				return this.y
			}
			set height(e) {
				this.y = e
			}
			set(e, t) {
				return this.x = e, this.y = t, this
			}
			setScalar(e) {
				return this.x = e, this.y = e, this
			}
			setX(e) {
				return this.x = e, this
			}
			setY(e) {
				return this.y = e, this
			}
			setComponent(e, t) {
				switch (e) {
					case 0:
						this.x = t;
						break;
					case 1:
						this.y = t;
						break;
					default:
						throw new Error("index is out of range: " + e)
				}
				return this
			}
			getComponent(e) {
				switch (e) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					default:
						throw new Error("index is out of range: " + e)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y)
			}
			copy(e) {
				return this.x = e.x, this.y = e.y, this
			}
			add(e) {
				return this.x += e.x, this.y += e.y, this
			}
			addScalar(e) {
				return this.x += e, this.y += e, this
			}
			addVectors(e, t) {
				return this.x = e.x + t.x, this.y = e.y + t.y, this
			}
			addScaledVector(e, t) {
				return this.x += e.x * t, this.y += e.y * t, this
			}
			sub(e) {
				return this.x -= e.x, this.y -= e.y, this
			}
			subScalar(e) {
				return this.x -= e, this.y -= e, this
			}
			subVectors(e, t) {
				return this.x = e.x - t.x, this.y = e.y - t.y, this
			}
			multiply(e) {
				return this.x *= e.x, this.y *= e.y, this
			}
			multiplyScalar(e) {
				return this.x *= e, this.y *= e, this
			}
			divide(e) {
				return this.x /= e.x, this.y /= e.y, this
			}
			divideScalar(e) {
				return this.multiplyScalar(1 / e)
			}
			applyMatrix3(e) {
				let t = this.x,
					n = this.y,
					i = e.elements;
				return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
			}
			min(e) {
				return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
			}
			max(e) {
				return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
			}
			clamp(e, t) {
				return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
			}
			clampScalar(e, t) {
				return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
			}
			clampLength(e, t) {
				let n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this
			}
			dot(e) {
				return this.x * e.x + this.y * e.y
			}
			cross(e) {
				return this.x * e.y - this.y * e.x
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			angle() {
				return Math.atan2(-this.y, -this.x) + Math.PI
			}
			angleTo(e) {
				let t = Math.sqrt(this.lengthSq() * e.lengthSq());
				if (t === 0) return Math.PI / 2;
				let n = this.dot(e) / t;
				return Math.acos(Pn(n, -1, 1))
			}
			distanceTo(e) {
				return Math.sqrt(this.distanceToSquared(e))
			}
			distanceToSquared(e) {
				let t = this.x - e.x,
					n = this.y - e.y;
				return t * t + n * n
			}
			manhattanDistanceTo(e) {
				return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
			}
			setLength(e) {
				return this.normalize().multiplyScalar(e)
			}
			lerp(e, t) {
				return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
			}
			lerpVectors(e, t, n) {
				return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
			}
			equals(e) {
				return e.x === this.x && e.y === this.y
			}
			fromArray(e, t = 0) {
				return this.x = e[t], this.y = e[t + 1], this
			}
			toArray(e = [], t = 0) {
				return e[t] = this.x, e[t + 1] = this.y, e
			}
			fromBufferAttribute(e, t) {
				return this.x = e.getX(t), this.y = e.getY(t), this
			}
			rotateAround(e, t) {
				let n = Math.cos(t),
					i = Math.sin(t),
					s = this.x - e.x,
					o = this.y - e.y;
				return this.x = s * n - o * i + e.x, this.y = s * i + o * n + e.y, this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y
			}
		},
		pt = class r {
			constructor(e, t, n, i, s, o, a, l, c) {
				r.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, o, a, l, c)
			}
			set(e, t, n, i, s, o, a, l, c) {
				let u = this.elements;
				return u[0] = e, u[1] = i, u[2] = a, u[3] = t, u[4] = s, u[5] = l, u[6] = n, u[7] = o, u[8] = c, this
			}
			identity() {
				return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
			}
			copy(e) {
				let t = this.elements,
					n = e.elements;
				return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
			}
			extractBasis(e, t, n) {
				return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
			}
			setFromMatrix4(e) {
				let t = e.elements;
				return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
			}
			multiply(e) {
				return this.multiplyMatrices(this, e)
			}
			premultiply(e) {
				return this.multiplyMatrices(e, this)
			}
			multiplyMatrices(e, t) {
				let n = e.elements,
					i = t.elements,
					s = this.elements,
					o = n[0],
					a = n[3],
					l = n[6],
					c = n[1],
					u = n[4],
					h = n[7],
					f = n[2],
					m = n[5],
					g = n[8],
					y = i[0],
					d = i[3],
					p = i[6],
					_ = i[1],
					v = i[4],
					x = i[7],
					M = i[2],
					I = i[5],
					w = i[8];
				return s[0] = o * y + a * _ + l * M, s[3] = o * d + a * v + l * I, s[6] = o * p + a * x + l * w, s[1] = c * y + u * _ + h * M, s[4] = c * d + u * v + h * I, s[7] = c * p + u * x + h * w, s[2] = f * y + m * _ + g * M, s[5] = f * d + m * v + g * I, s[8] = f * p + m * x + g * w, this
			}
			multiplyScalar(e) {
				let t = this.elements;
				return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
			}
			determinant() {
				let e = this.elements,
					t = e[0],
					n = e[1],
					i = e[2],
					s = e[3],
					o = e[4],
					a = e[5],
					l = e[6],
					c = e[7],
					u = e[8];
				return t * o * u - t * a * c - n * s * u + n * a * l + i * s * c - i * o * l
			}
			invert() {
				let e = this.elements,
					t = e[0],
					n = e[1],
					i = e[2],
					s = e[3],
					o = e[4],
					a = e[5],
					l = e[6],
					c = e[7],
					u = e[8],
					h = u * o - a * c,
					f = a * l - u * s,
					m = c * s - o * l,
					g = t * h + n * f + i * m;
				if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
				let y = 1 / g;
				return e[0] = h * y, e[1] = (i * c - u * n) * y, e[2] = (a * n - i * o) * y, e[3] = f * y, e[4] = (u * t - i * l) * y, e[5] = (i * s - a * t) * y, e[6] = m * y, e[7] = (n * l - c * t) * y, e[8] = (o * t - n * s) * y, this
			}
			transpose() {
				let e, t = this.elements;
				return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
			}
			getNormalMatrix(e) {
				return this.setFromMatrix4(e).invert().transpose()
			}
			transposeIntoArray(e) {
				let t = this.elements;
				return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
			}
			setUvTransform(e, t, n, i, s, o, a) {
				let l = Math.cos(s),
					c = Math.sin(s);
				return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -i * c, i * l, -i * (-c * o + l * a) + a + t, 0, 0, 1), this
			}
			scale(e, t) {
				return this.premultiply(Fh.makeScale(e, t)), this
			}
			rotate(e) {
				return this.premultiply(Fh.makeRotation(-e)), this
			}
			translate(e, t) {
				return this.premultiply(Fh.makeTranslation(e, t)), this
			}
			makeTranslation(e, t) {
				return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
			}
			makeRotation(e) {
				let t = Math.cos(e),
					n = Math.sin(e);
				return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
			}
			makeScale(e, t) {
				return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
			}
			equals(e) {
				let t = this.elements,
					n = e.elements;
				for (let i = 0; i < 9; i++)
					if (t[i] !== n[i]) return !1;
				return !0
			}
			fromArray(e, t = 0) {
				for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
				return this
			}
			toArray(e = [], t = 0) {
				let n = this.elements;
				return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
			}
			clone() {
				return new this.constructor().fromArray(this.elements)
			}
		},
		Fh = new pt;

	function Rg(r) {
		for (let e = r.length - 1; e >= 0; --e)
			if (r[e] >= 65535) return !0;
		return !1
	}

	function wl(r) {
		return document.createElementNS("http://www.w3.org/1999/xhtml", r)
	}
	var hm = {};

	function Tl(r) {
		r in hm || (hm[r] = !0, console.warn(r))
	}

	function Qo(r) {
		return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
	}

	function Uh(r) {
		return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
	}
	var fv = new pt().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]),
		dv = new pt().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]);

	function pv(r) {
		return r.convertSRGBToLinear().applyMatrix3(dv)
	}

	function mv(r) {
		return r.applyMatrix3(fv).convertLinearToSRGB()
	}
	var gv = {
			[Bn]: r => r,
			[ot]: r => r.convertSRGBToLinear(),
			[wg]: pv
		},
		yv = {
			[Bn]: r => r,
			[ot]: r => r.convertLinearToSRGB(),
			[wg]: mv
		},
		hi = {
			enabled: !0,
			get legacyMode() {
				return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled
			},
			set legacyMode(r) {
				console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !r
			},
			get workingColorSpace() {
				return Bn
			},
			set workingColorSpace(r) {
				console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
			},
			convert: function(r, e, t) {
				if (this.enabled === !1 || e === t || !e || !t) return r;
				let n = gv[e],
					i = yv[t];
				if (n === void 0 || i === void 0) throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);
				return i(n(r))
			},
			fromWorkingColorSpace: function(r, e) {
				return this.convert(r, this.workingColorSpace, e)
			},
			toWorkingColorSpace: function(r, e) {
				return this.convert(r, e, this.workingColorSpace)
			}
		},
		Po, Hs = class {
			static getDataURL(e) {
				if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
				let t;
				if (e instanceof HTMLCanvasElement) t = e;
				else {
					Po === void 0 && (Po = wl("canvas")), Po.width = e.width, Po.height = e.height;
					let n = Po.getContext("2d");
					e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Po
				}
				return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
			}
			static sRGBToLinear(e) {
				if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
					let t = wl("canvas");
					t.width = e.width, t.height = e.height;
					let n = t.getContext("2d");
					n.drawImage(e, 0, 0, e.width, e.height);
					let i = n.getImageData(0, 0, e.width, e.height),
						s = i.data;
					for (let o = 0; o < s.length; o++) s[o] = Qo(s[o] / 255) * 255;
					return n.putImageData(i, 0, 0), t
				} else if (e.data) {
					let t = e.data.slice(0);
					for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Qo(t[n] / 255) * 255) : t[n] = Qo(t[n]);
					return {
						data: t,
						width: e.width,
						height: e.height
					}
				} else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
			}
		},
		vv = 0,
		xu = class {
			constructor(e = null) {
				this.isSource = !0, Object.defineProperty(this, "id", {
					value: vv++
				}), this.uuid = Gr(), this.data = e, this.version = 0
			}
			set needsUpdate(e) {
				e === !0 && this.version++
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string";
				if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
				let n = {
						uuid: this.uuid,
						url: ""
					},
					i = this.data;
				if (i !== null) {
					let s;
					if (Array.isArray(i)) {
						s = [];
						for (let o = 0, a = i.length; o < a; o++) i[o].isDataTexture ? s.push(kh(i[o].image)) : s.push(kh(i[o]))
					} else s = kh(i);
					n.url = s
				}
				return t || (e.images[this.uuid] = n), n
			}
		};

	function kh(r) {
		return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? Hs.getDataURL(r) : r.data ? {
			data: Array.from(r.data),
			width: r.width,
			height: r.height,
			type: r.data.constructor.name
		} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
	}
	var xv = 0,
		Gn = class r extends os {
			constructor(e = r.DEFAULT_IMAGE, t = r.DEFAULT_MAPPING, n = Wt, i = Wt, s = mn, o = ki, a = xi, l = rs, c = r.DEFAULT_ANISOTROPY, u = zs) {
				super(), this.isTexture = !0, Object.defineProperty(this, "id", {
					value: xv++
				}), this.uuid = Gr(), this.name = "", this.source = new xu(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Ce(0, 0), this.repeat = new Ce(1, 1), this.center = new Ce(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new pt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof u == "string" ? this.colorSpace = u : (Tl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = u === Vs ? ot : zs), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
			}
			get image() {
				return this.source.data
			}
			set image(e = null) {
				this.source.data = e
			}
			updateMatrix() {
				this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string";
				if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
				let n = {
					metadata: {
						version: 4.6,
						type: "Texture",
						generator: "Texture.toJSON"
					},
					uuid: this.uuid,
					name: this.name,
					image: this.source.toJSON(e).uuid,
					mapping: this.mapping,
					channel: this.channel,
					repeat: [this.repeat.x, this.repeat.y],
					offset: [this.offset.x, this.offset.y],
					center: [this.center.x, this.center.y],
					rotation: this.rotation,
					wrap: [this.wrapS, this.wrapT],
					format: this.format,
					internalFormat: this.internalFormat,
					type: this.type,
					colorSpace: this.colorSpace,
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
					flipY: this.flipY,
					generateMipmaps: this.generateMipmaps,
					premultiplyAlpha: this.premultiplyAlpha,
					unpackAlignment: this.unpackAlignment
				};
				return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
			transformUv(e) {
				if (this.mapping !== xg) return e;
				if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
					case Qt:
						e.x = e.x - Math.floor(e.x);
						break;
					case Wt:
						e.x = e.x < 0 ? 0 : 1;
						break;
					case ia:
						Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
						break
				}
				if (e.y < 0 || e.y > 1) switch (this.wrapT) {
					case Qt:
						e.y = e.y - Math.floor(e.y);
						break;
					case Wt:
						e.y = e.y < 0 ? 0 : 1;
						break;
					case ia:
						Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
						break
				}
				return this.flipY && (e.y = 1 - e.y), e
			}
			set needsUpdate(e) {
				e === !0 && (this.version++, this.source.needsUpdate = !0)
			}
			get encoding() {
				return Tl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === ot ? Vs : Ag
			}
			set encoding(e) {
				Tl("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Vs ? ot : zs
			}
		};
	Gn.DEFAULT_IMAGE = null;
	Gn.DEFAULT_MAPPING = xg;
	Gn.DEFAULT_ANISOTROPY = 1;
	var Ct = class r {
			constructor(e = 0, t = 0, n = 0, i = 1) {
				r.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
			}
			get width() {
				return this.z
			}
			set width(e) {
				this.z = e
			}
			get height() {
				return this.w
			}
			set height(e) {
				this.w = e
			}
			set(e, t, n, i) {
				return this.x = e, this.y = t, this.z = n, this.w = i, this
			}
			setScalar(e) {
				return this.x = e, this.y = e, this.z = e, this.w = e, this
			}
			setX(e) {
				return this.x = e, this
			}
			setY(e) {
				return this.y = e, this
			}
			setZ(e) {
				return this.z = e, this
			}
			setW(e) {
				return this.w = e, this
			}
			setComponent(e, t) {
				switch (e) {
					case 0:
						this.x = t;
						break;
					case 1:
						this.y = t;
						break;
					case 2:
						this.z = t;
						break;
					case 3:
						this.w = t;
						break;
					default:
						throw new Error("index is out of range: " + e)
				}
				return this
			}
			getComponent(e) {
				switch (e) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					case 3:
						return this.w;
					default:
						throw new Error("index is out of range: " + e)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y, this.z, this.w)
			}
			copy(e) {
				return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
			}
			add(e) {
				return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
			}
			addScalar(e) {
				return this.x += e, this.y += e, this.z += e, this.w += e, this
			}
			addVectors(e, t) {
				return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
			}
			addScaledVector(e, t) {
				return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
			}
			sub(e) {
				return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
			}
			subScalar(e) {
				return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
			}
			subVectors(e, t) {
				return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
			}
			multiply(e) {
				return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
			}
			multiplyScalar(e) {
				return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
			}
			applyMatrix4(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = this.w,
					o = e.elements;
				return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s, this
			}
			divideScalar(e) {
				return this.multiplyScalar(1 / e)
			}
			setAxisAngleFromQuaternion(e) {
				this.w = 2 * Math.acos(e.w);
				let t = Math.sqrt(1 - e.w * e.w);
				return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
			}
			setAxisAngleFromRotationMatrix(e) {
				let t, n, i, s, l = e.elements,
					c = l[0],
					u = l[4],
					h = l[8],
					f = l[1],
					m = l[5],
					g = l[9],
					y = l[2],
					d = l[6],
					p = l[10];
				if (Math.abs(u - f) < .01 && Math.abs(h - y) < .01 && Math.abs(g - d) < .01) {
					if (Math.abs(u + f) < .1 && Math.abs(h + y) < .1 && Math.abs(g + d) < .1 && Math.abs(c + m + p - 3) < .1) return this.set(1, 0, 0, 0), this;
					t = Math.PI;
					let v = (c + 1) / 2,
						x = (m + 1) / 2,
						M = (p + 1) / 2,
						I = (u + f) / 4,
						w = (h + y) / 4,
						L = (g + d) / 4;
					return v > x && v > M ? v < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(v), i = I / n, s = w / n) : x > M ? x < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(x), n = I / i, s = L / i) : M < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(M), n = w / s, i = L / s), this.set(n, i, s, t), this
				}
				let _ = Math.sqrt((d - g) * (d - g) + (h - y) * (h - y) + (f - u) * (f - u));
				return Math.abs(_) < .001 && (_ = 1), this.x = (d - g) / _, this.y = (h - y) / _, this.z = (f - u) / _, this.w = Math.acos((c + m + p - 1) / 2), this
			}
			min(e) {
				return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
			}
			max(e) {
				return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
			}
			clamp(e, t) {
				return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
			}
			clampScalar(e, t) {
				return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
			}
			clampLength(e, t) {
				let n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
			}
			dot(e) {
				return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			setLength(e) {
				return this.normalize().multiplyScalar(e)
			}
			lerp(e, t) {
				return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
			}
			lerpVectors(e, t, n) {
				return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
			}
			equals(e) {
				return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
			}
			fromArray(e, t = 0) {
				return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
			}
			toArray(e = [], t = 0) {
				return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
			}
			fromBufferAttribute(e, t) {
				return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y, yield this.z, yield this.w
			}
		},
		Ur = class extends os {
			constructor(e = 1, t = 1, n = {}) {
				super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Ct(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ct(0, 0, e, t);
				let i = {
					width: e,
					height: t,
					depth: 1
				};
				n.encoding !== void 0 && (Tl("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === Vs ? ot : zs), this.texture = new Gn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : mn, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0
			}
			setSize(e, t, n = 1) {
				(this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
				let t = Object.assign({}, e.texture.image);
				return this.texture.source = new xu(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
		},
		_u = class extends Gn {
			constructor(e = null, t = 1, n = 1, i = 1) {
				super(null), this.isDataArrayTexture = !0, this.image = {
					data: e,
					width: t,
					height: n,
					depth: i
				}, this.magFilter = pn, this.minFilter = pn, this.wrapR = Wt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
			}
		};
	var gf = class extends Gn {
		constructor(e = null, t = 1, n = 1, i = 1) {
			super(null), this.isData3DTexture = !0, this.image = {
				data: e,
				width: t,
				height: n,
				depth: i
			}, this.magFilter = pn, this.minFilter = pn, this.wrapR = Wt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
		}
	};
	var yn = class {
			constructor(e = 0, t = 0, n = 0, i = 1) {
				this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
			}
			static slerpFlat(e, t, n, i, s, o, a) {
				let l = n[i + 0],
					c = n[i + 1],
					u = n[i + 2],
					h = n[i + 3],
					f = s[o + 0],
					m = s[o + 1],
					g = s[o + 2],
					y = s[o + 3];
				if (a === 0) {
					e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
					return
				}
				if (a === 1) {
					e[t + 0] = f, e[t + 1] = m, e[t + 2] = g, e[t + 3] = y;
					return
				}
				if (h !== y || l !== f || c !== m || u !== g) {
					let d = 1 - a,
						p = l * f + c * m + u * g + h * y,
						_ = p >= 0 ? 1 : -1,
						v = 1 - p * p;
					if (v > Number.EPSILON) {
						let M = Math.sqrt(v),
							I = Math.atan2(M, p * _);
						d = Math.sin(d * I) / M, a = Math.sin(a * I) / M
					}
					let x = a * _;
					if (l = l * d + f * x, c = c * d + m * x, u = u * d + g * x, h = h * d + y * x, d === 1 - a) {
						let M = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
						l *= M, c *= M, u *= M, h *= M
					}
				}
				e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h
			}
			static multiplyQuaternionsFlat(e, t, n, i, s, o) {
				let a = n[i],
					l = n[i + 1],
					c = n[i + 2],
					u = n[i + 3],
					h = s[o],
					f = s[o + 1],
					m = s[o + 2],
					g = s[o + 3];
				return e[t] = a * g + u * h + l * m - c * f, e[t + 1] = l * g + u * f + c * h - a * m, e[t + 2] = c * g + u * m + a * f - l * h, e[t + 3] = u * g - a * h - l * f - c * m, e
			}
			get x() {
				return this._x
			}
			set x(e) {
				this._x = e, this._onChangeCallback()
			}
			get y() {
				return this._y
			}
			set y(e) {
				this._y = e, this._onChangeCallback()
			}
			get z() {
				return this._z
			}
			set z(e) {
				this._z = e, this._onChangeCallback()
			}
			get w() {
				return this._w
			}
			set w(e) {
				this._w = e, this._onChangeCallback()
			}
			set(e, t, n, i) {
				return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
			}
			clone() {
				return new this.constructor(this._x, this._y, this._z, this._w)
			}
			copy(e) {
				return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
			}
			setFromEuler(e, t) {
				let n = e._x,
					i = e._y,
					s = e._z,
					o = e._order,
					a = Math.cos,
					l = Math.sin,
					c = a(n / 2),
					u = a(i / 2),
					h = a(s / 2),
					f = l(n / 2),
					m = l(i / 2),
					g = l(s / 2);
				switch (o) {
					case "XYZ":
						this._x = f * u * h + c * m * g, this._y = c * m * h - f * u * g, this._z = c * u * g + f * m * h, this._w = c * u * h - f * m * g;
						break;
					case "YXZ":
						this._x = f * u * h + c * m * g, this._y = c * m * h - f * u * g, this._z = c * u * g - f * m * h, this._w = c * u * h + f * m * g;
						break;
					case "ZXY":
						this._x = f * u * h - c * m * g, this._y = c * m * h + f * u * g, this._z = c * u * g + f * m * h, this._w = c * u * h - f * m * g;
						break;
					case "ZYX":
						this._x = f * u * h - c * m * g, this._y = c * m * h + f * u * g, this._z = c * u * g - f * m * h, this._w = c * u * h + f * m * g;
						break;
					case "YZX":
						this._x = f * u * h + c * m * g, this._y = c * m * h + f * u * g, this._z = c * u * g - f * m * h, this._w = c * u * h - f * m * g;
						break;
					case "XZY":
						this._x = f * u * h - c * m * g, this._y = c * m * h - f * u * g, this._z = c * u * g + f * m * h, this._w = c * u * h + f * m * g;
						break;
					default:
						console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
				}
				return t !== !1 && this._onChangeCallback(), this
			}
			setFromAxisAngle(e, t) {
				let n = t / 2,
					i = Math.sin(n);
				return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
			}
			setFromRotationMatrix(e) {
				let t = e.elements,
					n = t[0],
					i = t[4],
					s = t[8],
					o = t[1],
					a = t[5],
					l = t[9],
					c = t[2],
					u = t[6],
					h = t[10],
					f = n + a + h;
				if (f > 0) {
					let m = .5 / Math.sqrt(f + 1);
					this._w = .25 / m, this._x = (u - l) * m, this._y = (s - c) * m, this._z = (o - i) * m
				} else if (n > a && n > h) {
					let m = 2 * Math.sqrt(1 + n - a - h);
					this._w = (u - l) / m, this._x = .25 * m, this._y = (i + o) / m, this._z = (s + c) / m
				} else if (a > h) {
					let m = 2 * Math.sqrt(1 + a - n - h);
					this._w = (s - c) / m, this._x = (i + o) / m, this._y = .25 * m, this._z = (l + u) / m
				} else {
					let m = 2 * Math.sqrt(1 + h - n - a);
					this._w = (o - i) / m, this._x = (s + c) / m, this._y = (l + u) / m, this._z = .25 * m
				}
				return this._onChangeCallback(), this
			}
			setFromUnitVectors(e, t) {
				let n = e.dot(t) + 1;
				return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
			}
			angleTo(e) {
				return 2 * Math.acos(Math.abs(Pn(this.dot(e), -1, 1)))
			}
			rotateTowards(e, t) {
				let n = this.angleTo(e);
				if (n === 0) return this;
				let i = Math.min(1, t / n);
				return this.slerp(e, i), this
			}
			identity() {
				return this.set(0, 0, 0, 1)
			}
			invert() {
				return this.conjugate()
			}
			conjugate() {
				return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
			}
			dot(e) {
				return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
			}
			lengthSq() {
				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
			}
			length() {
				return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
			}
			normalize() {
				let e = this.length();
				return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
			}
			multiply(e) {
				return this.multiplyQuaternions(this, e)
			}
			premultiply(e) {
				return this.multiplyQuaternions(e, this)
			}
			multiplyQuaternions(e, t) {
				let n = e._x,
					i = e._y,
					s = e._z,
					o = e._w,
					a = t._x,
					l = t._y,
					c = t._z,
					u = t._w;
				return this._x = n * u + o * a + i * c - s * l, this._y = i * u + o * l + s * a - n * c, this._z = s * u + o * c + n * l - i * a, this._w = o * u - n * a - i * l - s * c, this._onChangeCallback(), this
			}
			slerp(e, t) {
				if (t === 0) return this;
				if (t === 1) return this.copy(e);
				let n = this._x,
					i = this._y,
					s = this._z,
					o = this._w,
					a = o * e._w + n * e._x + i * e._y + s * e._z;
				if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = s, this;
				let l = 1 - a * a;
				if (l <= Number.EPSILON) {
					let m = 1 - t;
					return this._w = m * o + t * this._w, this._x = m * n + t * this._x, this._y = m * i + t * this._y, this._z = m * s + t * this._z, this.normalize(), this._onChangeCallback(), this
				}
				let c = Math.sqrt(l),
					u = Math.atan2(c, a),
					h = Math.sin((1 - t) * u) / c,
					f = Math.sin(t * u) / c;
				return this._w = o * h + this._w * f, this._x = n * h + this._x * f, this._y = i * h + this._y * f, this._z = s * h + this._z * f, this._onChangeCallback(), this
			}
			slerpQuaternions(e, t, n) {
				return this.copy(e).slerp(t, n)
			}
			random() {
				let e = Math.random(),
					t = Math.sqrt(1 - e),
					n = Math.sqrt(e),
					i = 2 * Math.PI * Math.random(),
					s = 2 * Math.PI * Math.random();
				return this.set(t * Math.cos(i), n * Math.sin(s), n * Math.cos(s), t * Math.sin(i))
			}
			equals(e) {
				return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
			}
			fromArray(e, t = 0) {
				return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
			}
			toArray(e = [], t = 0) {
				return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
			}
			fromBufferAttribute(e, t) {
				return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
			}
			toJSON() {
				return this.toArray()
			}
			_onChange(e) {
				return this._onChangeCallback = e, this
			}
			_onChangeCallback() {}*[Symbol.iterator]() {
				yield this._x, yield this._y, yield this._z, yield this._w
			}
		},
		re = class r {
			constructor(e = 0, t = 0, n = 0) {
				r.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
			}
			set(e, t, n) {
				return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this
			}
			setScalar(e) {
				return this.x = e, this.y = e, this.z = e, this
			}
			setX(e) {
				return this.x = e, this
			}
			setY(e) {
				return this.y = e, this
			}
			setZ(e) {
				return this.z = e, this
			}
			setComponent(e, t) {
				switch (e) {
					case 0:
						this.x = t;
						break;
					case 1:
						this.y = t;
						break;
					case 2:
						this.z = t;
						break;
					default:
						throw new Error("index is out of range: " + e)
				}
				return this
			}
			getComponent(e) {
				switch (e) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					default:
						throw new Error("index is out of range: " + e)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y, this.z)
			}
			copy(e) {
				return this.x = e.x, this.y = e.y, this.z = e.z, this
			}
			add(e) {
				return this.x += e.x, this.y += e.y, this.z += e.z, this
			}
			addScalar(e) {
				return this.x += e, this.y += e, this.z += e, this
			}
			addVectors(e, t) {
				return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
			}
			addScaledVector(e, t) {
				return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
			}
			sub(e) {
				return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
			}
			subScalar(e) {
				return this.x -= e, this.y -= e, this.z -= e, this
			}
			subVectors(e, t) {
				return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
			}
			multiply(e) {
				return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
			}
			multiplyScalar(e) {
				return this.x *= e, this.y *= e, this.z *= e, this
			}
			multiplyVectors(e, t) {
				return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
			}
			applyEuler(e) {
				return this.applyQuaternion(fm.setFromEuler(e))
			}
			applyAxisAngle(e, t) {
				return this.applyQuaternion(fm.setFromAxisAngle(e, t))
			}
			applyMatrix3(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.elements;
				return this.x = s[0] * t + s[3] * n + s[6] * i, this.y = s[1] * t + s[4] * n + s[7] * i, this.z = s[2] * t + s[5] * n + s[8] * i, this
			}
			applyNormalMatrix(e) {
				return this.applyMatrix3(e).normalize()
			}
			applyMatrix4(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.elements,
					o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
				return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o, this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o, this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o, this
			}
			applyQuaternion(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.x,
					o = e.y,
					a = e.z,
					l = e.w,
					c = l * t + o * i - a * n,
					u = l * n + a * t - s * i,
					h = l * i + s * n - o * t,
					f = -s * t - o * n - a * i;
				return this.x = c * l + f * -s + u * -a - h * -o, this.y = u * l + f * -o + h * -s - c * -a, this.z = h * l + f * -a + c * -o - u * -s, this
			}
			project(e) {
				return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
			}
			unproject(e) {
				return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
			}
			transformDirection(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.elements;
				return this.x = s[0] * t + s[4] * n + s[8] * i, this.y = s[1] * t + s[5] * n + s[9] * i, this.z = s[2] * t + s[6] * n + s[10] * i, this.normalize()
			}
			divide(e) {
				return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
			}
			divideScalar(e) {
				return this.multiplyScalar(1 / e)
			}
			min(e) {
				return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
			}
			max(e) {
				return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
			}
			clamp(e, t) {
				return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
			}
			clampScalar(e, t) {
				return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
			}
			clampLength(e, t) {
				let n = this.length();
				return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
			}
			dot(e) {
				return this.x * e.x + this.y * e.y + this.z * e.z
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			setLength(e) {
				return this.normalize().multiplyScalar(e)
			}
			lerp(e, t) {
				return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
			}
			lerpVectors(e, t, n) {
				return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
			}
			cross(e) {
				return this.crossVectors(this, e)
			}
			crossVectors(e, t) {
				let n = e.x,
					i = e.y,
					s = e.z,
					o = t.x,
					a = t.y,
					l = t.z;
				return this.x = i * l - s * a, this.y = s * o - n * l, this.z = n * a - i * o, this
			}
			projectOnVector(e) {
				let t = e.lengthSq();
				if (t === 0) return this.set(0, 0, 0);
				let n = e.dot(this) / t;
				return this.copy(e).multiplyScalar(n)
			}
			projectOnPlane(e) {
				return Bh.copy(this).projectOnVector(e), this.sub(Bh)
			}
			reflect(e) {
				return this.sub(Bh.copy(e).multiplyScalar(2 * this.dot(e)))
			}
			angleTo(e) {
				let t = Math.sqrt(this.lengthSq() * e.lengthSq());
				if (t === 0) return Math.PI / 2;
				let n = this.dot(e) / t;
				return Math.acos(Pn(n, -1, 1))
			}
			distanceTo(e) {
				return Math.sqrt(this.distanceToSquared(e))
			}
			distanceToSquared(e) {
				let t = this.x - e.x,
					n = this.y - e.y,
					i = this.z - e.z;
				return t * t + n * n + i * i
			}
			manhattanDistanceTo(e) {
				return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
			}
			setFromSpherical(e) {
				return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
			}
			setFromSphericalCoords(e, t, n) {
				let i = Math.sin(t) * e;
				return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
			}
			setFromCylindrical(e) {
				return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
			}
			setFromCylindricalCoords(e, t, n) {
				return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
			}
			setFromMatrixPosition(e) {
				let t = e.elements;
				return this.x = t[12], this.y = t[13], this.z = t[14], this
			}
			setFromMatrixScale(e) {
				let t = this.setFromMatrixColumn(e, 0).length(),
					n = this.setFromMatrixColumn(e, 1).length(),
					i = this.setFromMatrixColumn(e, 2).length();
				return this.x = t, this.y = n, this.z = i, this
			}
			setFromMatrixColumn(e, t) {
				return this.fromArray(e.elements, t * 4)
			}
			setFromMatrix3Column(e, t) {
				return this.fromArray(e.elements, t * 3)
			}
			setFromEuler(e) {
				return this.x = e._x, this.y = e._y, this.z = e._z, this
			}
			setFromColor(e) {
				return this.x = e.r, this.y = e.g, this.z = e.b, this
			}
			equals(e) {
				return e.x === this.x && e.y === this.y && e.z === this.z
			}
			fromArray(e, t = 0) {
				return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
			}
			toArray(e = [], t = 0) {
				return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
			}
			fromBufferAttribute(e, t) {
				return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
			}
			randomDirection() {
				let e = (Math.random() - .5) * 2,
					t = Math.random() * Math.PI * 2,
					n = Math.sqrt(1 - e ** 2);
				return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y, yield this.z
			}
		},
		Bh = new re,
		fm = new yn,
		Bi = class {
			constructor(e = new re(1 / 0, 1 / 0, 1 / 0), t = new re(-1 / 0, -1 / 0, -1 / 0)) {
				this.isBox3 = !0, this.min = e, this.max = t
			}
			set(e, t) {
				return this.min.copy(e), this.max.copy(t), this
			}
			setFromArray(e) {
				this.makeEmpty();
				for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(Ar.fromArray(e, t));
				return this
			}
			setFromBufferAttribute(e) {
				this.makeEmpty();
				for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(Ar.fromBufferAttribute(e, t));
				return this
			}
			setFromPoints(e) {
				this.makeEmpty();
				for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
				return this
			}
			setFromCenterAndSize(e, t) {
				let n = Ar.copy(t).multiplyScalar(.5);
				return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
			}
			setFromObject(e, t = !1) {
				return this.makeEmpty(), this.expandByObject(e, t)
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				return this.min.copy(e.min), this.max.copy(e.max), this
			}
			makeEmpty() {
				return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
			}
			isEmpty() {
				return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
			}
			getCenter(e) {
				return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
			}
			getSize(e) {
				return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
			}
			expandByPoint(e) {
				return this.min.min(e), this.max.max(e), this
			}
			expandByVector(e) {
				return this.min.sub(e), this.max.add(e), this
			}
			expandByScalar(e) {
				return this.min.addScalar(-e), this.max.addScalar(e), this
			}
			expandByObject(e, t = !1) {
				if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0) e.boundingBox === null && e.computeBoundingBox(), Lo.copy(e.boundingBox), Lo.applyMatrix4(e.matrixWorld), this.union(Lo);
				else {
					let i = e.geometry;
					if (i !== void 0)
						if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
							let s = i.attributes.position;
							for (let o = 0, a = s.count; o < a; o++) Ar.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(Ar)
						} else i.boundingBox === null && i.computeBoundingBox(), Lo.copy(i.boundingBox), Lo.applyMatrix4(e.matrixWorld), this.union(Lo)
				}
				let n = e.children;
				for (let i = 0, s = n.length; i < s; i++) this.expandByObject(n[i], t);
				return this
			}
			containsPoint(e) {
				return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
			}
			containsBox(e) {
				return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
			}
			getParameter(e, t) {
				return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
			}
			intersectsBox(e) {
				return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
			}
			intersectsSphere(e) {
				return this.clampPoint(e.center, Ar), Ar.distanceToSquared(e.center) <= e.radius * e.radius
			}
			intersectsPlane(e) {
				let t, n;
				return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
			}
			intersectsTriangle(e) {
				if (this.isEmpty()) return !1;
				this.getCenter(dl), Bc.subVectors(this.max, dl), No.subVectors(e.a, dl), Oo.subVectors(e.b, dl), Do.subVectors(e.c, dl), Jr.subVectors(Oo, No), $r.subVectors(Do, Oo), Ls.subVectors(No, Do);
				let t = [0, -Jr.z, Jr.y, 0, -$r.z, $r.y, 0, -Ls.z, Ls.y, Jr.z, 0, -Jr.x, $r.z, 0, -$r.x, Ls.z, 0, -Ls.x, -Jr.y, Jr.x, 0, -$r.y, $r.x, 0, -Ls.y, Ls.x, 0];
				return !Gh(t, No, Oo, Do, Bc) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Gh(t, No, Oo, Do, Bc)) ? !1 : (Gc.crossVectors(Jr, $r), t = [Gc.x, Gc.y, Gc.z], Gh(t, No, Oo, Do, Bc))
			}
			clampPoint(e, t) {
				return t.copy(e).clamp(this.min, this.max)
			}
			distanceToPoint(e) {
				return this.clampPoint(e, Ar).distanceTo(e)
			}
			getBoundingSphere(e) {
				return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Ar).length() * .5), e
			}
			intersect(e) {
				return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
			}
			union(e) {
				return this.min.min(e.min), this.max.max(e.max), this
			}
			applyMatrix4(e) {
				return this.isEmpty() ? this : (Sr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Sr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Sr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Sr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Sr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Sr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Sr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Sr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Sr), this)
			}
			translate(e) {
				return this.min.add(e), this.max.add(e), this
			}
			equals(e) {
				return e.min.equals(this.min) && e.max.equals(this.max)
			}
		},
		Sr = [new re, new re, new re, new re, new re, new re, new re, new re],
		Ar = new re,
		Lo = new Bi,
		No = new re,
		Oo = new re,
		Do = new re,
		Jr = new re,
		$r = new re,
		Ls = new re,
		dl = new re,
		Bc = new re,
		Gc = new re,
		Ns = new re;

	function Gh(r, e, t, n, i) {
		for (let s = 0, o = r.length - 3; s <= o; s += 3) {
			Ns.fromArray(r, s);
			let a = i.x * Math.abs(Ns.x) + i.y * Math.abs(Ns.y) + i.z * Math.abs(Ns.z),
				l = e.dot(Ns),
				c = t.dot(Ns),
				u = n.dot(Ns);
			if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1
		}
		return !0
	}
	var _v = new Bi,
		pl = new re,
		Vh = new re,
		Gi = class {
			constructor(e = new re, t = -1) {
				this.center = e, this.radius = t
			}
			set(e, t) {
				return this.center.copy(e), this.radius = t, this
			}
			setFromPoints(e, t) {
				let n = this.center;
				t !== void 0 ? n.copy(t) : _v.setFromPoints(e).getCenter(n);
				let i = 0;
				for (let s = 0, o = e.length; s < o; s++) i = Math.max(i, n.distanceToSquared(e[s]));
				return this.radius = Math.sqrt(i), this
			}
			copy(e) {
				return this.center.copy(e.center), this.radius = e.radius, this
			}
			isEmpty() {
				return this.radius < 0
			}
			makeEmpty() {
				return this.center.set(0, 0, 0), this.radius = -1, this
			}
			containsPoint(e) {
				return e.distanceToSquared(this.center) <= this.radius * this.radius
			}
			distanceToPoint(e) {
				return e.distanceTo(this.center) - this.radius
			}
			intersectsSphere(e) {
				let t = this.radius + e.radius;
				return e.center.distanceToSquared(this.center) <= t * t
			}
			intersectsBox(e) {
				return e.intersectsSphere(this)
			}
			intersectsPlane(e) {
				return Math.abs(e.distanceToPoint(this.center)) <= this.radius
			}
			clampPoint(e, t) {
				let n = this.center.distanceToSquared(e);
				return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
			}
			getBoundingBox(e) {
				return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
			}
			applyMatrix4(e) {
				return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
			}
			translate(e) {
				return this.center.add(e), this
			}
			expandByPoint(e) {
				if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
				pl.subVectors(e, this.center);
				let t = pl.lengthSq();
				if (t > this.radius * this.radius) {
					let n = Math.sqrt(t),
						i = (n - this.radius) * .5;
					this.center.addScaledVector(pl, i / n), this.radius += i
				}
				return this
			}
			union(e) {
				return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Vh.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(pl.copy(e.center).add(Vh)), this.expandByPoint(pl.copy(e.center).sub(Vh))), this)
			}
			equals(e) {
				return e.center.equals(this.center) && e.radius === this.radius
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		wr = new re,
		zh = new re,
		Vc = new re,
		Qr = new re,
		Hh = new re,
		zc = new re,
		Wh = new re,
		Ws = class {
			constructor(e = new re, t = new re(0, 0, -1)) {
				this.origin = e, this.direction = t
			}
			set(e, t) {
				return this.origin.copy(e), this.direction.copy(t), this
			}
			copy(e) {
				return this.origin.copy(e.origin), this.direction.copy(e.direction), this
			}
			at(e, t) {
				return t.copy(this.origin).addScaledVector(this.direction, e)
			}
			lookAt(e) {
				return this.direction.copy(e).sub(this.origin).normalize(), this
			}
			recast(e) {
				return this.origin.copy(this.at(e, wr)), this
			}
			closestPointToPoint(e, t) {
				t.subVectors(e, this.origin);
				let n = t.dot(this.direction);
				return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
			}
			distanceToPoint(e) {
				return Math.sqrt(this.distanceSqToPoint(e))
			}
			distanceSqToPoint(e) {
				let t = wr.subVectors(e, this.origin).dot(this.direction);
				return t < 0 ? this.origin.distanceToSquared(e) : (wr.copy(this.origin).addScaledVector(this.direction, t), wr.distanceToSquared(e))
			}
			distanceSqToSegment(e, t, n, i) {
				zh.copy(e).add(t).multiplyScalar(.5), Vc.copy(t).sub(e).normalize(), Qr.copy(this.origin).sub(zh);
				let s = e.distanceTo(t) * .5,
					o = -this.direction.dot(Vc),
					a = Qr.dot(this.direction),
					l = -Qr.dot(Vc),
					c = Qr.lengthSq(),
					u = Math.abs(1 - o * o),
					h, f, m, g;
				if (u > 0)
					if (h = o * l - a, f = o * a - l, g = s * u, h >= 0)
						if (f >= -g)
							if (f <= g) {
								let y = 1 / u;
								h *= y, f *= y, m = h * (h + o * f + 2 * a) + f * (o * h + f + 2 * l) + c
							} else f = s, h = Math.max(0, -(o * f + a)), m = -h * h + f * (f + 2 * l) + c;
				else f = -s, h = Math.max(0, -(o * f + a)), m = -h * h + f * (f + 2 * l) + c;
				else f <= -g ? (h = Math.max(0, -(-o * s + a)), f = h > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -h * h + f * (f + 2 * l) + c) : f <= g ? (h = 0, f = Math.min(Math.max(-s, -l), s), m = f * (f + 2 * l) + c) : (h = Math.max(0, -(o * s + a)), f = h > 0 ? s : Math.min(Math.max(-s, -l), s), m = -h * h + f * (f + 2 * l) + c);
				else f = o > 0 ? -s : s, h = Math.max(0, -(o * f + a)), m = -h * h + f * (f + 2 * l) + c;
				return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(zh).addScaledVector(Vc, f), m
			}
			intersectSphere(e, t) {
				wr.subVectors(e.center, this.origin);
				let n = wr.dot(this.direction),
					i = wr.dot(wr) - n * n,
					s = e.radius * e.radius;
				if (i > s) return null;
				let o = Math.sqrt(s - i),
					a = n - o,
					l = n + o;
				return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
			}
			intersectsSphere(e) {
				return this.distanceSqToPoint(e.center) <= e.radius * e.radius
			}
			distanceToPlane(e) {
				let t = e.normal.dot(this.direction);
				if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
				let n = -(this.origin.dot(e.normal) + e.constant) / t;
				return n >= 0 ? n : null
			}
			intersectPlane(e, t) {
				let n = this.distanceToPlane(e);
				return n === null ? null : this.at(n, t)
			}
			intersectsPlane(e) {
				let t = e.distanceToPoint(this.origin);
				return t === 0 || e.normal.dot(this.direction) * t < 0
			}
			intersectBox(e, t) {
				let n, i, s, o, a, l, c = 1 / this.direction.x,
					u = 1 / this.direction.y,
					h = 1 / this.direction.z,
					f = this.origin;
				return c >= 0 ? (n = (e.min.x - f.x) * c, i = (e.max.x - f.x) * c) : (n = (e.max.x - f.x) * c, i = (e.min.x - f.x) * c), u >= 0 ? (s = (e.min.y - f.y) * u, o = (e.max.y - f.y) * u) : (s = (e.max.y - f.y) * u, o = (e.min.y - f.y) * u), n > o || s > i || ((s > n || isNaN(n)) && (n = s), (o < i || isNaN(i)) && (i = o), h >= 0 ? (a = (e.min.z - f.z) * h, l = (e.max.z - f.z) * h) : (a = (e.max.z - f.z) * h, l = (e.min.z - f.z) * h), n > l || a > i) || ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t)
			}
			intersectsBox(e) {
				return this.intersectBox(e, wr) !== null
			}
			intersectTriangle(e, t, n, i, s) {
				Hh.subVectors(t, e), zc.subVectors(n, e), Wh.crossVectors(Hh, zc);
				let o = this.direction.dot(Wh),
					a;
				if (o > 0) {
					if (i) return null;
					a = 1
				} else if (o < 0) a = -1, o = -o;
				else return null;
				Qr.subVectors(this.origin, e);
				let l = a * this.direction.dot(zc.crossVectors(Qr, zc));
				if (l < 0) return null;
				let c = a * this.direction.dot(Hh.cross(Qr));
				if (c < 0 || l + c > o) return null;
				let u = -a * Qr.dot(Wh);
				return u < 0 ? null : this.at(u / o, s)
			}
			applyMatrix4(e) {
				return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
			}
			equals(e) {
				return e.origin.equals(this.origin) && e.direction.equals(this.direction)
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		Je = class r {
			constructor(e, t, n, i, s, o, a, l, c, u, h, f, m, g, y, d) {
				r.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, o, a, l, c, u, h, f, m, g, y, d)
			}
			set(e, t, n, i, s, o, a, l, c, u, h, f, m, g, y, d) {
				let p = this.elements;
				return p[0] = e, p[4] = t, p[8] = n, p[12] = i, p[1] = s, p[5] = o, p[9] = a, p[13] = l, p[2] = c, p[6] = u, p[10] = h, p[14] = f, p[3] = m, p[7] = g, p[11] = y, p[15] = d, this
			}
			identity() {
				return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
			}
			clone() {
				return new r().fromArray(this.elements)
			}
			copy(e) {
				let t = this.elements,
					n = e.elements;
				return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
			}
			copyPosition(e) {
				let t = this.elements,
					n = e.elements;
				return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
			}
			setFromMatrix3(e) {
				let t = e.elements;
				return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
			}
			extractBasis(e, t, n) {
				return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
			}
			makeBasis(e, t, n) {
				return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
			}
			extractRotation(e) {
				let t = this.elements,
					n = e.elements,
					i = 1 / Fo.setFromMatrixColumn(e, 0).length(),
					s = 1 / Fo.setFromMatrixColumn(e, 1).length(),
					o = 1 / Fo.setFromMatrixColumn(e, 2).length();
				return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
			}
			makeRotationFromEuler(e) {
				let t = this.elements,
					n = e.x,
					i = e.y,
					s = e.z,
					o = Math.cos(n),
					a = Math.sin(n),
					l = Math.cos(i),
					c = Math.sin(i),
					u = Math.cos(s),
					h = Math.sin(s);
				if (e.order === "XYZ") {
					let f = o * u,
						m = o * h,
						g = a * u,
						y = a * h;
					t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = m + g * c, t[5] = f - y * c, t[9] = -a * l, t[2] = y - f * c, t[6] = g + m * c, t[10] = o * l
				} else if (e.order === "YXZ") {
					let f = l * u,
						m = l * h,
						g = c * u,
						y = c * h;
					t[0] = f + y * a, t[4] = g * a - m, t[8] = o * c, t[1] = o * h, t[5] = o * u, t[9] = -a, t[2] = m * a - g, t[6] = y + f * a, t[10] = o * l
				} else if (e.order === "ZXY") {
					let f = l * u,
						m = l * h,
						g = c * u,
						y = c * h;
					t[0] = f - y * a, t[4] = -o * h, t[8] = g + m * a, t[1] = m + g * a, t[5] = o * u, t[9] = y - f * a, t[2] = -o * c, t[6] = a, t[10] = o * l
				} else if (e.order === "ZYX") {
					let f = o * u,
						m = o * h,
						g = a * u,
						y = a * h;
					t[0] = l * u, t[4] = g * c - m, t[8] = f * c + y, t[1] = l * h, t[5] = y * c + f, t[9] = m * c - g, t[2] = -c, t[6] = a * l, t[10] = o * l
				} else if (e.order === "YZX") {
					let f = o * l,
						m = o * c,
						g = a * l,
						y = a * c;
					t[0] = l * u, t[4] = y - f * h, t[8] = g * h + m, t[1] = h, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = m * h + g, t[10] = f - y * h
				} else if (e.order === "XZY") {
					let f = o * l,
						m = o * c,
						g = a * l,
						y = a * c;
					t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = f * h + y, t[5] = o * u, t[9] = m * h - g, t[2] = g * h - m, t[6] = a * u, t[10] = y * h + f
				}
				return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
			}
			makeRotationFromQuaternion(e) {
				return this.compose(Tv, e, Ev)
			}
			lookAt(e, t, n) {
				let i = this.elements;
				return ci.subVectors(e, t), ci.lengthSq() === 0 && (ci.z = 1), ci.normalize(), es.crossVectors(n, ci), es.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ci.x += 1e-4 : ci.z += 1e-4, ci.normalize(), es.crossVectors(n, ci)), es.normalize(), Hc.crossVectors(ci, es), i[0] = es.x, i[4] = Hc.x, i[8] = ci.x, i[1] = es.y, i[5] = Hc.y, i[9] = ci.y, i[2] = es.z, i[6] = Hc.z, i[10] = ci.z, this
			}
			multiply(e) {
				return this.multiplyMatrices(this, e)
			}
			premultiply(e) {
				return this.multiplyMatrices(e, this)
			}
			multiplyMatrices(e, t) {
				let n = e.elements,
					i = t.elements,
					s = this.elements,
					o = n[0],
					a = n[4],
					l = n[8],
					c = n[12],
					u = n[1],
					h = n[5],
					f = n[9],
					m = n[13],
					g = n[2],
					y = n[6],
					d = n[10],
					p = n[14],
					_ = n[3],
					v = n[7],
					x = n[11],
					M = n[15],
					I = i[0],
					w = i[4],
					L = i[8],
					T = i[12],
					C = i[1],
					V = i[5],
					k = i[9],
					F = i[13],
					U = i[2],
					K = i[6],
					Z = i[10],
					Y = i[14],
					H = i[3],
					oe = i[7],
					de = i[11],
					te = i[15];
				return s[0] = o * I + a * C + l * U + c * H, s[4] = o * w + a * V + l * K + c * oe, s[8] = o * L + a * k + l * Z + c * de, s[12] = o * T + a * F + l * Y + c * te, s[1] = u * I + h * C + f * U + m * H, s[5] = u * w + h * V + f * K + m * oe, s[9] = u * L + h * k + f * Z + m * de, s[13] = u * T + h * F + f * Y + m * te, s[2] = g * I + y * C + d * U + p * H, s[6] = g * w + y * V + d * K + p * oe, s[10] = g * L + y * k + d * Z + p * de, s[14] = g * T + y * F + d * Y + p * te, s[3] = _ * I + v * C + x * U + M * H, s[7] = _ * w + v * V + x * K + M * oe, s[11] = _ * L + v * k + x * Z + M * de, s[15] = _ * T + v * F + x * Y + M * te, this
			}
			multiplyScalar(e) {
				let t = this.elements;
				return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
			}
			determinant() {
				let e = this.elements,
					t = e[0],
					n = e[4],
					i = e[8],
					s = e[12],
					o = e[1],
					a = e[5],
					l = e[9],
					c = e[13],
					u = e[2],
					h = e[6],
					f = e[10],
					m = e[14],
					g = e[3],
					y = e[7],
					d = e[11],
					p = e[15];
				return g * (+s * l * h - i * c * h - s * a * f + n * c * f + i * a * m - n * l * m) + y * (+t * l * m - t * c * f + s * o * f - i * o * m + i * c * u - s * l * u) + d * (+t * c * h - t * a * m - s * o * h + n * o * m + s * a * u - n * c * u) + p * (-i * a * u - t * l * h + t * a * f + i * o * h - n * o * f + n * l * u)
			}
			transpose() {
				let e = this.elements,
					t;
				return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
			}
			setPosition(e, t, n) {
				let i = this.elements;
				return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
			}
			invert() {
				let e = this.elements,
					t = e[0],
					n = e[1],
					i = e[2],
					s = e[3],
					o = e[4],
					a = e[5],
					l = e[6],
					c = e[7],
					u = e[8],
					h = e[9],
					f = e[10],
					m = e[11],
					g = e[12],
					y = e[13],
					d = e[14],
					p = e[15],
					_ = h * d * c - y * f * c + y * l * m - a * d * m - h * l * p + a * f * p,
					v = g * f * c - u * d * c - g * l * m + o * d * m + u * l * p - o * f * p,
					x = u * y * c - g * h * c + g * a * m - o * y * m - u * a * p + o * h * p,
					M = g * h * l - u * y * l - g * a * f + o * y * f + u * a * d - o * h * d,
					I = t * _ + n * v + i * x + s * M;
				if (I === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
				let w = 1 / I;
				return e[0] = _ * w, e[1] = (y * f * s - h * d * s - y * i * m + n * d * m + h * i * p - n * f * p) * w, e[2] = (a * d * s - y * l * s + y * i * c - n * d * c - a * i * p + n * l * p) * w, e[3] = (h * l * s - a * f * s - h * i * c + n * f * c + a * i * m - n * l * m) * w, e[4] = v * w, e[5] = (u * d * s - g * f * s + g * i * m - t * d * m - u * i * p + t * f * p) * w, e[6] = (g * l * s - o * d * s - g * i * c + t * d * c + o * i * p - t * l * p) * w, e[7] = (o * f * s - u * l * s + u * i * c - t * f * c - o * i * m + t * l * m) * w, e[8] = x * w, e[9] = (g * h * s - u * y * s - g * n * m + t * y * m + u * n * p - t * h * p) * w, e[10] = (o * y * s - g * a * s + g * n * c - t * y * c - o * n * p + t * a * p) * w, e[11] = (u * a * s - o * h * s - u * n * c + t * h * c + o * n * m - t * a * m) * w, e[12] = M * w, e[13] = (u * y * i - g * h * i + g * n * f - t * y * f - u * n * d + t * h * d) * w, e[14] = (g * a * i - o * y * i - g * n * l + t * y * l + o * n * d - t * a * d) * w, e[15] = (o * h * i - u * a * i + u * n * l - t * h * l - o * n * f + t * a * f) * w, this
			}
			scale(e) {
				let t = this.elements,
					n = e.x,
					i = e.y,
					s = e.z;
				return t[0] *= n, t[4] *= i, t[8] *= s, t[1] *= n, t[5] *= i, t[9] *= s, t[2] *= n, t[6] *= i, t[10] *= s, t[3] *= n, t[7] *= i, t[11] *= s, this
			}
			getMaxScaleOnAxis() {
				let e = this.elements,
					t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
					n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
					i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
				return Math.sqrt(Math.max(t, n, i))
			}
			makeTranslation(e, t, n) {
				return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
			}
			makeRotationX(e) {
				let t = Math.cos(e),
					n = Math.sin(e);
				return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
			}
			makeRotationY(e) {
				let t = Math.cos(e),
					n = Math.sin(e);
				return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
			}
			makeRotationZ(e) {
				let t = Math.cos(e),
					n = Math.sin(e);
				return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
			}
			makeRotationAxis(e, t) {
				let n = Math.cos(t),
					i = Math.sin(t),
					s = 1 - n,
					o = e.x,
					a = e.y,
					l = e.z,
					c = s * o,
					u = s * a;
				return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, u * a + n, u * l - i * o, 0, c * l - i * a, u * l + i * o, s * l * l + n, 0, 0, 0, 0, 1), this
			}
			makeScale(e, t, n) {
				return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
			}
			makeShear(e, t, n, i, s, o) {
				return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this
			}
			compose(e, t, n) {
				let i = this.elements,
					s = t._x,
					o = t._y,
					a = t._z,
					l = t._w,
					c = s + s,
					u = o + o,
					h = a + a,
					f = s * c,
					m = s * u,
					g = s * h,
					y = o * u,
					d = o * h,
					p = a * h,
					_ = l * c,
					v = l * u,
					x = l * h,
					M = n.x,
					I = n.y,
					w = n.z;
				return i[0] = (1 - (y + p)) * M, i[1] = (m + x) * M, i[2] = (g - v) * M, i[3] = 0, i[4] = (m - x) * I, i[5] = (1 - (f + p)) * I, i[6] = (d + _) * I, i[7] = 0, i[8] = (g + v) * w, i[9] = (d - _) * w, i[10] = (1 - (f + y)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
			}
			decompose(e, t, n) {
				let i = this.elements,
					s = Fo.set(i[0], i[1], i[2]).length(),
					o = Fo.set(i[4], i[5], i[6]).length(),
					a = Fo.set(i[8], i[9], i[10]).length();
				this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], Di.copy(this);
				let c = 1 / s,
					u = 1 / o,
					h = 1 / a;
				return Di.elements[0] *= c, Di.elements[1] *= c, Di.elements[2] *= c, Di.elements[4] *= u, Di.elements[5] *= u, Di.elements[6] *= u, Di.elements[8] *= h, Di.elements[9] *= h, Di.elements[10] *= h, t.setFromRotationMatrix(Di), n.x = s, n.y = o, n.z = a, this
			}
			makePerspective(e, t, n, i, s, o, a = Dr) {
				let l = this.elements,
					c = 2 * s / (t - e),
					u = 2 * s / (n - i),
					h = (t + e) / (t - e),
					f = (n + i) / (n - i),
					m, g;
				if (a === Dr) m = -(o + s) / (o - s), g = -2 * o * s / (o - s);
				else if (a === yu) m = -o / (o - s), g = -o * s / (o - s);
				else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
				return l[0] = c, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = u, l[9] = f, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = g, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
			}
			makeOrthographic(e, t, n, i, s, o, a = Dr) {
				let l = this.elements,
					c = 1 / (t - e),
					u = 1 / (n - i),
					h = 1 / (o - s),
					f = (t + e) * c,
					m = (n + i) * u,
					g, y;
				if (a === Dr) g = (o + s) * h, y = -2 * h;
				else if (a === yu) g = s * h, y = -1 * h;
				else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
				return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -f, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -m, l[2] = 0, l[6] = 0, l[10] = y, l[14] = -g, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
			}
			equals(e) {
				let t = this.elements,
					n = e.elements;
				for (let i = 0; i < 16; i++)
					if (t[i] !== n[i]) return !1;
				return !0
			}
			fromArray(e, t = 0) {
				for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
				return this
			}
			toArray(e = [], t = 0) {
				let n = this.elements;
				return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
			}
		},
		Fo = new re,
		Di = new Je,
		Tv = new re(0, 0, 0),
		Ev = new re(1, 1, 1),
		es = new re,
		Hc = new re,
		ci = new re,
		dm = new Je,
		pm = new yn,
		fi = class r {
			constructor(e = 0, t = 0, n = 0, i = r.DEFAULT_ORDER) {
				this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
			}
			get x() {
				return this._x
			}
			set x(e) {
				this._x = e, this._onChangeCallback()
			}
			get y() {
				return this._y
			}
			set y(e) {
				this._y = e, this._onChangeCallback()
			}
			get z() {
				return this._z
			}
			set z(e) {
				this._z = e, this._onChangeCallback()
			}
			get order() {
				return this._order
			}
			set order(e) {
				this._order = e, this._onChangeCallback()
			}
			set(e, t, n, i = this._order) {
				return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
			}
			clone() {
				return new this.constructor(this._x, this._y, this._z, this._order)
			}
			copy(e) {
				return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
			}
			setFromRotationMatrix(e, t = this._order, n = !0) {
				let i = e.elements,
					s = i[0],
					o = i[4],
					a = i[8],
					l = i[1],
					c = i[5],
					u = i[9],
					h = i[2],
					f = i[6],
					m = i[10];
				switch (t) {
					case "XYZ":
						this._y = Math.asin(Pn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, c), this._z = 0);
						break;
					case "YXZ":
						this._x = Math.asin(-Pn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
						break;
					case "ZXY":
						this._x = Math.asin(Pn(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, m), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
						break;
					case "ZYX":
						this._y = Math.asin(-Pn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
						break;
					case "YZX":
						this._z = Math.asin(Pn(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, m));
						break;
					case "XZY":
						this._z = Math.asin(-Pn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, m), this._y = 0);
						break;
					default:
						console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
				}
				return this._order = t, n === !0 && this._onChangeCallback(), this
			}
			setFromQuaternion(e, t, n) {
				return dm.makeRotationFromQuaternion(e), this.setFromRotationMatrix(dm, t, n)
			}
			setFromVector3(e, t = this._order) {
				return this.set(e.x, e.y, e.z, t)
			}
			reorder(e) {
				return pm.setFromEuler(this), this.setFromQuaternion(pm, e)
			}
			equals(e) {
				return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
			}
			fromArray(e) {
				return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
			}
			toArray(e = [], t = 0) {
				return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
			}
			_onChange(e) {
				return this._onChangeCallback = e, this
			}
			_onChangeCallback() {}*[Symbol.iterator]() {
				yield this._x, yield this._y, yield this._z, yield this._order
			}
		};
	fi.DEFAULT_ORDER = "XYZ";
	var Cl = class {
			constructor() {
				this.mask = 1
			}
			set(e) {
				this.mask = (1 << e | 0) >>> 0
			}
			enable(e) {
				this.mask |= 1 << e | 0
			}
			enableAll() {
				this.mask = -1
			}
			toggle(e) {
				this.mask ^= 1 << e | 0
			}
			disable(e) {
				this.mask &= ~(1 << e | 0)
			}
			disableAll() {
				this.mask = 0
			}
			test(e) {
				return (this.mask & e.mask) !== 0
			}
			isEnabled(e) {
				return (this.mask & (1 << e | 0)) !== 0
			}
		},
		Mv = 0,
		mm = new re,
		Uo = new yn,
		Cr = new Je,
		Wc = new re,
		ml = new re,
		bv = new re,
		Sv = new yn,
		gm = new re(1, 0, 0),
		ym = new re(0, 1, 0),
		vm = new re(0, 0, 1),
		Av = {
			type: "added"
		},
		xm = {
			type: "removed"
		},
		Rt = class r extends os {
			constructor() {
				super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
					value: Mv++
				}), this.uuid = Gr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = r.DEFAULT_UP.clone();
				let e = new re,
					t = new fi,
					n = new yn,
					i = new re(1, 1, 1);

				function s() {
					n.setFromEuler(t, !1)
				}

				function o() {
					t.setFromQuaternion(n, void 0, !1)
				}
				t._onChange(s), n._onChange(o), Object.defineProperties(this, {
					position: {
						configurable: !0,
						enumerable: !0,
						value: e
					},
					rotation: {
						configurable: !0,
						enumerable: !0,
						value: t
					},
					quaternion: {
						configurable: !0,
						enumerable: !0,
						value: n
					},
					scale: {
						configurable: !0,
						enumerable: !0,
						value: i
					},
					modelViewMatrix: {
						value: new Je
					},
					normalMatrix: {
						value: new pt
					}
				}), this.matrix = new Je, this.matrixWorld = new Je, this.matrixAutoUpdate = r.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = r.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Cl, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
			}
			onBeforeRender() {}
			onAfterRender() {}
			applyMatrix4(e) {
				this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
			}
			applyQuaternion(e) {
				return this.quaternion.premultiply(e), this
			}
			setRotationFromAxisAngle(e, t) {
				this.quaternion.setFromAxisAngle(e, t)
			}
			setRotationFromEuler(e) {
				this.quaternion.setFromEuler(e, !0)
			}
			setRotationFromMatrix(e) {
				this.quaternion.setFromRotationMatrix(e)
			}
			setRotationFromQuaternion(e) {
				this.quaternion.copy(e)
			}
			rotateOnAxis(e, t) {
				return Uo.setFromAxisAngle(e, t), this.quaternion.multiply(Uo), this
			}
			rotateOnWorldAxis(e, t) {
				return Uo.setFromAxisAngle(e, t), this.quaternion.premultiply(Uo), this
			}
			rotateX(e) {
				return this.rotateOnAxis(gm, e)
			}
			rotateY(e) {
				return this.rotateOnAxis(ym, e)
			}
			rotateZ(e) {
				return this.rotateOnAxis(vm, e)
			}
			translateOnAxis(e, t) {
				return mm.copy(e).applyQuaternion(this.quaternion), this.position.add(mm.multiplyScalar(t)), this
			}
			translateX(e) {
				return this.translateOnAxis(gm, e)
			}
			translateY(e) {
				return this.translateOnAxis(ym, e)
			}
			translateZ(e) {
				return this.translateOnAxis(vm, e)
			}
			localToWorld(e) {
				return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
			}
			worldToLocal(e) {
				return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Cr.copy(this.matrixWorld).invert())
			}
			lookAt(e, t, n) {
				e.isVector3 ? Wc.copy(e) : Wc.set(e, t, n);
				let i = this.parent;
				this.updateWorldMatrix(!0, !1), ml.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Cr.lookAt(ml, Wc, this.up) : Cr.lookAt(Wc, ml, this.up), this.quaternion.setFromRotationMatrix(Cr), i && (Cr.extractRotation(i.matrixWorld), Uo.setFromRotationMatrix(Cr), this.quaternion.premultiply(Uo.invert()))
			}
			add(e) {
				if (arguments.length > 1) {
					for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
					return this
				}
				return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Av)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
			}
			remove(e) {
				if (arguments.length > 1) {
					for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
					return this
				}
				let t = this.children.indexOf(e);
				return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(xm)), this
			}
			removeFromParent() {
				let e = this.parent;
				return e !== null && e.remove(this), this
			}
			clear() {
				for (let e = 0; e < this.children.length; e++) {
					let t = this.children[e];
					t.parent = null, t.dispatchEvent(xm)
				}
				return this.children.length = 0, this
			}
			attach(e) {
				return this.updateWorldMatrix(!0, !1), Cr.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Cr.multiply(e.parent.matrixWorld)), e.applyMatrix4(Cr), this.add(e), e.updateWorldMatrix(!1, !0), this
			}
			getObjectById(e) {
				return this.getObjectByProperty("id", e)
			}
			getObjectByName(e) {
				return this.getObjectByProperty("name", e)
			}
			getObjectByProperty(e, t) {
				if (this[e] === t) return this;
				for (let n = 0, i = this.children.length; n < i; n++) {
					let o = this.children[n].getObjectByProperty(e, t);
					if (o !== void 0) return o
				}
			}
			getObjectsByProperty(e, t) {
				let n = [];
				this[e] === t && n.push(this);
				for (let i = 0, s = this.children.length; i < s; i++) {
					let o = this.children[i].getObjectsByProperty(e, t);
					o.length > 0 && (n = n.concat(o))
				}
				return n
			}
			getWorldPosition(e) {
				return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
			}
			getWorldQuaternion(e) {
				return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ml, e, bv), e
			}
			getWorldScale(e) {
				return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ml, Sv, e), e
			}
			getWorldDirection(e) {
				this.updateWorldMatrix(!0, !1);
				let t = this.matrixWorld.elements;
				return e.set(t[8], t[9], t[10]).normalize()
			}
			raycast() {}
			traverse(e) {
				e(this);
				let t = this.children;
				for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
			}
			traverseVisible(e) {
				if (this.visible === !1) return;
				e(this);
				let t = this.children;
				for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
			}
			traverseAncestors(e) {
				let t = this.parent;
				t !== null && (e(t), t.traverseAncestors(e))
			}
			updateMatrix() {
				this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
			}
			updateMatrixWorld(e) {
				this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
				let t = this.children;
				for (let n = 0, i = t.length; n < i; n++) {
					let s = t[n];
					(s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
				}
			}
			updateWorldMatrix(e, t) {
				let n = this.parent;
				if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
					let i = this.children;
					for (let s = 0, o = i.length; s < o; s++) {
						let a = i[s];
						a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
					}
				}
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string",
					n = {};
				t && (e = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				}, n.metadata = {
					version: 4.6,
					type: "Object",
					generator: "Object3D.toJSON"
				});
				let i = {};
				i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));

				function s(a, l) {
					return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
				}
				if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
				else if (this.isMesh || this.isLine || this.isPoints) {
					i.geometry = s(e.geometries, this.geometry);
					let a = this.geometry.parameters;
					if (a !== void 0 && a.shapes !== void 0) {
						let l = a.shapes;
						if (Array.isArray(l))
							for (let c = 0, u = l.length; c < u; c++) {
								let h = l[c];
								s(e.shapes, h)
							} else s(e.shapes, l)
					}
				}
				if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
					if (Array.isArray(this.material)) {
						let a = [];
						for (let l = 0, c = this.material.length; l < c; l++) a.push(s(e.materials, this.material[l]));
						i.material = a
					} else i.material = s(e.materials, this.material);
				if (this.children.length > 0) {
					i.children = [];
					for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e).object)
				}
				if (this.animations.length > 0) {
					i.animations = [];
					for (let a = 0; a < this.animations.length; a++) {
						let l = this.animations[a];
						i.animations.push(s(e.animations, l))
					}
				}
				if (t) {
					let a = o(e.geometries),
						l = o(e.materials),
						c = o(e.textures),
						u = o(e.images),
						h = o(e.shapes),
						f = o(e.skeletons),
						m = o(e.animations),
						g = o(e.nodes);
					a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), h.length > 0 && (n.shapes = h), f.length > 0 && (n.skeletons = f), m.length > 0 && (n.animations = m), g.length > 0 && (n.nodes = g)
				}
				return n.object = i, n;

				function o(a) {
					let l = [];
					for (let c in a) {
						let u = a[c];
						delete u.metadata, l.push(u)
					}
					return l
				}
			}
			clone(e) {
				return new this.constructor().copy(this, e)
			}
			copy(e, t = !0) {
				if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
					for (let n = 0; n < e.children.length; n++) {
						let i = e.children[n];
						this.add(i.clone())
					}
				return this
			}
		};
	Rt.DEFAULT_UP = new re(0, 1, 0);
	Rt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
	Rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
	var Fi = new re,
		Rr = new re,
		Xh = new re,
		Ir = new re,
		ko = new re,
		Bo = new re,
		_m = new re,
		qh = new re,
		jh = new re,
		Yh = new re,
		Xc = !1,
		ks = class r {
			constructor(e = new re, t = new re, n = new re) {
				this.a = e, this.b = t, this.c = n
			}
			static getNormal(e, t, n, i) {
				i.subVectors(n, t), Fi.subVectors(e, t), i.cross(Fi);
				let s = i.lengthSq();
				return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
			}
			static getBarycoord(e, t, n, i, s) {
				Fi.subVectors(i, t), Rr.subVectors(n, t), Xh.subVectors(e, t);
				let o = Fi.dot(Fi),
					a = Fi.dot(Rr),
					l = Fi.dot(Xh),
					c = Rr.dot(Rr),
					u = Rr.dot(Xh),
					h = o * c - a * a;
				if (h === 0) return s.set(-2, -1, -1);
				let f = 1 / h,
					m = (c * l - a * u) * f,
					g = (o * u - a * l) * f;
				return s.set(1 - m - g, g, m)
			}
			static containsPoint(e, t, n, i) {
				return this.getBarycoord(e, t, n, i, Ir), Ir.x >= 0 && Ir.y >= 0 && Ir.x + Ir.y <= 1
			}
			static getUV(e, t, n, i, s, o, a, l) {
				return Xc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Xc = !0), this.getInterpolation(e, t, n, i, s, o, a, l)
			}
			static getInterpolation(e, t, n, i, s, o, a, l) {
				return this.getBarycoord(e, t, n, i, Ir), l.setScalar(0), l.addScaledVector(s, Ir.x), l.addScaledVector(o, Ir.y), l.addScaledVector(a, Ir.z), l
			}
			static isFrontFacing(e, t, n, i) {
				return Fi.subVectors(n, t), Rr.subVectors(e, t), Fi.cross(Rr).dot(i) < 0
			}
			set(e, t, n) {
				return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
			}
			setFromPointsAndIndices(e, t, n, i) {
				return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
			}
			setFromAttributeAndIndices(e, t, n, i) {
				return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
			}
			getArea() {
				return Fi.subVectors(this.c, this.b), Rr.subVectors(this.a, this.b), Fi.cross(Rr).length() * .5
			}
			getMidpoint(e) {
				return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
			}
			getNormal(e) {
				return r.getNormal(this.a, this.b, this.c, e)
			}
			getPlane(e) {
				return e.setFromCoplanarPoints(this.a, this.b, this.c)
			}
			getBarycoord(e, t) {
				return r.getBarycoord(e, this.a, this.b, this.c, t)
			}
			getUV(e, t, n, i, s) {
				return Xc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Xc = !0), r.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
			}
			getInterpolation(e, t, n, i, s) {
				return r.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
			}
			containsPoint(e) {
				return r.containsPoint(e, this.a, this.b, this.c)
			}
			isFrontFacing(e) {
				return r.isFrontFacing(this.a, this.b, this.c, e)
			}
			intersectsBox(e) {
				return e.intersectsTriangle(this)
			}
			closestPointToPoint(e, t) {
				let n = this.a,
					i = this.b,
					s = this.c,
					o, a;
				ko.subVectors(i, n), Bo.subVectors(s, n), qh.subVectors(e, n);
				let l = ko.dot(qh),
					c = Bo.dot(qh);
				if (l <= 0 && c <= 0) return t.copy(n);
				jh.subVectors(e, i);
				let u = ko.dot(jh),
					h = Bo.dot(jh);
				if (u >= 0 && h <= u) return t.copy(i);
				let f = l * h - u * c;
				if (f <= 0 && l >= 0 && u <= 0) return o = l / (l - u), t.copy(n).addScaledVector(ko, o);
				Yh.subVectors(e, s);
				let m = ko.dot(Yh),
					g = Bo.dot(Yh);
				if (g >= 0 && m <= g) return t.copy(s);
				let y = m * c - l * g;
				if (y <= 0 && c >= 0 && g <= 0) return a = c / (c - g), t.copy(n).addScaledVector(Bo, a);
				let d = u * g - m * h;
				if (d <= 0 && h - u >= 0 && m - g >= 0) return _m.subVectors(s, i), a = (h - u) / (h - u + (m - g)), t.copy(i).addScaledVector(_m, a);
				let p = 1 / (d + y + f);
				return o = y * p, a = f * p, t.copy(n).addScaledVector(ko, o).addScaledVector(Bo, a)
			}
			equals(e) {
				return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
			}
		},
		wv = 0,
		Vi = class extends os {
			constructor() {
				super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
					value: wv++
				}), this.uuid = Gr(), this.name = "", this.type = "Material", this.blending = Jo, this.side = _i, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = yg, this.blendDst = vg, this.blendEquation = Yo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = ff, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Wy, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Dh, this.stencilZFail = Dh, this.stencilZPass = Dh, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
			}
			get alphaTest() {
				return this._alphaTest
			}
			set alphaTest(e) {
				this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
			}
			onBuild() {}
			onBeforeRender() {}
			onBeforeCompile() {}
			customProgramCacheKey() {
				return this.onBeforeCompile.toString()
			}
			setValues(e) {
				if (e !== void 0)
					for (let t in e) {
						let n = e[t];
						if (n === void 0) {
							console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
							continue
						}
						let i = this[t];
						if (i === void 0) {
							console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
							continue
						}
						i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
					}
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string";
				t && (e = {
					textures: {},
					images: {}
				});
				let n = {
					metadata: {
						version: 4.6,
						type: "Material",
						generator: "Material.toJSON"
					}
				};
				n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Jo && (n.blending = this.blending), this.side !== _i && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = this.alphaHash), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);

				function i(s) {
					let o = [];
					for (let a in s) {
						let l = s[a];
						delete l.metadata, o.push(l)
					}
					return o
				}
				if (t) {
					let s = i(e.textures),
						o = i(e.images);
					s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o)
				}
				return n
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
				let t = e.clippingPlanes,
					n = null;
				if (t !== null) {
					let i = t.length;
					n = new Array(i);
					for (let s = 0; s !== i; ++s) n[s] = t[s].clone()
				}
				return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
			set needsUpdate(e) {
				e === !0 && this.version++
			}
		},
		Ig = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			rebeccapurple: 6697881,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074
		},
		Ui = {
			h: 0,
			s: 0,
			l: 0
		},
		qc = {
			h: 0,
			s: 0,
			l: 0
		};

	function Kh(r, e, t) {
		return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
	}
	var qe = class {
			constructor(e, t, n) {
				return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
			}
			set(e, t, n) {
				if (t === void 0 && n === void 0) {
					let i = e;
					i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
				} else this.setRGB(e, t, n);
				return this
			}
			setScalar(e) {
				return this.r = e, this.g = e, this.b = e, this
			}
			setHex(e, t = ot) {
				return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, hi.toWorkingColorSpace(this, t), this
			}
			setRGB(e, t, n, i = hi.workingColorSpace) {
				return this.r = e, this.g = t, this.b = n, hi.toWorkingColorSpace(this, i), this
			}
			setHSL(e, t, n, i = hi.workingColorSpace) {
				if (e = $f(e, 1), t = Pn(t, 0, 1), n = Pn(n, 0, 1), t === 0) this.r = this.g = this.b = n;
				else {
					let s = n <= .5 ? n * (1 + t) : n + t - n * t,
						o = 2 * n - s;
					this.r = Kh(o, s, e + 1 / 3), this.g = Kh(o, s, e), this.b = Kh(o, s, e - 1 / 3)
				}
				return hi.toWorkingColorSpace(this, i), this
			}
			setStyle(e, t = ot) {
				function n(s) {
					s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
				}
				let i;
				if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
					let s, o = i[1],
						a = i[2];
					switch (o) {
						case "rgb":
						case "rgba":
							if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
							if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
							break;
						case "hsl":
						case "hsla":
							if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
							break;
						default:
							console.warn("THREE.Color: Unknown color model " + e)
					}
				} else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
					let s = i[1],
						o = s.length;
					if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
					if (o === 6) return this.setHex(parseInt(s, 16), t);
					console.warn("THREE.Color: Invalid hex color " + e)
				} else if (e && e.length > 0) return this.setColorName(e, t);
				return this
			}
			setColorName(e, t = ot) {
				let n = Ig[e.toLowerCase()];
				return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
			}
			clone() {
				return new this.constructor(this.r, this.g, this.b)
			}
			copy(e) {
				return this.r = e.r, this.g = e.g, this.b = e.b, this
			}
			copySRGBToLinear(e) {
				return this.r = Qo(e.r), this.g = Qo(e.g), this.b = Qo(e.b), this
			}
			copyLinearToSRGB(e) {
				return this.r = Uh(e.r), this.g = Uh(e.g), this.b = Uh(e.b), this
			}
			convertSRGBToLinear() {
				return this.copySRGBToLinear(this), this
			}
			convertLinearToSRGB() {
				return this.copyLinearToSRGB(this), this
			}
			getHex(e = ot) {
				return hi.fromWorkingColorSpace(kn.copy(this), e), Math.round(Pn(kn.r * 255, 0, 255)) * 65536 + Math.round(Pn(kn.g * 255, 0, 255)) * 256 + Math.round(Pn(kn.b * 255, 0, 255))
			}
			getHexString(e = ot) {
				return ("000000" + this.getHex(e).toString(16)).slice(-6)
			}
			getHSL(e, t = hi.workingColorSpace) {
				hi.fromWorkingColorSpace(kn.copy(this), t);
				let n = kn.r,
					i = kn.g,
					s = kn.b,
					o = Math.max(n, i, s),
					a = Math.min(n, i, s),
					l, c, u = (a + o) / 2;
				if (a === o) l = 0, c = 0;
				else {
					let h = o - a;
					switch (c = u <= .5 ? h / (o + a) : h / (2 - o - a), o) {
						case n:
							l = (i - s) / h + (i < s ? 6 : 0);
							break;
						case i:
							l = (s - n) / h + 2;
							break;
						case s:
							l = (n - i) / h + 4;
							break
					}
					l /= 6
				}
				return e.h = l, e.s = c, e.l = u, e
			}
			getRGB(e, t = hi.workingColorSpace) {
				return hi.fromWorkingColorSpace(kn.copy(this), t), e.r = kn.r, e.g = kn.g, e.b = kn.b, e
			}
			getStyle(e = ot) {
				hi.fromWorkingColorSpace(kn.copy(this), e);
				let t = kn.r,
					n = kn.g,
					i = kn.b;
				return e !== ot ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`
			}
			offsetHSL(e, t, n) {
				return this.getHSL(Ui), Ui.h += e, Ui.s += t, Ui.l += n, this.setHSL(Ui.h, Ui.s, Ui.l), this
			}
			add(e) {
				return this.r += e.r, this.g += e.g, this.b += e.b, this
			}
			addColors(e, t) {
				return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
			}
			addScalar(e) {
				return this.r += e, this.g += e, this.b += e, this
			}
			sub(e) {
				return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
			}
			multiply(e) {
				return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
			}
			multiplyScalar(e) {
				return this.r *= e, this.g *= e, this.b *= e, this
			}
			lerp(e, t) {
				return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
			}
			lerpColors(e, t, n) {
				return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
			}
			lerpHSL(e, t) {
				this.getHSL(Ui), e.getHSL(qc);
				let n = _l(Ui.h, qc.h, t),
					i = _l(Ui.s, qc.s, t),
					s = _l(Ui.l, qc.l, t);
				return this.setHSL(n, i, s), this
			}
			setFromVector3(e) {
				return this.r = e.x, this.g = e.y, this.b = e.z, this
			}
			applyMatrix3(e) {
				let t = this.r,
					n = this.g,
					i = this.b,
					s = e.elements;
				return this.r = s[0] * t + s[3] * n + s[6] * i, this.g = s[1] * t + s[4] * n + s[7] * i, this.b = s[2] * t + s[5] * n + s[8] * i, this
			}
			equals(e) {
				return e.r === this.r && e.g === this.g && e.b === this.b
			}
			fromArray(e, t = 0) {
				return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
			}
			toArray(e = [], t = 0) {
				return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
			}
			fromBufferAttribute(e, t) {
				return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
			}
			toJSON() {
				return this.getHex()
			}*[Symbol.iterator]() {
				yield this.r, yield this.g, yield this.b
			}
		},
		kn = new qe;
	qe.NAMES = Ig;
	var Ti = class extends Vi {
		constructor(e) {
			super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ku, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
		}
	};
	var dn = new re,
		jc = new Ce,
		Ln = class {
			constructor(e, t, n = !1) {
				if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
				this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = lm, this.updateRange = {
					offset: 0,
					count: -1
				}, this.gpuType = Or, this.version = 0
			}
			onUploadCallback() {}
			set needsUpdate(e) {
				e === !0 && this.version++
			}
			setUsage(e) {
				return this.usage = e, this
			}
			copy(e) {
				return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
			}
			copyAt(e, t, n) {
				e *= this.itemSize, n *= t.itemSize;
				for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = t.array[n + i];
				return this
			}
			copyArray(e) {
				return this.array.set(e), this
			}
			applyMatrix3(e) {
				if (this.itemSize === 2)
					for (let t = 0, n = this.count; t < n; t++) jc.fromBufferAttribute(this, t), jc.applyMatrix3(e), this.setXY(t, jc.x, jc.y);
				else if (this.itemSize === 3)
					for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.applyMatrix3(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			applyMatrix4(e) {
				for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.applyMatrix4(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			applyNormalMatrix(e) {
				for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.applyNormalMatrix(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			transformDirection(e) {
				for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.transformDirection(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			set(e, t = 0) {
				return this.array.set(e, t), this
			}
			getX(e) {
				let t = this.array[e * this.itemSize];
				return this.normalized && (t = vl(t, this.array)), t
			}
			setX(e, t) {
				return this.normalized && (t = Qn(t, this.array)), this.array[e * this.itemSize] = t, this
			}
			getY(e) {
				let t = this.array[e * this.itemSize + 1];
				return this.normalized && (t = vl(t, this.array)), t
			}
			setY(e, t) {
				return this.normalized && (t = Qn(t, this.array)), this.array[e * this.itemSize + 1] = t, this
			}
			getZ(e) {
				let t = this.array[e * this.itemSize + 2];
				return this.normalized && (t = vl(t, this.array)), t
			}
			setZ(e, t) {
				return this.normalized && (t = Qn(t, this.array)), this.array[e * this.itemSize + 2] = t, this
			}
			getW(e) {
				let t = this.array[e * this.itemSize + 3];
				return this.normalized && (t = vl(t, this.array)), t
			}
			setW(e, t) {
				return this.normalized && (t = Qn(t, this.array)), this.array[e * this.itemSize + 3] = t, this
			}
			setXY(e, t, n) {
				return e *= this.itemSize, this.normalized && (t = Qn(t, this.array), n = Qn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
			}
			setXYZ(e, t, n, i) {
				return e *= this.itemSize, this.normalized && (t = Qn(t, this.array), n = Qn(n, this.array), i = Qn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
			}
			setXYZW(e, t, n, i, s) {
				return e *= this.itemSize, this.normalized && (t = Qn(t, this.array), n = Qn(n, this.array), i = Qn(i, this.array), s = Qn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = s, this
			}
			onUpload(e) {
				return this.onUploadCallback = e, this
			}
			clone() {
				return new this.constructor(this.array, this.itemSize).copy(this)
			}
			toJSON() {
				let e = {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: Array.from(this.array),
					normalized: this.normalized
				};
				return this.name !== "" && (e.name = this.name), this.usage !== lm && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e
			}
		};
	var oa = class extends Ln {
		constructor(e, t, n) {
			super(new Uint16Array(e), t, n)
		}
	};
	var Tu = class extends Ln {
		constructor(e, t, n) {
			super(new Uint32Array(e), t, n)
		}
	};
	var ze = class extends Ln {
		constructor(e, t, n) {
			super(new Float32Array(e), t, n)
		}
	};
	var Cv = 0,
		vi = new Je,
		Zh = new Rt,
		Go = new re,
		ui = new Bi,
		gl = new Bi,
		An = new re,
		St = class r extends os {
			constructor() {
				super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
					value: Cv++
				}), this.uuid = Gr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
					start: 0,
					count: 1 / 0
				}, this.userData = {}
			}
			getIndex() {
				return this.index
			}
			setIndex(e) {
				return Array.isArray(e) ? this.index = new(Rg(e) ? Tu : oa)(e, 1) : this.index = e, this
			}
			getAttribute(e) {
				return this.attributes[e]
			}
			setAttribute(e, t) {
				return this.attributes[e] = t, this
			}
			deleteAttribute(e) {
				return delete this.attributes[e], this
			}
			hasAttribute(e) {
				return this.attributes[e] !== void 0
			}
			addGroup(e, t, n = 0) {
				this.groups.push({
					start: e,
					count: t,
					materialIndex: n
				})
			}
			clearGroups() {
				this.groups = []
			}
			setDrawRange(e, t) {
				this.drawRange.start = e, this.drawRange.count = t
			}
			applyMatrix4(e) {
				let t = this.attributes.position;
				t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
				let n = this.attributes.normal;
				if (n !== void 0) {
					let s = new pt().getNormalMatrix(e);
					n.applyNormalMatrix(s), n.needsUpdate = !0
				}
				let i = this.attributes.tangent;
				return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
			}
			applyQuaternion(e) {
				return vi.makeRotationFromQuaternion(e), this.applyMatrix4(vi), this
			}
			rotateX(e) {
				return vi.makeRotationX(e), this.applyMatrix4(vi), this
			}
			rotateY(e) {
				return vi.makeRotationY(e), this.applyMatrix4(vi), this
			}
			rotateZ(e) {
				return vi.makeRotationZ(e), this.applyMatrix4(vi), this
			}
			translate(e, t, n) {
				return vi.makeTranslation(e, t, n), this.applyMatrix4(vi), this
			}
			scale(e, t, n) {
				return vi.makeScale(e, t, n), this.applyMatrix4(vi), this
			}
			lookAt(e) {
				return Zh.lookAt(e), Zh.updateMatrix(), this.applyMatrix4(Zh.matrix), this
			}
			center() {
				return this.computeBoundingBox(), this.boundingBox.getCenter(Go).negate(), this.translate(Go.x, Go.y, Go.z), this
			}
			setFromPoints(e) {
				let t = [];
				for (let n = 0, i = e.length; n < i; n++) {
					let s = e[n];
					t.push(s.x, s.y, s.z || 0)
				}
				return this.setAttribute("position", new ze(t, 3)), this
			}
			computeBoundingBox() {
				this.boundingBox === null && (this.boundingBox = new Bi);
				let e = this.attributes.position,
					t = this.morphAttributes.position;
				if (e && e.isGLBufferAttribute) {
					console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new re(-1 / 0, -1 / 0, -1 / 0), new re(1 / 0, 1 / 0, 1 / 0));
					return
				}
				if (e !== void 0) {
					if (this.boundingBox.setFromBufferAttribute(e), t)
						for (let n = 0, i = t.length; n < i; n++) {
							let s = t[n];
							ui.setFromBufferAttribute(s), this.morphTargetsRelative ? (An.addVectors(this.boundingBox.min, ui.min), this.boundingBox.expandByPoint(An), An.addVectors(this.boundingBox.max, ui.max), this.boundingBox.expandByPoint(An)) : (this.boundingBox.expandByPoint(ui.min), this.boundingBox.expandByPoint(ui.max))
						}
				} else this.boundingBox.makeEmpty();
				(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
			}
			computeBoundingSphere() {
				this.boundingSphere === null && (this.boundingSphere = new Gi);
				let e = this.attributes.position,
					t = this.morphAttributes.position;
				if (e && e.isGLBufferAttribute) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new re, 1 / 0);
					return
				}
				if (e) {
					let n = this.boundingSphere.center;
					if (ui.setFromBufferAttribute(e), t)
						for (let s = 0, o = t.length; s < o; s++) {
							let a = t[s];
							gl.setFromBufferAttribute(a), this.morphTargetsRelative ? (An.addVectors(ui.min, gl.min), ui.expandByPoint(An), An.addVectors(ui.max, gl.max), ui.expandByPoint(An)) : (ui.expandByPoint(gl.min), ui.expandByPoint(gl.max))
						}
					ui.getCenter(n);
					let i = 0;
					for (let s = 0, o = e.count; s < o; s++) An.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(An));
					if (t)
						for (let s = 0, o = t.length; s < o; s++) {
							let a = t[s],
								l = this.morphTargetsRelative;
							for (let c = 0, u = a.count; c < u; c++) An.fromBufferAttribute(a, c), l && (Go.fromBufferAttribute(e, c), An.add(Go)), i = Math.max(i, n.distanceToSquared(An))
						}
					this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
				}
			}
			computeTangents() {
				let e = this.index,
					t = this.attributes;
				if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
					console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
					return
				}
				let n = e.array,
					i = t.position.array,
					s = t.normal.array,
					o = t.uv.array,
					a = i.length / 3;
				this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ln(new Float32Array(4 * a), 4));
				let l = this.getAttribute("tangent").array,
					c = [],
					u = [];
				for (let C = 0; C < a; C++) c[C] = new re, u[C] = new re;
				let h = new re,
					f = new re,
					m = new re,
					g = new Ce,
					y = new Ce,
					d = new Ce,
					p = new re,
					_ = new re;

				function v(C, V, k) {
					h.fromArray(i, C * 3), f.fromArray(i, V * 3), m.fromArray(i, k * 3), g.fromArray(o, C * 2), y.fromArray(o, V * 2), d.fromArray(o, k * 2), f.sub(h), m.sub(h), y.sub(g), d.sub(g);
					let F = 1 / (y.x * d.y - d.x * y.y);
					isFinite(F) && (p.copy(f).multiplyScalar(d.y).addScaledVector(m, -y.y).multiplyScalar(F), _.copy(m).multiplyScalar(y.x).addScaledVector(f, -d.x).multiplyScalar(F), c[C].add(p), c[V].add(p), c[k].add(p), u[C].add(_), u[V].add(_), u[k].add(_))
				}
				let x = this.groups;
				x.length === 0 && (x = [{
					start: 0,
					count: n.length
				}]);
				for (let C = 0, V = x.length; C < V; ++C) {
					let k = x[C],
						F = k.start,
						U = k.count;
					for (let K = F, Z = F + U; K < Z; K += 3) v(n[K + 0], n[K + 1], n[K + 2])
				}
				let M = new re,
					I = new re,
					w = new re,
					L = new re;

				function T(C) {
					w.fromArray(s, C * 3), L.copy(w);
					let V = c[C];
					M.copy(V), M.sub(w.multiplyScalar(w.dot(V))).normalize(), I.crossVectors(L, V);
					let F = I.dot(u[C]) < 0 ? -1 : 1;
					l[C * 4] = M.x, l[C * 4 + 1] = M.y, l[C * 4 + 2] = M.z, l[C * 4 + 3] = F
				}
				for (let C = 0, V = x.length; C < V; ++C) {
					let k = x[C],
						F = k.start,
						U = k.count;
					for (let K = F, Z = F + U; K < Z; K += 3) T(n[K + 0]), T(n[K + 1]), T(n[K + 2])
				}
			}
			computeVertexNormals() {
				let e = this.index,
					t = this.getAttribute("position");
				if (t !== void 0) {
					let n = this.getAttribute("normal");
					if (n === void 0) n = new Ln(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
					else
						for (let f = 0, m = n.count; f < m; f++) n.setXYZ(f, 0, 0, 0);
					let i = new re,
						s = new re,
						o = new re,
						a = new re,
						l = new re,
						c = new re,
						u = new re,
						h = new re;
					if (e)
						for (let f = 0, m = e.count; f < m; f += 3) {
							let g = e.getX(f + 0),
								y = e.getX(f + 1),
								d = e.getX(f + 2);
							i.fromBufferAttribute(t, g), s.fromBufferAttribute(t, y), o.fromBufferAttribute(t, d), u.subVectors(o, s), h.subVectors(i, s), u.cross(h), a.fromBufferAttribute(n, g), l.fromBufferAttribute(n, y), c.fromBufferAttribute(n, d), a.add(u), l.add(u), c.add(u), n.setXYZ(g, a.x, a.y, a.z), n.setXYZ(y, l.x, l.y, l.z), n.setXYZ(d, c.x, c.y, c.z)
						} else
							for (let f = 0, m = t.count; f < m; f += 3) i.fromBufferAttribute(t, f + 0), s.fromBufferAttribute(t, f + 1), o.fromBufferAttribute(t, f + 2), u.subVectors(o, s), h.subVectors(i, s), u.cross(h), n.setXYZ(f + 0, u.x, u.y, u.z), n.setXYZ(f + 1, u.x, u.y, u.z), n.setXYZ(f + 2, u.x, u.y, u.z);
					this.normalizeNormals(), n.needsUpdate = !0
				}
			}
			normalizeNormals() {
				let e = this.attributes.normal;
				for (let t = 0, n = e.count; t < n; t++) An.fromBufferAttribute(e, t), An.normalize(), e.setXYZ(t, An.x, An.y, An.z)
			}
			toNonIndexed() {
				function e(a, l) {
					let c = a.array,
						u = a.itemSize,
						h = a.normalized,
						f = new c.constructor(l.length * u),
						m = 0,
						g = 0;
					for (let y = 0, d = l.length; y < d; y++) {
						a.isInterleavedBufferAttribute ? m = l[y] * a.data.stride + a.offset : m = l[y] * u;
						for (let p = 0; p < u; p++) f[g++] = c[m++]
					}
					return new Ln(f, u, h)
				}
				if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
				let t = new r,
					n = this.index.array,
					i = this.attributes;
				for (let a in i) {
					let l = i[a],
						c = e(l, n);
					t.setAttribute(a, c)
				}
				let s = this.morphAttributes;
				for (let a in s) {
					let l = [],
						c = s[a];
					for (let u = 0, h = c.length; u < h; u++) {
						let f = c[u],
							m = e(f, n);
						l.push(m)
					}
					t.morphAttributes[a] = l
				}
				t.morphTargetsRelative = this.morphTargetsRelative;
				let o = this.groups;
				for (let a = 0, l = o.length; a < l; a++) {
					let c = o[a];
					t.addGroup(c.start, c.count, c.materialIndex)
				}
				return t
			}
			toJSON() {
				let e = {
					metadata: {
						version: 4.6,
						type: "BufferGeometry",
						generator: "BufferGeometry.toJSON"
					}
				};
				if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
					let l = this.parameters;
					for (let c in l) l[c] !== void 0 && (e[c] = l[c]);
					return e
				}
				e.data = {
					attributes: {}
				};
				let t = this.index;
				t !== null && (e.data.index = {
					type: t.array.constructor.name,
					array: Array.prototype.slice.call(t.array)
				});
				let n = this.attributes;
				for (let l in n) {
					let c = n[l];
					e.data.attributes[l] = c.toJSON(e.data)
				}
				let i = {},
					s = !1;
				for (let l in this.morphAttributes) {
					let c = this.morphAttributes[l],
						u = [];
					for (let h = 0, f = c.length; h < f; h++) {
						let m = c[h];
						u.push(m.toJSON(e.data))
					}
					u.length > 0 && (i[l] = u, s = !0)
				}
				s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
				let o = this.groups;
				o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
				let a = this.boundingSphere;
				return a !== null && (e.data.boundingSphere = {
					center: a.center.toArray(),
					radius: a.radius
				}), e
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
				let t = {};
				this.name = e.name;
				let n = e.index;
				n !== null && this.setIndex(n.clone(t));
				let i = e.attributes;
				for (let c in i) {
					let u = i[c];
					this.setAttribute(c, u.clone(t))
				}
				let s = e.morphAttributes;
				for (let c in s) {
					let u = [],
						h = s[c];
					for (let f = 0, m = h.length; f < m; f++) u.push(h[f].clone(t));
					this.morphAttributes[c] = u
				}
				this.morphTargetsRelative = e.morphTargetsRelative;
				let o = e.groups;
				for (let c = 0, u = o.length; c < u; c++) {
					let h = o[c];
					this.addGroup(h.start, h.count, h.materialIndex)
				}
				let a = e.boundingBox;
				a !== null && (this.boundingBox = a.clone());
				let l = e.boundingSphere;
				return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
		},
		Tm = new Je,
		Os = new Ws,
		Yc = new Gi,
		Em = new re,
		Vo = new re,
		zo = new re,
		Ho = new re,
		Jh = new re,
		Kc = new re,
		Zc = new Ce,
		Jc = new Ce,
		$c = new Ce,
		Mm = new re,
		bm = new re,
		Sm = new re,
		Qc = new re,
		eu = new re,
		Nt = class extends Rt {
			constructor(e = new St, t = new Ti) {
				super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
			}
			copy(e, t) {
				return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
			}
			updateMorphTargets() {
				let t = this.geometry.morphAttributes,
					n = Object.keys(t);
				if (n.length > 0) {
					let i = t[n[0]];
					if (i !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, o = i.length; s < o; s++) {
							let a = i[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
						}
					}
				}
			}
			getVertexPosition(e, t) {
				let n = this.geometry,
					i = n.attributes.position,
					s = n.morphAttributes.position,
					o = n.morphTargetsRelative;
				t.fromBufferAttribute(i, e);
				let a = this.morphTargetInfluences;
				if (s && a) {
					Kc.set(0, 0, 0);
					for (let l = 0, c = s.length; l < c; l++) {
						let u = a[l],
							h = s[l];
						u !== 0 && (Jh.fromBufferAttribute(h, e), o ? Kc.addScaledVector(Jh, u) : Kc.addScaledVector(Jh.sub(t), u))
					}
					t.add(Kc)
				}
				return t
			}
			raycast(e, t) {
				let n = this.geometry,
					i = this.material,
					s = this.matrixWorld;
				i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Yc.copy(n.boundingSphere), Yc.applyMatrix4(s), Os.copy(e.ray).recast(e.near), !(Yc.containsPoint(Os.origin) === !1 && (Os.intersectSphere(Yc, Em) === null || Os.origin.distanceToSquared(Em) > (e.far - e.near) ** 2)) && (Tm.copy(s).invert(), Os.copy(e.ray).applyMatrix4(Tm), !(n.boundingBox !== null && Os.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Os)))
			}
			_computeIntersections(e, t, n) {
				let i, s = this.geometry,
					o = this.material,
					a = s.index,
					l = s.attributes.position,
					c = s.attributes.uv,
					u = s.attributes.uv1,
					h = s.attributes.normal,
					f = s.groups,
					m = s.drawRange;
				if (a !== null)
					if (Array.isArray(o))
						for (let g = 0, y = f.length; g < y; g++) {
							let d = f[g],
								p = o[d.materialIndex],
								_ = Math.max(d.start, m.start),
								v = Math.min(a.count, Math.min(d.start + d.count, m.start + m.count));
							for (let x = _, M = v; x < M; x += 3) {
								let I = a.getX(x),
									w = a.getX(x + 1),
									L = a.getX(x + 2);
								i = tu(this, p, e, n, c, u, h, I, w, L), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = d.materialIndex, t.push(i))
							}
						} else {
							let g = Math.max(0, m.start),
								y = Math.min(a.count, m.start + m.count);
							for (let d = g, p = y; d < p; d += 3) {
								let _ = a.getX(d),
									v = a.getX(d + 1),
									x = a.getX(d + 2);
								i = tu(this, o, e, n, c, u, h, _, v, x), i && (i.faceIndex = Math.floor(d / 3), t.push(i))
							}
						} else if (l !== void 0)
							if (Array.isArray(o))
								for (let g = 0, y = f.length; g < y; g++) {
									let d = f[g],
										p = o[d.materialIndex],
										_ = Math.max(d.start, m.start),
										v = Math.min(l.count, Math.min(d.start + d.count, m.start + m.count));
									for (let x = _, M = v; x < M; x += 3) {
										let I = x,
											w = x + 1,
											L = x + 2;
										i = tu(this, p, e, n, c, u, h, I, w, L), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = d.materialIndex, t.push(i))
									}
								} else {
									let g = Math.max(0, m.start),
										y = Math.min(l.count, m.start + m.count);
									for (let d = g, p = y; d < p; d += 3) {
										let _ = d,
											v = d + 1,
											x = d + 2;
										i = tu(this, o, e, n, c, u, h, _, v, x), i && (i.faceIndex = Math.floor(d / 3), t.push(i))
									}
								}
			}
		};

	function Rv(r, e, t, n, i, s, o, a) {
		let l;
		if (e.side === gn ? l = n.intersectTriangle(o, s, i, !0, a) : l = n.intersectTriangle(i, s, o, e.side === _i, a), l === null) return null;
		eu.copy(a), eu.applyMatrix4(r.matrixWorld);
		let c = t.ray.origin.distanceTo(eu);
		return c < t.near || c > t.far ? null : {
			distance: c,
			point: eu.clone(),
			object: r
		}
	}

	function tu(r, e, t, n, i, s, o, a, l, c) {
		r.getVertexPosition(a, Vo), r.getVertexPosition(l, zo), r.getVertexPosition(c, Ho);
		let u = Rv(r, e, t, n, Vo, zo, Ho, Qc);
		if (u) {
			i && (Zc.fromBufferAttribute(i, a), Jc.fromBufferAttribute(i, l), $c.fromBufferAttribute(i, c), u.uv = ks.getInterpolation(Qc, Vo, zo, Ho, Zc, Jc, $c, new Ce)), s && (Zc.fromBufferAttribute(s, a), Jc.fromBufferAttribute(s, l), $c.fromBufferAttribute(s, c), u.uv1 = ks.getInterpolation(Qc, Vo, zo, Ho, Zc, Jc, $c, new Ce), u.uv2 = u.uv1), o && (Mm.fromBufferAttribute(o, a), bm.fromBufferAttribute(o, l), Sm.fromBufferAttribute(o, c), u.normal = ks.getInterpolation(Qc, Vo, zo, Ho, Mm, bm, Sm, new re), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
			let h = {
				a,
				b: l,
				c,
				normal: new re,
				materialIndex: 0
			};
			ks.getNormal(Vo, zo, Ho, h.normal), u.face = h
		}
		return u
	}
	var Xs = class r extends St {
		constructor(e = 1, t = 1, n = 1, i = 1, s = 1, o = 1) {
			super(), this.type = "BoxGeometry", this.parameters = {
				width: e,
				height: t,
				depth: n,
				widthSegments: i,
				heightSegments: s,
				depthSegments: o
			};
			let a = this;
			i = Math.floor(i), s = Math.floor(s), o = Math.floor(o);
			let l = [],
				c = [],
				u = [],
				h = [],
				f = 0,
				m = 0;
			g("z", "y", "x", -1, -1, n, t, e, o, s, 0), g("z", "y", "x", 1, -1, n, t, -e, o, s, 1), g("x", "z", "y", 1, 1, e, n, t, i, o, 2), g("x", "z", "y", 1, -1, e, n, -t, i, o, 3), g("x", "y", "z", 1, -1, e, t, n, i, s, 4), g("x", "y", "z", -1, -1, e, t, -n, i, s, 5), this.setIndex(l), this.setAttribute("position", new ze(c, 3)), this.setAttribute("normal", new ze(u, 3)), this.setAttribute("uv", new ze(h, 2));

			function g(y, d, p, _, v, x, M, I, w, L, T) {
				let C = x / w,
					V = M / L,
					k = x / 2,
					F = M / 2,
					U = I / 2,
					K = w + 1,
					Z = L + 1,
					Y = 0,
					H = 0,
					oe = new re;
				for (let de = 0; de < Z; de++) {
					let te = de * V - F;
					for (let fe = 0; fe < K; fe++) {
						let me = fe * C - k;
						oe[y] = me * _, oe[d] = te * v, oe[p] = U, c.push(oe.x, oe.y, oe.z), oe[y] = 0, oe[d] = 0, oe[p] = I > 0 ? 1 : -1, u.push(oe.x, oe.y, oe.z), h.push(fe / w), h.push(1 - de / L), Y += 1
					}
				}
				for (let de = 0; de < L; de++)
					for (let te = 0; te < w; te++) {
						let fe = f + te + K * de,
							me = f + te + K * (de + 1),
							P = f + (te + 1) + K * (de + 1),
							b = f + (te + 1) + K * de;
						l.push(fe, me, b), l.push(me, P, b), H += 6
					}
				a.addGroup(m, H, T), m += H, f += Y
			}
		}
		copy(e) {
			return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
		}
		static fromJSON(e) {
			return new r(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
		}
	};

	function aa(r) {
		let e = {};
		for (let t in r) {
			e[t] = {};
			for (let n in r[t]) {
				let i = r[t][n];
				i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
			}
		}
		return e
	}

	function qn(r) {
		let e = {};
		for (let t = 0; t < r.length; t++) {
			let n = aa(r[t]);
			for (let i in n) e[i] = n[i]
		}
		return e
	}

	function Iv(r) {
		let e = [];
		for (let t = 0; t < r.length; t++) e.push(r[t].clone());
		return e
	}

	function Pg(r) {
		return r.getRenderTarget() === null ? r.outputColorSpace : Bn
	}
	var Pv = {
			clone: aa,
			merge: qn
		},
		Lv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
		Nv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
		kr = class extends Vi {
			constructor(e) {
				super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Lv, this.fragmentShader = Nv, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
					derivatives: !1,
					fragDepth: !1,
					drawBuffers: !1,
					shaderTextureLOD: !1
				}, this.defaultAttributeValues = {
					color: [1, 1, 1],
					uv: [0, 0],
					uv1: [0, 0]
				}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = aa(e.uniforms), this.uniformsGroups = Iv(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
			}
			toJSON(e) {
				let t = super.toJSON(e);
				t.glslVersion = this.glslVersion, t.uniforms = {};
				for (let i in this.uniforms) {
					let o = this.uniforms[i].value;
					o && o.isTexture ? t.uniforms[i] = {
						type: "t",
						value: o.toJSON(e).uuid
					} : o && o.isColor ? t.uniforms[i] = {
						type: "c",
						value: o.getHex()
					} : o && o.isVector2 ? t.uniforms[i] = {
						type: "v2",
						value: o.toArray()
					} : o && o.isVector3 ? t.uniforms[i] = {
						type: "v3",
						value: o.toArray()
					} : o && o.isVector4 ? t.uniforms[i] = {
						type: "v4",
						value: o.toArray()
					} : o && o.isMatrix3 ? t.uniforms[i] = {
						type: "m3",
						value: o.toArray()
					} : o && o.isMatrix4 ? t.uniforms[i] = {
						type: "m4",
						value: o.toArray()
					} : t.uniforms[i] = {
						value: o
					}
				}
				Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
				let n = {};
				for (let i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
				return Object.keys(n).length > 0 && (t.extensions = n), t
			}
		},
		Eu = class extends Rt {
			constructor() {
				super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Je, this.projectionMatrix = new Je, this.projectionMatrixInverse = new Je, this.coordinateSystem = Dr
			}
			copy(e, t) {
				return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
			}
			getWorldDirection(e) {
				this.updateWorldMatrix(!0, !1);
				let t = this.matrixWorld.elements;
				return e.set(-t[8], -t[9], -t[10]).normalize()
			}
			updateMatrixWorld(e) {
				super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
			}
			updateWorldMatrix(e, t) {
				super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		Yt = class extends Eu {
			constructor(e = 50, t = 1, n = .1, i = 2e3) {
				super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
			}
			copy(e, t) {
				return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
			}
			setFocalLength(e) {
				let t = .5 * this.getFilmHeight() / e;
				this.fov = sa * 2 * Math.atan(t), this.updateProjectionMatrix()
			}
			getFocalLength() {
				let e = Math.tan($o * .5 * this.fov);
				return .5 * this.getFilmHeight() / e
			}
			getEffectiveFOV() {
				return sa * 2 * Math.atan(Math.tan($o * .5 * this.fov) / this.zoom)
			}
			getFilmWidth() {
				return this.filmGauge * Math.min(this.aspect, 1)
			}
			getFilmHeight() {
				return this.filmGauge / Math.max(this.aspect, 1)
			}
			setViewOffset(e, t, n, i, s, o) {
				this.aspect = e / t, this.view === null && (this.view = {
					enabled: !0,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
			}
			clearViewOffset() {
				this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
			}
			updateProjectionMatrix() {
				let e = this.near,
					t = e * Math.tan($o * .5 * this.fov) / this.zoom,
					n = 2 * t,
					i = this.aspect * n,
					s = -.5 * i,
					o = this.view;
				if (this.view !== null && this.view.enabled) {
					let l = o.fullWidth,
						c = o.fullHeight;
					s += o.offsetX * i / l, t -= o.offsetY * n / c, i *= o.width / l, n *= o.height / c
				}
				let a = this.filmOffset;
				a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
			}
			toJSON(e) {
				let t = super.toJSON(e);
				return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
			}
		},
		Wo = -90,
		Xo = 1,
		yf = class extends Rt {
			constructor(e, t, n) {
				super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null;
				let i = new Yt(Wo, Xo, e, t);
				i.layers = this.layers, this.add(i);
				let s = new Yt(Wo, Xo, e, t);
				s.layers = this.layers, this.add(s);
				let o = new Yt(Wo, Xo, e, t);
				o.layers = this.layers, this.add(o);
				let a = new Yt(Wo, Xo, e, t);
				a.layers = this.layers, this.add(a);
				let l = new Yt(Wo, Xo, e, t);
				l.layers = this.layers, this.add(l);
				let c = new Yt(Wo, Xo, e, t);
				c.layers = this.layers, this.add(c)
			}
			updateCoordinateSystem() {
				let e = this.coordinateSystem,
					t = this.children.concat(),
					[n, i, s, o, a, l] = t;
				for (let c of t) this.remove(c);
				if (e === Dr) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
				else if (e === yu) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
				else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
				for (let c of t) this.add(c), c.updateMatrixWorld()
			}
			update(e, t) {
				this.parent === null && this.updateMatrixWorld();
				let n = this.renderTarget;
				this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
				let [i, s, o, a, l, c] = this.children, u = e.getRenderTarget(), h = e.toneMapping, f = e.xr.enabled;
				e.toneMapping = Fr, e.xr.enabled = !1;
				let m = n.texture.generateMipmaps;
				n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, o), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, l), n.texture.generateMipmaps = m, e.setRenderTarget(n, 5), e.render(t, c), e.setRenderTarget(u), e.toneMapping = h, e.xr.enabled = f, n.texture.needsPMREMUpdate = !0
			}
		},
		Rl = class extends Gn {
			constructor(e, t, n, i, s, o, a, l, c, u) {
				e = e !== void 0 ? e : [], t = t !== void 0 ? t : ta, super(e, t, n, i, s, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1
			}
			get images() {
				return this.image
			}
			set images(e) {
				this.image = e
			}
		},
		vf = class extends Ur {
			constructor(e = 1, t = {}) {
				super(e, e, t), this.isWebGLCubeRenderTarget = !0;
				let n = {
						width: e,
						height: e,
						depth: 1
					},
					i = [n, n, n, n, n, n];
				t.encoding !== void 0 && (Tl("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Vs ? ot : zs), this.texture = new Rl(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : mn
			}
			fromEquirectangularTexture(e, t) {
				this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
				let n = {
						uniforms: {
							tEquirect: {
								value: null
							}
						},
						vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
						fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
					},
					i = new Xs(5, 5, 5),
					s = new kr({
						name: "CubemapFromEquirect",
						uniforms: aa(n.uniforms),
						vertexShader: n.vertexShader,
						fragmentShader: n.fragmentShader,
						side: gn,
						blending: is
					});
				s.uniforms.tEquirect.value = t;
				let o = new Nt(i, s),
					a = t.minFilter;
				return t.minFilter === ki && (t.minFilter = mn), new yf(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
			}
			clear(e, t, n, i) {
				let s = e.getRenderTarget();
				for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
				e.setRenderTarget(s)
			}
		},
		$h = new re,
		Ov = new re,
		Dv = new pt,
		Nr = class {
			constructor(e = new re(1, 0, 0), t = 0) {
				this.isPlane = !0, this.normal = e, this.constant = t
			}
			set(e, t) {
				return this.normal.copy(e), this.constant = t, this
			}
			setComponents(e, t, n, i) {
				return this.normal.set(e, t, n), this.constant = i, this
			}
			setFromNormalAndCoplanarPoint(e, t) {
				return this.normal.copy(e), this.constant = -t.dot(this.normal), this
			}
			setFromCoplanarPoints(e, t, n) {
				let i = $h.subVectors(n, t).cross(Ov.subVectors(e, t)).normalize();
				return this.setFromNormalAndCoplanarPoint(i, e), this
			}
			copy(e) {
				return this.normal.copy(e.normal), this.constant = e.constant, this
			}
			normalize() {
				let e = 1 / this.normal.length();
				return this.normal.multiplyScalar(e), this.constant *= e, this
			}
			negate() {
				return this.constant *= -1, this.normal.negate(), this
			}
			distanceToPoint(e) {
				return this.normal.dot(e) + this.constant
			}
			distanceToSphere(e) {
				return this.distanceToPoint(e.center) - e.radius
			}
			projectPoint(e, t) {
				return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
			}
			intersectLine(e, t) {
				let n = e.delta($h),
					i = this.normal.dot(n);
				if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
				let s = -(e.start.dot(this.normal) + this.constant) / i;
				return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
			}
			intersectsLine(e) {
				let t = this.distanceToPoint(e.start),
					n = this.distanceToPoint(e.end);
				return t < 0 && n > 0 || n < 0 && t > 0
			}
			intersectsBox(e) {
				return e.intersectsPlane(this)
			}
			intersectsSphere(e) {
				return e.intersectsPlane(this)
			}
			coplanarPoint(e) {
				return e.copy(this.normal).multiplyScalar(-this.constant)
			}
			applyMatrix4(e, t) {
				let n = t || Dv.getNormalMatrix(e),
					i = this.coplanarPoint($h).applyMatrix4(e),
					s = this.normal.applyMatrix3(n).normalize();
				return this.constant = -i.dot(s), this
			}
			translate(e) {
				return this.constant -= e.dot(this.normal), this
			}
			equals(e) {
				return e.normal.equals(this.normal) && e.constant === this.constant
			}
			clone() {
				return new this.constructor().copy(this)
			}
		},
		Ds = new Gi,
		nu = new re,
		Il = class {
			constructor(e = new Nr, t = new Nr, n = new Nr, i = new Nr, s = new Nr, o = new Nr) {
				this.planes = [e, t, n, i, s, o]
			}
			set(e, t, n, i, s, o) {
				let a = this.planes;
				return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(s), a[5].copy(o), this
			}
			copy(e) {
				let t = this.planes;
				for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
				return this
			}
			setFromProjectionMatrix(e, t = Dr) {
				let n = this.planes,
					i = e.elements,
					s = i[0],
					o = i[1],
					a = i[2],
					l = i[3],
					c = i[4],
					u = i[5],
					h = i[6],
					f = i[7],
					m = i[8],
					g = i[9],
					y = i[10],
					d = i[11],
					p = i[12],
					_ = i[13],
					v = i[14],
					x = i[15];
				if (n[0].setComponents(l - s, f - c, d - m, x - p).normalize(), n[1].setComponents(l + s, f + c, d + m, x + p).normalize(), n[2].setComponents(l + o, f + u, d + g, x + _).normalize(), n[3].setComponents(l - o, f - u, d - g, x - _).normalize(), n[4].setComponents(l - a, f - h, d - y, x - v).normalize(), t === Dr) n[5].setComponents(l + a, f + h, d + y, x + v).normalize();
				else if (t === yu) n[5].setComponents(a, h, y, v).normalize();
				else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
				return this
			}
			intersectsObject(e) {
				if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ds.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
				else {
					let t = e.geometry;
					t.boundingSphere === null && t.computeBoundingSphere(), Ds.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
				}
				return this.intersectsSphere(Ds)
			}
			intersectsSprite(e) {
				return Ds.center.set(0, 0, 0), Ds.radius = .7071067811865476, Ds.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ds)
			}
			intersectsSphere(e) {
				let t = this.planes,
					n = e.center,
					i = -e.radius;
				for (let s = 0; s < 6; s++)
					if (t[s].distanceToPoint(n) < i) return !1;
				return !0
			}
			intersectsBox(e) {
				let t = this.planes;
				for (let n = 0; n < 6; n++) {
					let i = t[n];
					if (nu.x = i.normal.x > 0 ? e.max.x : e.min.x, nu.y = i.normal.y > 0 ? e.max.y : e.min.y, nu.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(nu) < 0) return !1
				}
				return !0
			}
			containsPoint(e) {
				let t = this.planes;
				for (let n = 0; n < 6; n++)
					if (t[n].distanceToPoint(e) < 0) return !1;
				return !0
			}
			clone() {
				return new this.constructor().copy(this)
			}
		};

	function Lg() {
		let r = null,
			e = !1,
			t = null,
			n = null;

		function i(s, o) {
			t(s, o), n = r.requestAnimationFrame(i)
		}
		return {
			start: function() {
				e !== !0 && t !== null && (n = r.requestAnimationFrame(i), e = !0)
			},
			stop: function() {
				r.cancelAnimationFrame(n), e = !1
			},
			setAnimationLoop: function(s) {
				t = s
			},
			setContext: function(s) {
				r = s
			}
		}
	}

	function Fv(r, e) {
		let t = e.isWebGL2,
			n = new WeakMap;

		function i(c, u) {
			let h = c.array,
				f = c.usage,
				m = r.createBuffer();
			r.bindBuffer(u, m), r.bufferData(u, h, f), c.onUploadCallback();
			let g;
			if (h instanceof Float32Array) g = r.FLOAT;
			else if (h instanceof Uint16Array)
				if (c.isFloat16BufferAttribute)
					if (t) g = r.HALF_FLOAT;
					else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
			else g = r.UNSIGNED_SHORT;
			else if (h instanceof Int16Array) g = r.SHORT;
			else if (h instanceof Uint32Array) g = r.UNSIGNED_INT;
			else if (h instanceof Int32Array) g = r.INT;
			else if (h instanceof Int8Array) g = r.BYTE;
			else if (h instanceof Uint8Array) g = r.UNSIGNED_BYTE;
			else if (h instanceof Uint8ClampedArray) g = r.UNSIGNED_BYTE;
			else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
			return {
				buffer: m,
				type: g,
				bytesPerElement: h.BYTES_PER_ELEMENT,
				version: c.version
			}
		}

		function s(c, u, h) {
			let f = u.array,
				m = u.updateRange;
			r.bindBuffer(h, c), m.count === -1 ? r.bufferSubData(h, 0, f) : (t ? r.bufferSubData(h, m.offset * f.BYTES_PER_ELEMENT, f, m.offset, m.count) : r.bufferSubData(h, m.offset * f.BYTES_PER_ELEMENT, f.subarray(m.offset, m.offset + m.count)), m.count = -1), u.onUploadCallback()
		}

		function o(c) {
			return c.isInterleavedBufferAttribute && (c = c.data), n.get(c)
		}

		function a(c) {
			c.isInterleavedBufferAttribute && (c = c.data);
			let u = n.get(c);
			u && (r.deleteBuffer(u.buffer), n.delete(c))
		}

		function l(c, u) {
			if (c.isGLBufferAttribute) {
				let f = n.get(c);
				(!f || f.version < c.version) && n.set(c, {
					buffer: c.buffer,
					type: c.type,
					bytesPerElement: c.elementSize,
					version: c.version
				});
				return
			}
			c.isInterleavedBufferAttribute && (c = c.data);
			let h = n.get(c);
			h === void 0 ? n.set(c, i(c, u)) : h.version < c.version && (s(h.buffer, c, u), h.version = c.version)
		}
		return {
			get: o,
			remove: a,
			update: l
		}
	}
	var Pl = class r extends St {
			constructor(e = 1, t = 1, n = 1, i = 1) {
				super(), this.type = "PlaneGeometry", this.parameters = {
					width: e,
					height: t,
					widthSegments: n,
					heightSegments: i
				};
				let s = e / 2,
					o = t / 2,
					a = Math.floor(n),
					l = Math.floor(i),
					c = a + 1,
					u = l + 1,
					h = e / a,
					f = t / l,
					m = [],
					g = [],
					y = [],
					d = [];
				for (let p = 0; p < u; p++) {
					let _ = p * f - o;
					for (let v = 0; v < c; v++) {
						let x = v * h - s;
						g.push(x, -_, 0), y.push(0, 0, 1), d.push(v / a), d.push(1 - p / l)
					}
				}
				for (let p = 0; p < l; p++)
					for (let _ = 0; _ < a; _++) {
						let v = _ + c * p,
							x = _ + c * (p + 1),
							M = _ + 1 + c * (p + 1),
							I = _ + 1 + c * p;
						m.push(v, x, I), m.push(x, M, I)
					}
				this.setIndex(m), this.setAttribute("position", new ze(g, 3)), this.setAttribute("normal", new ze(y, 3)), this.setAttribute("uv", new ze(d, 2))
			}
			copy(e) {
				return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
			}
			static fromJSON(e) {
				return new r(e.width, e.height, e.widthSegments, e.heightSegments)
			}
		},
		Uv = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
		kv = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
		Bv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
		Gv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		Vv = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
		zv = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
		Hv = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
		Wv = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
		Xv = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
		qv = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
		jv = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
		Yv = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
		Kv = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
		Zv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
		Jv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
		$v = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
		Qv = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
		ex = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
		tx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
		nx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
		ix = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
		rx = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
		sx = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
		ox = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
		ax = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
		lx = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
		cx = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
		ux = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
		hx = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
		fx = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
		dx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
		px = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
		mx = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
		gx = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
		yx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
		vx = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
		xx = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
		_x = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
		Tx = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
		Ex = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
		Mx = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
		bx = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
		Sx = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
		Ax = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
		wx = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
		Cx = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
		Rx = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
		Ix = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
		Px = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
		Lx = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
		Nx = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
		Ox = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
		Dx = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
		Fx = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
		Ux = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
		kx = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
		Bx = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
		Gx = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
		Vx = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
		zx = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,
		Hx = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
		Wx = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
		Xx = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		qx = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
		jx = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
		Yx = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
		Kx = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
		Zx = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
		Jx = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
		$x = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
		Qx = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
		e_ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		t_ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		n_ = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
		i_ = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
		r_ = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
		s_ = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
		o_ = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
		a_ = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
		l_ = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
		c_ = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
		u_ = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
		h_ = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
		f_ = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
		d_ = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
		p_ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
		m_ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
		g_ = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
		y_ = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
		v_ = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
		x_ = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
		__ = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
		T_ = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
		E_ = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
		M_ = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
		b_ = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
		S_ = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
		A_ = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
		w_ = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
		C_ = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
		R_ = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
		I_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
		P_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
		L_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
		N_ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
		O_ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
		D_ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		F_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
		U_ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		k_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
		B_ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		G_ = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
		V_ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
		z_ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
		H_ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
		W_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
		X_ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
		q_ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		j_ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		Y_ = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
		K_ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		Z_ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		J_ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		$_ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
		Q_ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		eT = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
		tT = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
		nT = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		iT = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		rT = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
		sT = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		oT = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		aT = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		lT = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
		cT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		uT = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		hT = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
		fT = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		dT = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
		Tt = {
			alphahash_fragment: Uv,
			alphahash_pars_fragment: kv,
			alphamap_fragment: Bv,
			alphamap_pars_fragment: Gv,
			alphatest_fragment: Vv,
			alphatest_pars_fragment: zv,
			aomap_fragment: Hv,
			aomap_pars_fragment: Wv,
			begin_vertex: Xv,
			beginnormal_vertex: qv,
			bsdfs: jv,
			iridescence_fragment: Yv,
			bumpmap_pars_fragment: Kv,
			clipping_planes_fragment: Zv,
			clipping_planes_pars_fragment: Jv,
			clipping_planes_pars_vertex: $v,
			clipping_planes_vertex: Qv,
			color_fragment: ex,
			color_pars_fragment: tx,
			color_pars_vertex: nx,
			color_vertex: ix,
			common: rx,
			cube_uv_reflection_fragment: sx,
			defaultnormal_vertex: ox,
			displacementmap_pars_vertex: ax,
			displacementmap_vertex: lx,
			emissivemap_fragment: cx,
			emissivemap_pars_fragment: ux,
			colorspace_fragment: hx,
			colorspace_pars_fragment: fx,
			envmap_fragment: dx,
			envmap_common_pars_fragment: px,
			envmap_pars_fragment: mx,
			envmap_pars_vertex: gx,
			envmap_physical_pars_fragment: Cx,
			envmap_vertex: yx,
			fog_vertex: vx,
			fog_pars_vertex: xx,
			fog_fragment: _x,
			fog_pars_fragment: Tx,
			gradientmap_pars_fragment: Ex,
			lightmap_fragment: Mx,
			lightmap_pars_fragment: bx,
			lights_lambert_fragment: Sx,
			lights_lambert_pars_fragment: Ax,
			lights_pars_begin: wx,
			lights_toon_fragment: Rx,
			lights_toon_pars_fragment: Ix,
			lights_phong_fragment: Px,
			lights_phong_pars_fragment: Lx,
			lights_physical_fragment: Nx,
			lights_physical_pars_fragment: Ox,
			lights_fragment_begin: Dx,
			lights_fragment_maps: Fx,
			lights_fragment_end: Ux,
			logdepthbuf_fragment: kx,
			logdepthbuf_pars_fragment: Bx,
			logdepthbuf_pars_vertex: Gx,
			logdepthbuf_vertex: Vx,
			map_fragment: zx,
			map_pars_fragment: Hx,
			map_particle_fragment: Wx,
			map_particle_pars_fragment: Xx,
			metalnessmap_fragment: qx,
			metalnessmap_pars_fragment: jx,
			morphcolor_vertex: Yx,
			morphnormal_vertex: Kx,
			morphtarget_pars_vertex: Zx,
			morphtarget_vertex: Jx,
			normal_fragment_begin: $x,
			normal_fragment_maps: Qx,
			normal_pars_fragment: e_,
			normal_pars_vertex: t_,
			normal_vertex: n_,
			normalmap_pars_fragment: i_,
			clearcoat_normal_fragment_begin: r_,
			clearcoat_normal_fragment_maps: s_,
			clearcoat_pars_fragment: o_,
			iridescence_pars_fragment: a_,
			opaque_fragment: l_,
			packing: c_,
			premultiplied_alpha_fragment: u_,
			project_vertex: h_,
			dithering_fragment: f_,
			dithering_pars_fragment: d_,
			roughnessmap_fragment: p_,
			roughnessmap_pars_fragment: m_,
			shadowmap_pars_fragment: g_,
			shadowmap_pars_vertex: y_,
			shadowmap_vertex: v_,
			shadowmask_pars_fragment: x_,
			skinbase_vertex: __,
			skinning_pars_vertex: T_,
			skinning_vertex: E_,
			skinnormal_vertex: M_,
			specularmap_fragment: b_,
			specularmap_pars_fragment: S_,
			tonemapping_fragment: A_,
			tonemapping_pars_fragment: w_,
			transmission_fragment: C_,
			transmission_pars_fragment: R_,
			uv_pars_fragment: I_,
			uv_pars_vertex: P_,
			uv_vertex: L_,
			worldpos_vertex: N_,
			background_vert: O_,
			background_frag: D_,
			backgroundCube_vert: F_,
			backgroundCube_frag: U_,
			cube_vert: k_,
			cube_frag: B_,
			depth_vert: G_,
			depth_frag: V_,
			distanceRGBA_vert: z_,
			distanceRGBA_frag: H_,
			equirect_vert: W_,
			equirect_frag: X_,
			linedashed_vert: q_,
			linedashed_frag: j_,
			meshbasic_vert: Y_,
			meshbasic_frag: K_,
			meshlambert_vert: Z_,
			meshlambert_frag: J_,
			meshmatcap_vert: $_,
			meshmatcap_frag: Q_,
			meshnormal_vert: eT,
			meshnormal_frag: tT,
			meshphong_vert: nT,
			meshphong_frag: iT,
			meshphysical_vert: rT,
			meshphysical_frag: sT,
			meshtoon_vert: oT,
			meshtoon_frag: aT,
			points_vert: lT,
			points_frag: cT,
			shadow_vert: uT,
			shadow_frag: hT,
			sprite_vert: fT,
			sprite_frag: dT
		},
		Ve = {
			common: {
				diffuse: {
					value: new qe(16777215)
				},
				opacity: {
					value: 1
				},
				map: {
					value: null
				},
				mapTransform: {
					value: new pt
				},
				alphaMap: {
					value: null
				},
				alphaMapTransform: {
					value: new pt
				},
				alphaTest: {
					value: 0
				}
			},
			specularmap: {
				specularMap: {
					value: null
				},
				specularMapTransform: {
					value: new pt
				}
			},
			envmap: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				reflectivity: {
					value: 1
				},
				ior: {
					value: 1.5
				},
				refractionRatio: {
					value: .98
				}
			},
			aomap: {
				aoMap: {
					value: null
				},
				aoMapIntensity: {
					value: 1
				},
				aoMapTransform: {
					value: new pt
				}
			},
			lightmap: {
				lightMap: {
					value: null
				},
				lightMapIntensity: {
					value: 1
				},
				lightMapTransform: {
					value: new pt
				}
			},
			bumpmap: {
				bumpMap: {
					value: null
				},
				bumpMapTransform: {
					value: new pt
				},
				bumpScale: {
					value: 1
				}
			},
			normalmap: {
				normalMap: {
					value: null
				},
				normalMapTransform: {
					value: new pt
				},
				normalScale: {
					value: new Ce(1, 1)
				}
			},
			displacementmap: {
				displacementMap: {
					value: null
				},
				displacementMapTransform: {
					value: new pt
				},
				displacementScale: {
					value: 1
				},
				displacementBias: {
					value: 0
				}
			},
			emissivemap: {
				emissiveMap: {
					value: null
				},
				emissiveMapTransform: {
					value: new pt
				}
			},
			metalnessmap: {
				metalnessMap: {
					value: null
				},
				metalnessMapTransform: {
					value: new pt
				}
			},
			roughnessmap: {
				roughnessMap: {
					value: null
				},
				roughnessMapTransform: {
					value: new pt
				}
			},
			gradientmap: {
				gradientMap: {
					value: null
				}
			},
			fog: {
				fogDensity: {
					value: 25e-5
				},
				fogNear: {
					value: 1
				},
				fogFar: {
					value: 2e3
				},
				fogColor: {
					value: new qe(16777215)
				}
			},
			lights: {
				ambientLightColor: {
					value: []
				},
				lightProbe: {
					value: []
				},
				directionalLights: {
					value: [],
					properties: {
						direction: {},
						color: {}
					}
				},
				directionalLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				directionalShadowMap: {
					value: []
				},
				directionalShadowMatrix: {
					value: []
				},
				spotLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {}
					}
				},
				spotLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				spotLightMap: {
					value: []
				},
				spotShadowMap: {
					value: []
				},
				spotLightMatrix: {
					value: []
				},
				pointLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						decay: {},
						distance: {}
					}
				},
				pointLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {}
					}
				},
				pointShadowMap: {
					value: []
				},
				pointShadowMatrix: {
					value: []
				},
				hemisphereLights: {
					value: [],
					properties: {
						direction: {},
						skyColor: {},
						groundColor: {}
					}
				},
				rectAreaLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						width: {},
						height: {}
					}
				},
				ltc_1: {
					value: null
				},
				ltc_2: {
					value: null
				}
			},
			points: {
				diffuse: {
					value: new qe(16777215)
				},
				opacity: {
					value: 1
				},
				size: {
					value: 1
				},
				scale: {
					value: 1
				},
				map: {
					value: null
				},
				alphaMap: {
					value: null
				},
				alphaMapTransform: {
					value: new pt
				},
				alphaTest: {
					value: 0
				},
				uvTransform: {
					value: new pt
				}
			},
			sprite: {
				diffuse: {
					value: new qe(16777215)
				},
				opacity: {
					value: 1
				},
				center: {
					value: new Ce(.5, .5)
				},
				rotation: {
					value: 0
				},
				map: {
					value: null
				},
				mapTransform: {
					value: new pt
				},
				alphaMap: {
					value: null
				},
				alphaMapTransform: {
					value: new pt
				},
				alphaTest: {
					value: 0
				}
			}
		},
		ar = {
			basic: {
				uniforms: qn([Ve.common, Ve.specularmap, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.fog]),
				vertexShader: Tt.meshbasic_vert,
				fragmentShader: Tt.meshbasic_frag
			},
			lambert: {
				uniforms: qn([Ve.common, Ve.specularmap, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.fog, Ve.lights, {
					emissive: {
						value: new qe(0)
					}
				}]),
				vertexShader: Tt.meshlambert_vert,
				fragmentShader: Tt.meshlambert_frag
			},
			phong: {
				uniforms: qn([Ve.common, Ve.specularmap, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.fog, Ve.lights, {
					emissive: {
						value: new qe(0)
					},
					specular: {
						value: new qe(1118481)
					},
					shininess: {
						value: 30
					}
				}]),
				vertexShader: Tt.meshphong_vert,
				fragmentShader: Tt.meshphong_frag
			},
			standard: {
				uniforms: qn([Ve.common, Ve.envmap, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.roughnessmap, Ve.metalnessmap, Ve.fog, Ve.lights, {
					emissive: {
						value: new qe(0)
					},
					roughness: {
						value: 1
					},
					metalness: {
						value: 0
					},
					envMapIntensity: {
						value: 1
					}
				}]),
				vertexShader: Tt.meshphysical_vert,
				fragmentShader: Tt.meshphysical_frag
			},
			toon: {
				uniforms: qn([Ve.common, Ve.aomap, Ve.lightmap, Ve.emissivemap, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.gradientmap, Ve.fog, Ve.lights, {
					emissive: {
						value: new qe(0)
					}
				}]),
				vertexShader: Tt.meshtoon_vert,
				fragmentShader: Tt.meshtoon_frag
			},
			matcap: {
				uniforms: qn([Ve.common, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, Ve.fog, {
					matcap: {
						value: null
					}
				}]),
				vertexShader: Tt.meshmatcap_vert,
				fragmentShader: Tt.meshmatcap_frag
			},
			points: {
				uniforms: qn([Ve.points, Ve.fog]),
				vertexShader: Tt.points_vert,
				fragmentShader: Tt.points_frag
			},
			dashed: {
				uniforms: qn([Ve.common, Ve.fog, {
					scale: {
						value: 1
					},
					dashSize: {
						value: 1
					},
					totalSize: {
						value: 2
					}
				}]),
				vertexShader: Tt.linedashed_vert,
				fragmentShader: Tt.linedashed_frag
			},
			depth: {
				uniforms: qn([Ve.common, Ve.displacementmap]),
				vertexShader: Tt.depth_vert,
				fragmentShader: Tt.depth_frag
			},
			normal: {
				uniforms: qn([Ve.common, Ve.bumpmap, Ve.normalmap, Ve.displacementmap, {
					opacity: {
						value: 1
					}
				}]),
				vertexShader: Tt.meshnormal_vert,
				fragmentShader: Tt.meshnormal_frag
			},
			sprite: {
				uniforms: qn([Ve.sprite, Ve.fog]),
				vertexShader: Tt.sprite_vert,
				fragmentShader: Tt.sprite_frag
			},
			background: {
				uniforms: {
					uvTransform: {
						value: new pt
					},
					t2D: {
						value: null
					},
					backgroundIntensity: {
						value: 1
					}
				},
				vertexShader: Tt.background_vert,
				fragmentShader: Tt.background_frag
			},
			backgroundCube: {
				uniforms: {
					envMap: {
						value: null
					},
					flipEnvMap: {
						value: -1
					},
					backgroundBlurriness: {
						value: 0
					},
					backgroundIntensity: {
						value: 1
					}
				},
				vertexShader: Tt.backgroundCube_vert,
				fragmentShader: Tt.backgroundCube_frag
			},
			cube: {
				uniforms: {
					tCube: {
						value: null
					},
					tFlip: {
						value: -1
					},
					opacity: {
						value: 1
					}
				},
				vertexShader: Tt.cube_vert,
				fragmentShader: Tt.cube_frag
			},
			equirect: {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: Tt.equirect_vert,
				fragmentShader: Tt.equirect_frag
			},
			distanceRGBA: {
				uniforms: qn([Ve.common, Ve.displacementmap, {
					referencePosition: {
						value: new re
					},
					nearDistance: {
						value: 1
					},
					farDistance: {
						value: 1e3
					}
				}]),
				vertexShader: Tt.distanceRGBA_vert,
				fragmentShader: Tt.distanceRGBA_frag
			},
			shadow: {
				uniforms: qn([Ve.lights, Ve.fog, {
					color: {
						value: new qe(0)
					},
					opacity: {
						value: 1
					}
				}]),
				vertexShader: Tt.shadow_vert,
				fragmentShader: Tt.shadow_frag
			}
		};
	ar.physical = {
		uniforms: qn([ar.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatMapTransform: {
				value: new pt
			},
			clearcoatNormalMap: {
				value: null
			},
			clearcoatNormalMapTransform: {
				value: new pt
			},
			clearcoatNormalScale: {
				value: new Ce(1, 1)
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatRoughnessMapTransform: {
				value: new pt
			},
			iridescence: {
				value: 0
			},
			iridescenceMap: {
				value: null
			},
			iridescenceMapTransform: {
				value: new pt
			},
			iridescenceIOR: {
				value: 1.3
			},
			iridescenceThicknessMinimum: {
				value: 100
			},
			iridescenceThicknessMaximum: {
				value: 400
			},
			iridescenceThicknessMap: {
				value: null
			},
			iridescenceThicknessMapTransform: {
				value: new pt
			},
			sheen: {
				value: 0
			},
			sheenColor: {
				value: new qe(0)
			},
			sheenColorMap: {
				value: null
			},
			sheenColorMapTransform: {
				value: new pt
			},
			sheenRoughness: {
				value: 1
			},
			sheenRoughnessMap: {
				value: null
			},
			sheenRoughnessMapTransform: {
				value: new pt
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			},
			transmissionMapTransform: {
				value: new pt
			},
			transmissionSamplerSize: {
				value: new Ce
			},
			transmissionSamplerMap: {
				value: null
			},
			thickness: {
				value: 0
			},
			thicknessMap: {
				value: null
			},
			thicknessMapTransform: {
				value: new pt
			},
			attenuationDistance: {
				value: 0
			},
			attenuationColor: {
				value: new qe(0)
			},
			specularColor: {
				value: new qe(1, 1, 1)
			},
			specularColorMap: {
				value: null
			},
			specularColorMapTransform: {
				value: new pt
			},
			specularIntensity: {
				value: 1
			},
			specularIntensityMap: {
				value: null
			},
			specularIntensityMapTransform: {
				value: new pt
			},
			anisotropyVector: {
				value: new Ce
			},
			anisotropyMap: {
				value: null
			},
			anisotropyMapTransform: {
				value: new pt
			}
		}]),
		vertexShader: Tt.meshphysical_vert,
		fragmentShader: Tt.meshphysical_frag
	};
	var iu = {
		r: 0,
		b: 0,
		g: 0
	};

	function pT(r, e, t, n, i, s, o) {
		let a = new qe(0),
			l = s === !0 ? 0 : 1,
			c, u, h = null,
			f = 0,
			m = null;

		function g(d, p) {
			let _ = !1,
				v = p.isScene === !0 ? p.background : null;
			switch (v && v.isTexture && (v = (p.backgroundBlurriness > 0 ? t : e).get(v)), v === null ? y(a, l) : v && v.isColor && (y(v, 1), _ = !0), r.xr.getEnvironmentBlendMode()) {
				case "opaque":
					_ = !0;
					break;
				case "additive":
					n.buffers.color.setClear(0, 0, 0, 1, o), _ = !0;
					break;
				case "alpha-blend":
					n.buffers.color.setClear(0, 0, 0, 0, o), _ = !0;
					break
			}(r.autoClear || _) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil), v && (v.isCubeTexture || v.mapping === Bu) ? (u === void 0 && (u = new Nt(new Xs(1, 1, 1), new kr({
				name: "BackgroundCubeMaterial",
				uniforms: aa(ar.backgroundCube.uniforms),
				vertexShader: ar.backgroundCube.vertexShader,
				fragmentShader: ar.backgroundCube.fragmentShader,
				side: gn,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(I, w, L) {
				this.matrixWorld.copyPosition(L.matrixWorld)
			}, Object.defineProperty(u.material, "envMap", {
				get: function() {
					return this.uniforms.envMap.value
				}
			}), i.update(u)), u.material.uniforms.envMap.value = v, u.material.uniforms.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = p.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, u.material.toneMapped = v.colorSpace !== ot, (h !== v || f !== v.version || m !== r.toneMapping) && (u.material.needsUpdate = !0, h = v, f = v.version, m = r.toneMapping), u.layers.enableAll(), d.unshift(u, u.geometry, u.material, 0, 0, null)) : v && v.isTexture && (c === void 0 && (c = new Nt(new Pl(2, 2), new kr({
				name: "BackgroundMaterial",
				uniforms: aa(ar.background.uniforms),
				vertexShader: ar.background.vertexShader,
				fragmentShader: ar.background.fragmentShader,
				side: _i,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
				get: function() {
					return this.uniforms.t2D.value
				}
			}), i.update(c)), c.material.uniforms.t2D.value = v, c.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, c.material.toneMapped = v.colorSpace !== ot, v.matrixAutoUpdate === !0 && v.updateMatrix(), c.material.uniforms.uvTransform.value.copy(v.matrix), (h !== v || f !== v.version || m !== r.toneMapping) && (c.material.needsUpdate = !0, h = v, f = v.version, m = r.toneMapping), c.layers.enableAll(), d.unshift(c, c.geometry, c.material, 0, 0, null))
		}

		function y(d, p) {
			d.getRGB(iu, Pg(r)), n.buffers.color.setClear(iu.r, iu.g, iu.b, p, o)
		}
		return {
			getClearColor: function() {
				return a
			},
			setClearColor: function(d, p = 1) {
				a.set(d), l = p, y(a, l)
			},
			getClearAlpha: function() {
				return l
			},
			setClearAlpha: function(d) {
				l = d, y(a, l)
			},
			render: g
		}
	}

	function mT(r, e, t, n) {
		let i = r.getParameter(r.MAX_VERTEX_ATTRIBS),
			s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
			o = n.isWebGL2 || s !== null,
			a = {},
			l = d(null),
			c = l,
			u = !1;

		function h(U, K, Z, Y, H) {
			let oe = !1;
			if (o) {
				let de = y(Y, Z, K);
				c !== de && (c = de, m(c.object)), oe = p(U, Y, Z, H), oe && _(U, Y, Z, H)
			} else {
				let de = K.wireframe === !0;
				(c.geometry !== Y.id || c.program !== Z.id || c.wireframe !== de) && (c.geometry = Y.id, c.program = Z.id, c.wireframe = de, oe = !0)
			}
			H !== null && t.update(H, r.ELEMENT_ARRAY_BUFFER), (oe || u) && (u = !1, L(U, K, Z, Y), H !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(H).buffer))
		}

		function f() {
			return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES()
		}

		function m(U) {
			return n.isWebGL2 ? r.bindVertexArray(U) : s.bindVertexArrayOES(U)
		}

		function g(U) {
			return n.isWebGL2 ? r.deleteVertexArray(U) : s.deleteVertexArrayOES(U)
		}

		function y(U, K, Z) {
			let Y = Z.wireframe === !0,
				H = a[U.id];
			H === void 0 && (H = {}, a[U.id] = H);
			let oe = H[K.id];
			oe === void 0 && (oe = {}, H[K.id] = oe);
			let de = oe[Y];
			return de === void 0 && (de = d(f()), oe[Y] = de), de
		}

		function d(U) {
			let K = [],
				Z = [],
				Y = [];
			for (let H = 0; H < i; H++) K[H] = 0, Z[H] = 0, Y[H] = 0;
			return {
				geometry: null,
				program: null,
				wireframe: !1,
				newAttributes: K,
				enabledAttributes: Z,
				attributeDivisors: Y,
				object: U,
				attributes: {},
				index: null
			}
		}

		function p(U, K, Z, Y) {
			let H = c.attributes,
				oe = K.attributes,
				de = 0,
				te = Z.getAttributes();
			for (let fe in te)
				if (te[fe].location >= 0) {
					let P = H[fe],
						b = oe[fe];
					if (b === void 0 && (fe === "instanceMatrix" && U.instanceMatrix && (b = U.instanceMatrix), fe === "instanceColor" && U.instanceColor && (b = U.instanceColor)), P === void 0 || P.attribute !== b || b && P.data !== b.data) return !0;
					de++
				} return c.attributesNum !== de || c.index !== Y
		}

		function _(U, K, Z, Y) {
			let H = {},
				oe = K.attributes,
				de = 0,
				te = Z.getAttributes();
			for (let fe in te)
				if (te[fe].location >= 0) {
					let P = oe[fe];
					P === void 0 && (fe === "instanceMatrix" && U.instanceMatrix && (P = U.instanceMatrix), fe === "instanceColor" && U.instanceColor && (P = U.instanceColor));
					let b = {};
					b.attribute = P, P && P.data && (b.data = P.data), H[fe] = b, de++
				} c.attributes = H, c.attributesNum = de, c.index = Y
		}

		function v() {
			let U = c.newAttributes;
			for (let K = 0, Z = U.length; K < Z; K++) U[K] = 0
		}

		function x(U) {
			M(U, 0)
		}

		function M(U, K) {
			let Z = c.newAttributes,
				Y = c.enabledAttributes,
				H = c.attributeDivisors;
			Z[U] = 1, Y[U] === 0 && (r.enableVertexAttribArray(U), Y[U] = 1), H[U] !== K && ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](U, K), H[U] = K)
		}

		function I() {
			let U = c.newAttributes,
				K = c.enabledAttributes;
			for (let Z = 0, Y = K.length; Z < Y; Z++) K[Z] !== U[Z] && (r.disableVertexAttribArray(Z), K[Z] = 0)
		}

		function w(U, K, Z, Y, H, oe, de) {
			de === !0 ? r.vertexAttribIPointer(U, K, Z, H, oe) : r.vertexAttribPointer(U, K, Z, Y, H, oe)
		}

		function L(U, K, Z, Y) {
			if (n.isWebGL2 === !1 && (U.isInstancedMesh || Y.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
			v();
			let H = Y.attributes,
				oe = Z.getAttributes(),
				de = K.defaultAttributeValues;
			for (let te in oe) {
				let fe = oe[te];
				if (fe.location >= 0) {
					let me = H[te];
					if (me === void 0 && (te === "instanceMatrix" && U.instanceMatrix && (me = U.instanceMatrix), te === "instanceColor" && U.instanceColor && (me = U.instanceColor)), me !== void 0) {
						let P = me.normalized,
							b = me.itemSize,
							S = t.get(me);
						if (S === void 0) continue;
						let A = S.buffer,
							G = S.type,
							J = S.bytesPerElement,
							$ = n.isWebGL2 === !0 && (G === r.INT || G === r.UNSIGNED_INT || me.gpuType === _g);
						if (me.isInterleavedBufferAttribute) {
							let le = me.data,
								N = le.stride,
								pe = me.offset;
							if (le.isInstancedInterleavedBuffer) {
								for (let Q = 0; Q < fe.locationSize; Q++) M(fe.location + Q, le.meshPerAttribute);
								U.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = le.meshPerAttribute * le.count)
							} else
								for (let Q = 0; Q < fe.locationSize; Q++) x(fe.location + Q);
							r.bindBuffer(r.ARRAY_BUFFER, A);
							for (let Q = 0; Q < fe.locationSize; Q++) w(fe.location + Q, b / fe.locationSize, G, P, N * J, (pe + b / fe.locationSize * Q) * J, $)
						} else {
							if (me.isInstancedBufferAttribute) {
								for (let le = 0; le < fe.locationSize; le++) M(fe.location + le, me.meshPerAttribute);
								U.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = me.meshPerAttribute * me.count)
							} else
								for (let le = 0; le < fe.locationSize; le++) x(fe.location + le);
							r.bindBuffer(r.ARRAY_BUFFER, A);
							for (let le = 0; le < fe.locationSize; le++) w(fe.location + le, b / fe.locationSize, G, P, b * J, b / fe.locationSize * le * J, $)
						}
					} else if (de !== void 0) {
						let P = de[te];
						if (P !== void 0) switch (P.length) {
							case 2:
								r.vertexAttrib2fv(fe.location, P);
								break;
							case 3:
								r.vertexAttrib3fv(fe.location, P);
								break;
							case 4:
								r.vertexAttrib4fv(fe.location, P);
								break;
							default:
								r.vertexAttrib1fv(fe.location, P)
						}
					}
				}
			}
			I()
		}

		function T() {
			k();
			for (let U in a) {
				let K = a[U];
				for (let Z in K) {
					let Y = K[Z];
					for (let H in Y) g(Y[H].object), delete Y[H];
					delete K[Z]
				}
				delete a[U]
			}
		}

		function C(U) {
			if (a[U.id] === void 0) return;
			let K = a[U.id];
			for (let Z in K) {
				let Y = K[Z];
				for (let H in Y) g(Y[H].object), delete Y[H];
				delete K[Z]
			}
			delete a[U.id]
		}

		function V(U) {
			for (let K in a) {
				let Z = a[K];
				if (Z[U.id] === void 0) continue;
				let Y = Z[U.id];
				for (let H in Y) g(Y[H].object), delete Y[H];
				delete Z[U.id]
			}
		}

		function k() {
			F(), u = !0, c !== l && (c = l, m(c.object))
		}

		function F() {
			l.geometry = null, l.program = null, l.wireframe = !1
		}
		return {
			setup: h,
			reset: k,
			resetDefaultState: F,
			dispose: T,
			releaseStatesOfGeometry: C,
			releaseStatesOfProgram: V,
			initAttributes: v,
			enableAttribute: x,
			disableUnusedAttributes: I
		}
	}

	function gT(r, e, t, n) {
		let i = n.isWebGL2,
			s;

		function o(c) {
			s = c
		}

		function a(c, u) {
			r.drawArrays(s, c, u), t.update(u, s, 1)
		}

		function l(c, u, h) {
			if (h === 0) return;
			let f, m;
			if (i) f = r, m = "drawArraysInstanced";
			else if (f = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", f === null) {
				console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			f[m](s, c, u, h), t.update(u, s, h)
		}
		this.setMode = o, this.render = a, this.renderInstances = l
	}

	function yT(r, e, t) {
		let n;

		function i() {
			if (n !== void 0) return n;
			if (e.has("EXT_texture_filter_anisotropic") === !0) {
				let w = e.get("EXT_texture_filter_anisotropic");
				n = r.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
			} else n = 0;
			return n
		}

		function s(w) {
			if (w === "highp") {
				if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp";
				w = "mediump"
			}
			return w === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
		}
		let o = typeof WebGL2RenderingContext < "u" && r.constructor.name === "WebGL2RenderingContext",
			a = t.precision !== void 0 ? t.precision : "highp",
			l = s(a);
		l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
		let c = o || e.has("WEBGL_draw_buffers"),
			u = t.logarithmicDepthBuffer === !0,
			h = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
			f = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
			m = r.getParameter(r.MAX_TEXTURE_SIZE),
			g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
			y = r.getParameter(r.MAX_VERTEX_ATTRIBS),
			d = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
			p = r.getParameter(r.MAX_VARYING_VECTORS),
			_ = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
			v = f > 0,
			x = o || e.has("OES_texture_float"),
			M = v && x,
			I = o ? r.getParameter(r.MAX_SAMPLES) : 0;
		return {
			isWebGL2: o,
			drawBuffers: c,
			getMaxAnisotropy: i,
			getMaxPrecision: s,
			precision: a,
			logarithmicDepthBuffer: u,
			maxTextures: h,
			maxVertexTextures: f,
			maxTextureSize: m,
			maxCubemapSize: g,
			maxAttributes: y,
			maxVertexUniforms: d,
			maxVaryings: p,
			maxFragmentUniforms: _,
			vertexTextures: v,
			floatFragmentTextures: x,
			floatVertexTextures: M,
			maxSamples: I
		}
	}

	function vT(r) {
		let e = this,
			t = null,
			n = 0,
			i = !1,
			s = !1,
			o = new Nr,
			a = new pt,
			l = {
				value: null,
				needsUpdate: !1
			};
		this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, f) {
			let m = h.length !== 0 || f || n !== 0 || i;
			return i = f, n = h.length, m
		}, this.beginShadows = function() {
			s = !0, u(null)
		}, this.endShadows = function() {
			s = !1
		}, this.setGlobalState = function(h, f) {
			t = u(h, f, 0)
		}, this.setState = function(h, f, m) {
			let g = h.clippingPlanes,
				y = h.clipIntersection,
				d = h.clipShadows,
				p = r.get(h);
			if (!i || g === null || g.length === 0 || s && !d) s ? u(null) : c();
			else {
				let _ = s ? 0 : n,
					v = _ * 4,
					x = p.clippingState || null;
				l.value = x, x = u(g, f, v, m);
				for (let M = 0; M !== v; ++M) x[M] = t[M];
				p.clippingState = x, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += _
			}
		};

		function c() {
			l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
		}

		function u(h, f, m, g) {
			let y = h !== null ? h.length : 0,
				d = null;
			if (y !== 0) {
				if (d = l.value, g !== !0 || d === null) {
					let p = m + y * 4,
						_ = f.matrixWorldInverse;
					a.getNormalMatrix(_), (d === null || d.length < p) && (d = new Float32Array(p));
					for (let v = 0, x = m; v !== y; ++v, x += 4) o.copy(h[v]).applyMatrix4(_, a), o.normal.toArray(d, x), d[x + 3] = o.constant
				}
				l.value = d, l.needsUpdate = !0
			}
			return e.numPlanes = y, e.numIntersection = 0, d
		}
	}

	function xT(r) {
		let e = new WeakMap;

		function t(o, a) {
			return a === Sl ? o.mapping = ta : a === df && (o.mapping = na), o
		}

		function n(o) {
			if (o && o.isTexture && o.isRenderTargetTexture === !1) {
				let a = o.mapping;
				if (a === Sl || a === df)
					if (e.has(o)) {
						let l = e.get(o).texture;
						return t(l, o.mapping)
					} else {
						let l = o.image;
						if (l && l.height > 0) {
							let c = new vf(l.height / 2);
							return c.fromEquirectangularTexture(r, o), e.set(o, c), o.addEventListener("dispose", i), t(c.texture, o.mapping)
						} else return null
					}
			}
			return o
		}

		function i(o) {
			let a = o.target;
			a.removeEventListener("dispose", i);
			let l = e.get(a);
			l !== void 0 && (e.delete(a), l.dispose())
		}

		function s() {
			e = new WeakMap
		}
		return {
			get: n,
			dispose: s
		}
	}
	var cr = class extends Eu {
			constructor(e = -1, t = 1, n = 1, i = -1, s = .1, o = 2e3) {
				super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = s, this.far = o, this.updateProjectionMatrix()
			}
			copy(e, t) {
				return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
			}
			setViewOffset(e, t, n, i, s, o) {
				this.view === null && (this.view = {
					enabled: !0,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
			}
			clearViewOffset() {
				this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
			}
			updateProjectionMatrix() {
				let e = (this.right - this.left) / (2 * this.zoom),
					t = (this.top - this.bottom) / (2 * this.zoom),
					n = (this.right + this.left) / 2,
					i = (this.top + this.bottom) / 2,
					s = n - e,
					o = n + e,
					a = i + t,
					l = i - t;
				if (this.view !== null && this.view.enabled) {
					let c = (this.right - this.left) / this.view.fullWidth / this.zoom,
						u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
					s += c * this.view.offsetX, o = s + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height
				}
				this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
			}
			toJSON(e) {
				let t = super.toJSON(e);
				return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
			}
		},
		Ko = 4,
		Am = [.125, .215, .35, .446, .526, .582],
		Us = 20,
		Qh = new cr,
		wm = new qe,
		ef = null,
		Fs = (1 + Math.sqrt(5)) / 2,
		qo = 1 / Fs,
		Cm = [new re(1, 1, 1), new re(-1, 1, 1), new re(1, 1, -1), new re(-1, 1, -1), new re(0, Fs, qo), new re(0, Fs, -qo), new re(qo, 0, Fs), new re(-qo, 0, Fs), new re(Fs, qo, 0), new re(-Fs, qo, 0)],
		Mu = class {
			constructor(e) {
				this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
			}
			fromScene(e, t = 0, n = .1, i = 100) {
				ef = this._renderer.getRenderTarget(), this._setSize(256);
				let s = this._allocateTargets();
				return s.depthBuffer = !0, this._sceneToCubeUV(e, n, i, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s
			}
			fromEquirectangular(e, t = null) {
				return this._fromTexture(e, t)
			}
			fromCubemap(e, t = null) {
				return this._fromTexture(e, t)
			}
			compileCubemapShader() {
				this._cubemapMaterial === null && (this._cubemapMaterial = Pm(), this._compileMaterial(this._cubemapMaterial))
			}
			compileEquirectangularShader() {
				this._equirectMaterial === null && (this._equirectMaterial = Im(), this._compileMaterial(this._equirectMaterial))
			}
			dispose() {
				this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
			}
			_setSize(e) {
				this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
			}
			_dispose() {
				this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
				for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
			}
			_cleanup(e) {
				this._renderer.setRenderTarget(ef), e.scissorTest = !1, ru(e, 0, 0, e.width, e.height)
			}
			_fromTexture(e, t) {
				e.mapping === ta || e.mapping === na ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), ef = this._renderer.getRenderTarget();
				let n = t || this._allocateTargets();
				return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
			}
			_allocateTargets() {
				let e = 3 * Math.max(this._cubeSize, 112),
					t = 4 * this._cubeSize,
					n = {
						magFilter: mn,
						minFilter: mn,
						generateMipmaps: !1,
						type: Al,
						format: xi,
						colorSpace: Bn,
						depthBuffer: !1
					},
					i = Rm(e, t, n);
				if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
					this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Rm(e, t, n);
					let {
						_lodMax: s
					} = this;
					({
						sizeLods: this._sizeLods,
						lodPlanes: this._lodPlanes,
						sigmas: this._sigmas
					} = _T(s)), this._blurMaterial = TT(s, e, t)
				}
				return i
			}
			_compileMaterial(e) {
				let t = new Nt(this._lodPlanes[0], e);
				this._renderer.compile(t, Qh)
			}
			_sceneToCubeUV(e, t, n, i) {
				let a = new Yt(90, 1, t, n),
					l = [1, -1, 1, 1, 1, 1],
					c = [1, 1, 1, -1, -1, -1],
					u = this._renderer,
					h = u.autoClear,
					f = u.toneMapping;
				u.getClearColor(wm), u.toneMapping = Fr, u.autoClear = !1;
				let m = new Ti({
						name: "PMREM.Background",
						side: gn,
						depthWrite: !1,
						depthTest: !1
					}),
					g = new Nt(new Xs, m),
					y = !1,
					d = e.background;
				d ? d.isColor && (m.color.copy(d), e.background = null, y = !0) : (m.color.copy(wm), y = !0);
				for (let p = 0; p < 6; p++) {
					let _ = p % 3;
					_ === 0 ? (a.up.set(0, l[p], 0), a.lookAt(c[p], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[p]), a.lookAt(0, c[p], 0)) : (a.up.set(0, l[p], 0), a.lookAt(0, 0, c[p]));
					let v = this._cubeSize;
					ru(i, _ * v, p > 2 ? v : 0, v, v), u.setRenderTarget(i), y && u.render(g, a), u.render(e, a)
				}
				g.geometry.dispose(), g.material.dispose(), u.toneMapping = f, u.autoClear = h, e.background = d
			}
			_textureToCubeUV(e, t) {
				let n = this._renderer,
					i = e.mapping === ta || e.mapping === na;
				i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Pm()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Im());
				let s = i ? this._cubemapMaterial : this._equirectMaterial,
					o = new Nt(this._lodPlanes[0], s),
					a = s.uniforms;
				a.envMap.value = e;
				let l = this._cubeSize;
				ru(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, Qh)
			}
			_applyPMREM(e) {
				let t = this._renderer,
					n = t.autoClear;
				t.autoClear = !1;
				for (let i = 1; i < this._lodPlanes.length; i++) {
					let s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]),
						o = Cm[(i - 1) % Cm.length];
					this._blur(e, i - 1, i, s, o)
				}
				t.autoClear = n
			}
			_blur(e, t, n, i, s) {
				let o = this._pingPongRenderTarget;
				this._halfBlur(e, o, t, n, i, "latitudinal", s), this._halfBlur(o, e, n, n, i, "longitudinal", s)
			}
			_halfBlur(e, t, n, i, s, o, a) {
				let l = this._renderer,
					c = this._blurMaterial;
				o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
				let u = 3,
					h = new Nt(this._lodPlanes[i], c),
					f = c.uniforms,
					m = this._sizeLods[n] - 1,
					g = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Us - 1),
					y = s / g,
					d = isFinite(s) ? 1 + Math.floor(u * y) : Us;
				d > Us && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${d} samples when the maximum is set to ${Us}`);
				let p = [],
					_ = 0;
				for (let w = 0; w < Us; ++w) {
					let L = w / y,
						T = Math.exp(-L * L / 2);
					p.push(T), w === 0 ? _ += T : w < d && (_ += 2 * T)
				}
				for (let w = 0; w < p.length; w++) p[w] = p[w] / _;
				f.envMap.value = e.texture, f.samples.value = d, f.weights.value = p, f.latitudinal.value = o === "latitudinal", a && (f.poleAxis.value = a);
				let {
					_lodMax: v
				} = this;
				f.dTheta.value = g, f.mipInt.value = v - n;
				let x = this._sizeLods[i],
					M = 3 * x * (i > v - Ko ? i - v + Ko : 0),
					I = 4 * (this._cubeSize - x);
				ru(t, M, I, 3 * x, 2 * x), l.setRenderTarget(t), l.render(h, Qh)
			}
		};

	function _T(r) {
		let e = [],
			t = [],
			n = [],
			i = r,
			s = r - Ko + 1 + Am.length;
		for (let o = 0; o < s; o++) {
			let a = Math.pow(2, i);
			t.push(a);
			let l = 1 / a;
			o > r - Ko ? l = Am[o - r + Ko - 1] : o === 0 && (l = 0), n.push(l);
			let c = 1 / (a - 2),
				u = -c,
				h = 1 + c,
				f = [u, u, h, u, h, h, u, u, h, h, u, h],
				m = 6,
				g = 6,
				y = 3,
				d = 2,
				p = 1,
				_ = new Float32Array(y * g * m),
				v = new Float32Array(d * g * m),
				x = new Float32Array(p * g * m);
			for (let I = 0; I < m; I++) {
				let w = I % 3 * 2 / 3 - 1,
					L = I > 2 ? 0 : -1,
					T = [w, L, 0, w + 2 / 3, L, 0, w + 2 / 3, L + 1, 0, w, L, 0, w + 2 / 3, L + 1, 0, w, L + 1, 0];
				_.set(T, y * g * I), v.set(f, d * g * I);
				let C = [I, I, I, I, I, I];
				x.set(C, p * g * I)
			}
			let M = new St;
			M.setAttribute("position", new Ln(_, y)), M.setAttribute("uv", new Ln(v, d)), M.setAttribute("faceIndex", new Ln(x, p)), e.push(M), i > Ko && i--
		}
		return {
			lodPlanes: e,
			sizeLods: t,
			sigmas: n
		}
	}

	function Rm(r, e, t) {
		let n = new Ur(r, e, t);
		return n.texture.mapping = Bu, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
	}

	function ru(r, e, t, n, i) {
		r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i)
	}

	function TT(r, e, t) {
		let n = new Float32Array(Us),
			i = new re(0, 1, 0);
		return new kr({
			name: "SphericalGaussianBlur",
			defines: {
				n: Us,
				CUBEUV_TEXEL_WIDTH: 1 / e,
				CUBEUV_TEXEL_HEIGHT: 1 / t,
				CUBEUV_MAX_MIP: `${r}.0`
			},
			uniforms: {
				envMap: {
					value: null
				},
				samples: {
					value: 1
				},
				weights: {
					value: n
				},
				latitudinal: {
					value: !1
				},
				dTheta: {
					value: 0
				},
				mipInt: {
					value: 0
				},
				poleAxis: {
					value: i
				}
			},
			vertexShader: Qf(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
			blending: is,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function Im() {
		return new kr({
			name: "EquirectangularToCubeUV",
			uniforms: {
				envMap: {
					value: null
				}
			},
			vertexShader: Qf(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
			blending: is,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function Pm() {
		return new kr({
			name: "CubemapToCubeUV",
			uniforms: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				}
			},
			vertexShader: Qf(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
			blending: is,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function Qf() {
		return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
	}

	function ET(r) {
		let e = new WeakMap,
			t = null;

		function n(a) {
			if (a && a.isTexture) {
				let l = a.mapping,
					c = l === Sl || l === df,
					u = l === ta || l === na;
				if (c || u)
					if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
						a.needsPMREMUpdate = !1;
						let h = e.get(a);
						return t === null && (t = new Mu(r)), h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h), e.set(a, h), h.texture
					} else {
						if (e.has(a)) return e.get(a).texture;
						{
							let h = a.image;
							if (c && h && h.height > 0 || u && h && i(h)) {
								t === null && (t = new Mu(r));
								let f = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
								return e.set(a, f), a.addEventListener("dispose", s), f.texture
							} else return null
						}
					}
			}
			return a
		}

		function i(a) {
			let l = 0,
				c = 6;
			for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
			return l === c
		}

		function s(a) {
			let l = a.target;
			l.removeEventListener("dispose", s);
			let c = e.get(l);
			c !== void 0 && (e.delete(l), c.dispose())
		}

		function o() {
			e = new WeakMap, t !== null && (t.dispose(), t = null)
		}
		return {
			get: n,
			dispose: o
		}
	}

	function MT(r) {
		let e = {};

		function t(n) {
			if (e[n] !== void 0) return e[n];
			let i;
			switch (n) {
				case "WEBGL_depth_texture":
					i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
					break;
				case "EXT_texture_filter_anisotropic":
					i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
					break;
				case "WEBGL_compressed_texture_s3tc":
					i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
					break;
				case "WEBGL_compressed_texture_pvrtc":
					i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
					break;
				default:
					i = r.getExtension(n)
			}
			return e[n] = i, i
		}
		return {
			has: function(n) {
				return t(n) !== null
			},
			init: function(n) {
				n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture")
			},
			get: function(n) {
				let i = t(n);
				return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i
			}
		}
	}

	function bT(r, e, t, n) {
		let i = {},
			s = new WeakMap;

		function o(h) {
			let f = h.target;
			f.index !== null && e.remove(f.index);
			for (let g in f.attributes) e.remove(f.attributes[g]);
			for (let g in f.morphAttributes) {
				let y = f.morphAttributes[g];
				for (let d = 0, p = y.length; d < p; d++) e.remove(y[d])
			}
			f.removeEventListener("dispose", o), delete i[f.id];
			let m = s.get(f);
			m && (e.remove(m), s.delete(f)), n.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount, t.memory.geometries--
		}

		function a(h, f) {
			return i[f.id] === !0 || (f.addEventListener("dispose", o), i[f.id] = !0, t.memory.geometries++), f
		}

		function l(h) {
			let f = h.attributes;
			for (let g in f) e.update(f[g], r.ARRAY_BUFFER);
			let m = h.morphAttributes;
			for (let g in m) {
				let y = m[g];
				for (let d = 0, p = y.length; d < p; d++) e.update(y[d], r.ARRAY_BUFFER)
			}
		}

		function c(h) {
			let f = [],
				m = h.index,
				g = h.attributes.position,
				y = 0;
			if (m !== null) {
				let _ = m.array;
				y = m.version;
				for (let v = 0, x = _.length; v < x; v += 3) {
					let M = _[v + 0],
						I = _[v + 1],
						w = _[v + 2];
					f.push(M, I, I, w, w, M)
				}
			} else {
				let _ = g.array;
				y = g.version;
				for (let v = 0, x = _.length / 3 - 1; v < x; v += 3) {
					let M = v + 0,
						I = v + 1,
						w = v + 2;
					f.push(M, I, I, w, w, M)
				}
			}
			let d = new(Rg(f) ? Tu : oa)(f, 1);
			d.version = y;
			let p = s.get(h);
			p && e.remove(p), s.set(h, d)
		}

		function u(h) {
			let f = s.get(h);
			if (f) {
				let m = h.index;
				m !== null && f.version < m.version && c(h)
			} else c(h);
			return s.get(h)
		}
		return {
			get: a,
			update: l,
			getWireframeAttribute: u
		}
	}

	function ST(r, e, t, n) {
		let i = n.isWebGL2,
			s;

		function o(f) {
			s = f
		}
		let a, l;

		function c(f) {
			a = f.type, l = f.bytesPerElement
		}

		function u(f, m) {
			r.drawElements(s, m, a, f * l), t.update(m, s, 1)
		}

		function h(f, m, g) {
			if (g === 0) return;
			let y, d;
			if (i) y = r, d = "drawElementsInstanced";
			else if (y = e.get("ANGLE_instanced_arrays"), d = "drawElementsInstancedANGLE", y === null) {
				console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			y[d](s, m, a, f * l, g), t.update(m, s, g)
		}
		this.setMode = o, this.setIndex = c, this.render = u, this.renderInstances = h
	}

	function AT(r) {
		let e = {
				geometries: 0,
				textures: 0
			},
			t = {
				frame: 0,
				calls: 0,
				triangles: 0,
				points: 0,
				lines: 0
			};

		function n(s, o, a) {
			switch (t.calls++, o) {
				case r.TRIANGLES:
					t.triangles += a * (s / 3);
					break;
				case r.LINES:
					t.lines += a * (s / 2);
					break;
				case r.LINE_STRIP:
					t.lines += a * (s - 1);
					break;
				case r.LINE_LOOP:
					t.lines += a * s;
					break;
				case r.POINTS:
					t.points += a * s;
					break;
				default:
					console.error("THREE.WebGLInfo: Unknown draw mode:", o);
					break
			}
		}

		function i() {
			t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
		}
		return {
			memory: e,
			render: t,
			programs: null,
			autoReset: !0,
			reset: i,
			update: n
		}
	}

	function wT(r, e) {
		return r[0] - e[0]
	}

	function CT(r, e) {
		return Math.abs(e[1]) - Math.abs(r[1])
	}

	function RT(r, e, t) {
		let n = {},
			i = new Float32Array(8),
			s = new WeakMap,
			o = new Ct,
			a = [];
		for (let c = 0; c < 8; c++) a[c] = [c, 0];

		function l(c, u, h) {
			let f = c.morphTargetInfluences;
			if (e.isWebGL2 === !0) {
				let m = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
					g = m !== void 0 ? m.length : 0,
					y = s.get(u);
				if (y === void 0 || y.count !== g) {
					let U = function() {
						k.dispose(), s.delete(u), u.removeEventListener("dispose", U)
					};
					y !== void 0 && y.texture.dispose();
					let _ = u.morphAttributes.position !== void 0,
						v = u.morphAttributes.normal !== void 0,
						x = u.morphAttributes.color !== void 0,
						M = u.morphAttributes.position || [],
						I = u.morphAttributes.normal || [],
						w = u.morphAttributes.color || [],
						L = 0;
					_ === !0 && (L = 1), v === !0 && (L = 2), x === !0 && (L = 3);
					let T = u.attributes.position.count * L,
						C = 1;
					T > e.maxTextureSize && (C = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
					let V = new Float32Array(T * C * 4 * g),
						k = new _u(V, T, C, g);
					k.type = Or, k.needsUpdate = !0;
					let F = L * 4;
					for (let K = 0; K < g; K++) {
						let Z = M[K],
							Y = I[K],
							H = w[K],
							oe = T * C * 4 * K;
						for (let de = 0; de < Z.count; de++) {
							let te = de * F;
							_ === !0 && (o.fromBufferAttribute(Z, de), V[oe + te + 0] = o.x, V[oe + te + 1] = o.y, V[oe + te + 2] = o.z, V[oe + te + 3] = 0), v === !0 && (o.fromBufferAttribute(Y, de), V[oe + te + 4] = o.x, V[oe + te + 5] = o.y, V[oe + te + 6] = o.z, V[oe + te + 7] = 0), x === !0 && (o.fromBufferAttribute(H, de), V[oe + te + 8] = o.x, V[oe + te + 9] = o.y, V[oe + te + 10] = o.z, V[oe + te + 11] = H.itemSize === 4 ? o.w : 1)
						}
					}
					y = {
						count: g,
						texture: k,
						size: new Ce(T, C)
					}, s.set(u, y), u.addEventListener("dispose", U)
				}
				let d = 0;
				for (let _ = 0; _ < f.length; _++) d += f[_];
				let p = u.morphTargetsRelative ? 1 : 1 - d;
				h.getUniforms().setValue(r, "morphTargetBaseInfluence", p), h.getUniforms().setValue(r, "morphTargetInfluences", f), h.getUniforms().setValue(r, "morphTargetsTexture", y.texture, t), h.getUniforms().setValue(r, "morphTargetsTextureSize", y.size)
			} else {
				let m = f === void 0 ? 0 : f.length,
					g = n[u.id];
				if (g === void 0 || g.length !== m) {
					g = [];
					for (let v = 0; v < m; v++) g[v] = [v, 0];
					n[u.id] = g
				}
				for (let v = 0; v < m; v++) {
					let x = g[v];
					x[0] = v, x[1] = f[v]
				}
				g.sort(CT);
				for (let v = 0; v < 8; v++) v < m && g[v][1] ? (a[v][0] = g[v][0], a[v][1] = g[v][1]) : (a[v][0] = Number.MAX_SAFE_INTEGER, a[v][1] = 0);
				a.sort(wT);
				let y = u.morphAttributes.position,
					d = u.morphAttributes.normal,
					p = 0;
				for (let v = 0; v < 8; v++) {
					let x = a[v],
						M = x[0],
						I = x[1];
					M !== Number.MAX_SAFE_INTEGER && I ? (y && u.getAttribute("morphTarget" + v) !== y[M] && u.setAttribute("morphTarget" + v, y[M]), d && u.getAttribute("morphNormal" + v) !== d[M] && u.setAttribute("morphNormal" + v, d[M]), i[v] = I, p += I) : (y && u.hasAttribute("morphTarget" + v) === !0 && u.deleteAttribute("morphTarget" + v), d && u.hasAttribute("morphNormal" + v) === !0 && u.deleteAttribute("morphNormal" + v), i[v] = 0)
				}
				let _ = u.morphTargetsRelative ? 1 : 1 - p;
				h.getUniforms().setValue(r, "morphTargetBaseInfluence", _), h.getUniforms().setValue(r, "morphTargetInfluences", i)
			}
		}
		return {
			update: l
		}
	}

	function IT(r, e, t, n) {
		let i = new WeakMap;

		function s(l) {
			let c = n.render.frame,
				u = l.geometry,
				h = e.get(l, u);
			if (i.get(h) !== c && (e.update(h), i.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== c && (t.update(l.instanceMatrix, r.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, r.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
				let f = l.skeleton;
				i.get(f) !== c && (f.update(), i.set(f, c))
			}
			return h
		}

		function o() {
			i = new WeakMap
		}

		function a(l) {
			let c = l.target;
			c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
		}
		return {
			update: s,
			dispose: o
		}
	}
	var Ng = new Gn,
		Og = new _u,
		Dg = new gf,
		Fg = new Rl,
		Lm = [],
		Nm = [],
		Om = new Float32Array(16),
		Dm = new Float32Array(9),
		Fm = new Float32Array(4);

	function ga(r, e, t) {
		let n = r[0];
		if (n <= 0 || n > 0) return r;
		let i = e * t,
			s = Lm[i];
		if (s === void 0 && (s = new Float32Array(i), Lm[i] = s), e !== 0) {
			n.toArray(s, 0);
			for (let o = 1, a = 0; o !== e; ++o) a += t, r[o].toArray(s, a)
		}
		return s
	}

	function _n(r, e) {
		if (r.length !== e.length) return !1;
		for (let t = 0, n = r.length; t < n; t++)
			if (r[t] !== e[t]) return !1;
		return !0
	}

	function Tn(r, e) {
		for (let t = 0, n = e.length; t < n; t++) r[t] = e[t]
	}

	function Vu(r, e) {
		let t = Nm[e];
		t === void 0 && (t = new Int32Array(e), Nm[e] = t);
		for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
		return t
	}

	function PT(r, e) {
		let t = this.cache;
		t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e)
	}

	function LT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
		else {
			if (_n(t, e)) return;
			r.uniform2fv(this.addr, e), Tn(t, e)
		}
	}

	function NT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
		else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
		else {
			if (_n(t, e)) return;
			r.uniform3fv(this.addr, e), Tn(t, e)
		}
	}

	function OT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
		else {
			if (_n(t, e)) return;
			r.uniform4fv(this.addr, e), Tn(t, e)
		}
	}

	function DT(r, e) {
		let t = this.cache,
			n = e.elements;
		if (n === void 0) {
			if (_n(t, e)) return;
			r.uniformMatrix2fv(this.addr, !1, e), Tn(t, e)
		} else {
			if (_n(t, n)) return;
			Fm.set(n), r.uniformMatrix2fv(this.addr, !1, Fm), Tn(t, n)
		}
	}

	function FT(r, e) {
		let t = this.cache,
			n = e.elements;
		if (n === void 0) {
			if (_n(t, e)) return;
			r.uniformMatrix3fv(this.addr, !1, e), Tn(t, e)
		} else {
			if (_n(t, n)) return;
			Dm.set(n), r.uniformMatrix3fv(this.addr, !1, Dm), Tn(t, n)
		}
	}

	function UT(r, e) {
		let t = this.cache,
			n = e.elements;
		if (n === void 0) {
			if (_n(t, e)) return;
			r.uniformMatrix4fv(this.addr, !1, e), Tn(t, e)
		} else {
			if (_n(t, n)) return;
			Om.set(n), r.uniformMatrix4fv(this.addr, !1, Om), Tn(t, n)
		}
	}

	function kT(r, e) {
		let t = this.cache;
		t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e)
	}

	function BT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
		else {
			if (_n(t, e)) return;
			r.uniform2iv(this.addr, e), Tn(t, e)
		}
	}

	function GT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
		else {
			if (_n(t, e)) return;
			r.uniform3iv(this.addr, e), Tn(t, e)
		}
	}

	function VT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
		else {
			if (_n(t, e)) return;
			r.uniform4iv(this.addr, e), Tn(t, e)
		}
	}

	function zT(r, e) {
		let t = this.cache;
		t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e)
	}

	function HT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
		else {
			if (_n(t, e)) return;
			r.uniform2uiv(this.addr, e), Tn(t, e)
		}
	}

	function WT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
		else {
			if (_n(t, e)) return;
			r.uniform3uiv(this.addr, e), Tn(t, e)
		}
	}

	function XT(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
		else {
			if (_n(t, e)) return;
			r.uniform4uiv(this.addr, e), Tn(t, e)
		}
	}

	function qT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2D(e || Ng, i)
	}

	function jT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || Dg, i)
	}

	function YT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || Fg, i)
	}

	function KT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || Og, i)
	}

	function ZT(r) {
		switch (r) {
			case 5126:
				return PT;
			case 35664:
				return LT;
			case 35665:
				return NT;
			case 35666:
				return OT;
			case 35674:
				return DT;
			case 35675:
				return FT;
			case 35676:
				return UT;
			case 5124:
			case 35670:
				return kT;
			case 35667:
			case 35671:
				return BT;
			case 35668:
			case 35672:
				return GT;
			case 35669:
			case 35673:
				return VT;
			case 5125:
				return zT;
			case 36294:
				return HT;
			case 36295:
				return WT;
			case 36296:
				return XT;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return qT;
			case 35679:
			case 36299:
			case 36307:
				return jT;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return YT;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return KT
		}
	}

	function JT(r, e) {
		r.uniform1fv(this.addr, e)
	}

	function $T(r, e) {
		let t = ga(e, this.size, 2);
		r.uniform2fv(this.addr, t)
	}

	function QT(r, e) {
		let t = ga(e, this.size, 3);
		r.uniform3fv(this.addr, t)
	}

	function eE(r, e) {
		let t = ga(e, this.size, 4);
		r.uniform4fv(this.addr, t)
	}

	function tE(r, e) {
		let t = ga(e, this.size, 4);
		r.uniformMatrix2fv(this.addr, !1, t)
	}

	function nE(r, e) {
		let t = ga(e, this.size, 9);
		r.uniformMatrix3fv(this.addr, !1, t)
	}

	function iE(r, e) {
		let t = ga(e, this.size, 16);
		r.uniformMatrix4fv(this.addr, !1, t)
	}

	function rE(r, e) {
		r.uniform1iv(this.addr, e)
	}

	function sE(r, e) {
		r.uniform2iv(this.addr, e)
	}

	function oE(r, e) {
		r.uniform3iv(this.addr, e)
	}

	function aE(r, e) {
		r.uniform4iv(this.addr, e)
	}

	function lE(r, e) {
		r.uniform1uiv(this.addr, e)
	}

	function cE(r, e) {
		r.uniform2uiv(this.addr, e)
	}

	function uE(r, e) {
		r.uniform3uiv(this.addr, e)
	}

	function hE(r, e) {
		r.uniform4uiv(this.addr, e)
	}

	function fE(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Vu(t, i);
		_n(n, s) || (r.uniform1iv(this.addr, s), Tn(n, s));
		for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || Ng, s[o])
	}

	function dE(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Vu(t, i);
		_n(n, s) || (r.uniform1iv(this.addr, s), Tn(n, s));
		for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || Dg, s[o])
	}

	function pE(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Vu(t, i);
		_n(n, s) || (r.uniform1iv(this.addr, s), Tn(n, s));
		for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || Fg, s[o])
	}

	function mE(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Vu(t, i);
		_n(n, s) || (r.uniform1iv(this.addr, s), Tn(n, s));
		for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || Og, s[o])
	}

	function gE(r) {
		switch (r) {
			case 5126:
				return JT;
			case 35664:
				return $T;
			case 35665:
				return QT;
			case 35666:
				return eE;
			case 35674:
				return tE;
			case 35675:
				return nE;
			case 35676:
				return iE;
			case 5124:
			case 35670:
				return rE;
			case 35667:
			case 35671:
				return sE;
			case 35668:
			case 35672:
				return oE;
			case 35669:
			case 35673:
				return aE;
			case 5125:
				return lE;
			case 36294:
				return cE;
			case 36295:
				return uE;
			case 36296:
				return hE;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return fE;
			case 35679:
			case 36299:
			case 36307:
				return dE;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return pE;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return mE
		}
	}
	var xf = class {
			constructor(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.setValue = ZT(t.type)
			}
		},
		_f = class {
			constructor(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = gE(t.type)
			}
		},
		Tf = class {
			constructor(e) {
				this.id = e, this.seq = [], this.map = {}
			}
			setValue(e, t, n) {
				let i = this.seq;
				for (let s = 0, o = i.length; s !== o; ++s) {
					let a = i[s];
					a.setValue(e, t[a.id], n)
				}
			}
		},
		tf = /(\w+)(\])?(\[|\.)?/g;

	function Um(r, e) {
		r.seq.push(e), r.map[e.id] = e
	}

	function yE(r, e, t) {
		let n = r.name,
			i = n.length;
		for (tf.lastIndex = 0;;) {
			let s = tf.exec(n),
				o = tf.lastIndex,
				a = s[1],
				l = s[2] === "]",
				c = s[3];
			if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === i) {
				Um(t, c === void 0 ? new xf(a, r, e) : new _f(a, r, e));
				break
			} else {
				let h = t.map[a];
				h === void 0 && (h = new Tf(a), Um(t, h)), t = h
			}
		}
	}
	var ea = class {
		constructor(e, t) {
			this.seq = [], this.map = {};
			let n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
			for (let i = 0; i < n; ++i) {
				let s = e.getActiveUniform(t, i),
					o = e.getUniformLocation(t, s.name);
				yE(s, o, this)
			}
		}
		setValue(e, t, n, i) {
			let s = this.map[t];
			s !== void 0 && s.setValue(e, n, i)
		}
		setOptional(e, t, n) {
			let i = t[n];
			i !== void 0 && this.setValue(e, n, i)
		}
		static upload(e, t, n, i) {
			for (let s = 0, o = t.length; s !== o; ++s) {
				let a = t[s],
					l = n[a.id];
				l.needsUpdate !== !1 && a.setValue(e, l.value, i)
			}
		}
		static seqWithValue(e, t) {
			let n = [];
			for (let i = 0, s = e.length; i !== s; ++i) {
				let o = e[i];
				o.id in t && n.push(o)
			}
			return n
		}
	};

	function km(r, e, t) {
		let n = r.createShader(e);
		return r.shaderSource(n, t), r.compileShader(n), n
	}
	var vE = 0;

	function xE(r, e) {
		let t = r.split(`
`),
			n = [],
			i = Math.max(e - 6, 0),
			s = Math.min(e + 6, t.length);
		for (let o = i; o < s; o++) {
			let a = o + 1;
			n.push(`${a===e?">":" "} ${a}: ${t[o]}`)
		}
		return n.join(`
`)
	}

	function _E(r) {
		switch (r) {
			case Bn:
				return ["Linear", "( value )"];
			case ot:
				return ["sRGB", "( value )"];
			default:
				return console.warn("THREE.WebGLProgram: Unsupported color space:", r), ["Linear", "( value )"]
		}
	}

	function Bm(r, e, t) {
		let n = r.getShaderParameter(e, r.COMPILE_STATUS),
			i = r.getShaderInfoLog(e).trim();
		if (n && i === "") return "";
		let s = /ERROR: 0:(\d+)/.exec(i);
		if (s) {
			let o = parseInt(s[1]);
			return t.toUpperCase() + `

` + i + `

` + xE(r.getShaderSource(e), o)
		} else return i
	}

	function TE(r, e) {
		let t = _E(e);
		return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
	}

	function EE(r, e) {
		let t;
		switch (e) {
			case Sy:
				t = "Linear";
				break;
			case Ay:
				t = "Reinhard";
				break;
			case wy:
				t = "OptimizedCineon";
				break;
			case Cy:
				t = "ACESFilmic";
				break;
			case Ry:
				t = "Custom";
				break;
			default:
				console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
		}
		return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
	}

	function ME(r) {
		return [r.extensionDerivatives || r.envMapCubeUVHeight || r.bumpMap || r.normalMapTangentSpace || r.clearcoatNormalMap || r.flatShading || r.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (r.extensionFragDepth || r.logarithmicDepthBuffer) && r.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", r.extensionDrawBuffers && r.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (r.extensionShaderTextureLOD || r.envMap || r.transmission) && r.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xl).join(`
`)
	}

	function bE(r) {
		let e = [];
		for (let t in r) {
			let n = r[t];
			n !== !1 && e.push("#define " + t + " " + n)
		}
		return e.join(`
`)
	}

	function SE(r, e) {
		let t = {},
			n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
		for (let i = 0; i < n; i++) {
			let s = r.getActiveAttrib(e, i),
				o = s.name,
				a = 1;
			s.type === r.FLOAT_MAT2 && (a = 2), s.type === r.FLOAT_MAT3 && (a = 3), s.type === r.FLOAT_MAT4 && (a = 4), t[o] = {
				type: s.type,
				location: r.getAttribLocation(e, o),
				locationSize: a
			}
		}
		return t
	}

	function xl(r) {
		return r !== ""
	}

	function Gm(r, e) {
		let t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
		return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
	}

	function Vm(r, e) {
		return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
	}
	var AE = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function Ef(r) {
		return r.replace(AE, CE)
	}
	var wE = new Map([
		["encodings_fragment", "colorspace_fragment"],
		["encodings_pars_fragment", "colorspace_pars_fragment"],
		["output_fragment", "opaque_fragment"]
	]);

	function CE(r, e) {
		let t = Tt[e];
		if (t === void 0) {
			let n = wE.get(e);
			if (n !== void 0) t = Tt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
			else throw new Error("Can not resolve #include <" + e + ">")
		}
		return Ef(t)
	}
	var RE = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function zm(r) {
		return r.replace(RE, IE)
	}

	function IE(r, e, t, n) {
		let i = "";
		for (let s = parseInt(e); s < parseInt(t); s++) i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
		return i
	}

	function Hm(r) {
		let e = "precision " + r.precision + ` float;
precision ` + r.precision + " int;";
		return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
	}

	function PE(r) {
		let e = "SHADOWMAP_TYPE_BASIC";
		return r.shadowMapType === gg ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === iy ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Lr && (e = "SHADOWMAP_TYPE_VSM"), e
	}

	function LE(r) {
		let e = "ENVMAP_TYPE_CUBE";
		if (r.envMap) switch (r.envMapMode) {
			case ta:
			case na:
				e = "ENVMAP_TYPE_CUBE";
				break;
			case Bu:
				e = "ENVMAP_TYPE_CUBE_UV";
				break
		}
		return e
	}

	function NE(r) {
		let e = "ENVMAP_MODE_REFLECTION";
		if (r.envMap) switch (r.envMapMode) {
			case na:
				e = "ENVMAP_MODE_REFRACTION";
				break
		}
		return e
	}

	function OE(r) {
		let e = "ENVMAP_BLENDING_NONE";
		if (r.envMap) switch (r.combine) {
			case ku:
				e = "ENVMAP_BLENDING_MULTIPLY";
				break;
			case My:
				e = "ENVMAP_BLENDING_MIX";
				break;
			case by:
				e = "ENVMAP_BLENDING_ADD";
				break
		}
		return e
	}

	function DE(r) {
		let e = r.envMapCubeUVHeight;
		if (e === null) return null;
		let t = Math.log2(e) - 2,
			n = 1 / e;
		return {
			texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
			texelHeight: n,
			maxMip: t
		}
	}

	function FE(r, e, t, n) {
		let i = r.getContext(),
			s = t.defines,
			o = t.vertexShader,
			a = t.fragmentShader,
			l = PE(t),
			c = LE(t),
			u = NE(t),
			h = OE(t),
			f = DE(t),
			m = t.isWebGL2 ? "" : ME(t),
			g = bE(s),
			y = i.createProgram(),
			d, p, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
		t.isRawShaderMaterial ? (d = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(xl).join(`
`), d.length > 0 && (d += `
`), p = [m, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(xl).join(`
`), p.length > 0 && (p += `
`)) : (d = [Hm(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(xl).join(`
`), p = [m, Hm(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Fr ? "#define TONE_MAPPING" : "", t.toneMapping !== Fr ? Tt.tonemapping_pars_fragment : "", t.toneMapping !== Fr ? EE("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Tt.colorspace_pars_fragment, TE("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(xl).join(`
`)), o = Ef(o), o = Gm(o, t), o = Vm(o, t), a = Ef(a), a = Gm(a, t), a = Vm(a, t), o = zm(o), a = zm(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, d = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + d, p = ["#define varying in", t.glslVersion === cm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === cm ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
		let v = _ + d + o,
			x = _ + p + a,
			M = km(i, i.VERTEX_SHADER, v),
			I = km(i, i.FRAGMENT_SHADER, x);
		if (i.attachShader(y, M), i.attachShader(y, I), t.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y), r.debug.checkShaderErrors) {
			let T = i.getProgramInfoLog(y).trim(),
				C = i.getShaderInfoLog(M).trim(),
				V = i.getShaderInfoLog(I).trim(),
				k = !0,
				F = !0;
			if (i.getProgramParameter(y, i.LINK_STATUS) === !1)
				if (k = !1, typeof r.debug.onShaderError == "function") r.debug.onShaderError(i, y, M, I);
				else {
					let U = Bm(i, M, "vertex"),
						K = Bm(i, I, "fragment");
					console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, i.VALIDATE_STATUS) + `

Program Info Log: ` + T + `
` + U + `
` + K)
				}
			else T !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", T) : (C === "" || V === "") && (F = !1);
			F && (this.diagnostics = {
				runnable: k,
				programLog: T,
				vertexShader: {
					log: C,
					prefix: d
				},
				fragmentShader: {
					log: V,
					prefix: p
				}
			})
		}
		i.deleteShader(M), i.deleteShader(I);
		let w;
		this.getUniforms = function() {
			return w === void 0 && (w = new ea(i, y)), w
		};
		let L;
		return this.getAttributes = function() {
			return L === void 0 && (L = SE(i, y)), L
		}, this.destroy = function() {
			n.releaseStatesOfProgram(this), i.deleteProgram(y), this.program = void 0
		}, this.type = t.shaderType, this.name = t.shaderName, this.id = vE++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = M, this.fragmentShader = I, this
	}
	var UE = 0,
		Mf = class {
			constructor() {
				this.shaderCache = new Map, this.materialCache = new Map
			}
			update(e) {
				let t = e.vertexShader,
					n = e.fragmentShader,
					i = this._getShaderStage(t),
					s = this._getShaderStage(n),
					o = this._getShaderCacheForMaterial(e);
				return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
			}
			remove(e) {
				let t = this.materialCache.get(e);
				for (let n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
				return this.materialCache.delete(e), this
			}
			getVertexShaderID(e) {
				return this._getShaderStage(e.vertexShader).id
			}
			getFragmentShaderID(e) {
				return this._getShaderStage(e.fragmentShader).id
			}
			dispose() {
				this.shaderCache.clear(), this.materialCache.clear()
			}
			_getShaderCacheForMaterial(e) {
				let t = this.materialCache,
					n = t.get(e);
				return n === void 0 && (n = new Set, t.set(e, n)), n
			}
			_getShaderStage(e) {
				let t = this.shaderCache,
					n = t.get(e);
				return n === void 0 && (n = new bf(e), t.set(e, n)), n
			}
		},
		bf = class {
			constructor(e) {
				this.id = UE++, this.code = e, this.usedTimes = 0
			}
		};

	function kE(r, e, t, n, i, s, o) {
		let a = new Cl,
			l = new Mf,
			c = [],
			u = i.isWebGL2,
			h = i.logarithmicDepthBuffer,
			f = i.vertexTextures,
			m = i.precision,
			g = {
				MeshDepthMaterial: "depth",
				MeshDistanceMaterial: "distanceRGBA",
				MeshNormalMaterial: "normal",
				MeshBasicMaterial: "basic",
				MeshLambertMaterial: "lambert",
				MeshPhongMaterial: "phong",
				MeshToonMaterial: "toon",
				MeshStandardMaterial: "physical",
				MeshPhysicalMaterial: "physical",
				MeshMatcapMaterial: "matcap",
				LineBasicMaterial: "basic",
				LineDashedMaterial: "dashed",
				PointsMaterial: "points",
				ShadowMaterial: "shadow",
				SpriteMaterial: "sprite"
			};

		function y(T) {
			return T === 0 ? "uv" : `uv${T}`
		}

		function d(T, C, V, k, F) {
			let U = k.fog,
				K = F.geometry,
				Z = T.isMeshStandardMaterial ? k.environment : null,
				Y = (T.isMeshStandardMaterial ? t : e).get(T.envMap || Z),
				H = Y && Y.mapping === Bu ? Y.image.height : null,
				oe = g[T.type];
			T.precision !== null && (m = i.getMaxPrecision(T.precision), m !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", m, "instead."));
			let de = K.morphAttributes.position || K.morphAttributes.normal || K.morphAttributes.color,
				te = de !== void 0 ? de.length : 0,
				fe = 0;
			K.morphAttributes.position !== void 0 && (fe = 1), K.morphAttributes.normal !== void 0 && (fe = 2), K.morphAttributes.color !== void 0 && (fe = 3);
			let me, P, b, S;
			if (oe) {
				let ft = ar[oe];
				me = ft.vertexShader, P = ft.fragmentShader
			} else me = T.vertexShader, P = T.fragmentShader, l.update(T), b = l.getVertexShaderID(T), S = l.getFragmentShaderID(T);
			let A = r.getRenderTarget(),
				G = F.isInstancedMesh === !0,
				J = !!T.map,
				$ = !!T.matcap,
				le = !!Y,
				N = !!T.aoMap,
				pe = !!T.lightMap,
				Q = !!T.bumpMap,
				he = !!T.normalMap,
				ye = !!T.displacementMap,
				Ee = !!T.emissiveMap,
				ie = !!T.metalnessMap,
				q = !!T.roughnessMap,
				Me = T.anisotropy > 0,
				Pe = T.clearcoat > 0,
				Ke = T.iridescence > 0,
				R = T.sheen > 0,
				E = T.transmission > 0,
				B = Me && !!T.anisotropyMap,
				ne = Pe && !!T.clearcoatMap,
				X = Pe && !!T.clearcoatNormalMap,
				ae = Pe && !!T.clearcoatRoughnessMap,
				ge = Ke && !!T.iridescenceMap,
				ue = Ke && !!T.iridescenceThicknessMap,
				se = R && !!T.sheenColorMap,
				_e = R && !!T.sheenRoughnessMap,
				Se = !!T.specularMap,
				Ne = !!T.specularColorMap,
				Fe = !!T.specularIntensityMap,
				ke = E && !!T.transmissionMap,
				je = E && !!T.thicknessMap,
				We = !!T.gradientMap,
				ce = !!T.alphaMap,
				Le = T.alphaTest > 0,
				ve = !!T.alphaHash,
				Ie = !!T.extensions,
				De = !!K.attributes.uv1,
				et = !!K.attributes.uv2,
				vt = !!K.attributes.uv3;
			return {
				isWebGL2: u,
				shaderID: oe,
				shaderType: T.type,
				shaderName: T.name,
				vertexShader: me,
				fragmentShader: P,
				defines: T.defines,
				customVertexShaderID: b,
				customFragmentShaderID: S,
				isRawShaderMaterial: T.isRawShaderMaterial === !0,
				glslVersion: T.glslVersion,
				precision: m,
				instancing: G,
				instancingColor: G && F.instanceColor !== null,
				supportsVertexTextures: f,
				outputColorSpace: A === null ? r.outputColorSpace : A.isXRRenderTarget === !0 ? A.texture.colorSpace : Bn,
				map: J,
				matcap: $,
				envMap: le,
				envMapMode: le && Y.mapping,
				envMapCubeUVHeight: H,
				aoMap: N,
				lightMap: pe,
				bumpMap: Q,
				normalMap: he,
				displacementMap: f && ye,
				emissiveMap: Ee,
				normalMapObjectSpace: he && T.normalMapType === Hy,
				normalMapTangentSpace: he && T.normalMapType === Gu,
				metalnessMap: ie,
				roughnessMap: q,
				anisotropy: Me,
				anisotropyMap: B,
				clearcoat: Pe,
				clearcoatMap: ne,
				clearcoatNormalMap: X,
				clearcoatRoughnessMap: ae,
				iridescence: Ke,
				iridescenceMap: ge,
				iridescenceThicknessMap: ue,
				sheen: R,
				sheenColorMap: se,
				sheenRoughnessMap: _e,
				specularMap: Se,
				specularColorMap: Ne,
				specularIntensityMap: Fe,
				transmission: E,
				transmissionMap: ke,
				thicknessMap: je,
				gradientMap: We,
				opaque: T.transparent === !1 && T.blending === Jo,
				alphaMap: ce,
				alphaTest: Le,
				alphaHash: ve,
				combine: T.combine,
				mapUv: J && y(T.map.channel),
				aoMapUv: N && y(T.aoMap.channel),
				lightMapUv: pe && y(T.lightMap.channel),
				bumpMapUv: Q && y(T.bumpMap.channel),
				normalMapUv: he && y(T.normalMap.channel),
				displacementMapUv: ye && y(T.displacementMap.channel),
				emissiveMapUv: Ee && y(T.emissiveMap.channel),
				metalnessMapUv: ie && y(T.metalnessMap.channel),
				roughnessMapUv: q && y(T.roughnessMap.channel),
				anisotropyMapUv: B && y(T.anisotropyMap.channel),
				clearcoatMapUv: ne && y(T.clearcoatMap.channel),
				clearcoatNormalMapUv: X && y(T.clearcoatNormalMap.channel),
				clearcoatRoughnessMapUv: ae && y(T.clearcoatRoughnessMap.channel),
				iridescenceMapUv: ge && y(T.iridescenceMap.channel),
				iridescenceThicknessMapUv: ue && y(T.iridescenceThicknessMap.channel),
				sheenColorMapUv: se && y(T.sheenColorMap.channel),
				sheenRoughnessMapUv: _e && y(T.sheenRoughnessMap.channel),
				specularMapUv: Se && y(T.specularMap.channel),
				specularColorMapUv: Ne && y(T.specularColorMap.channel),
				specularIntensityMapUv: Fe && y(T.specularIntensityMap.channel),
				transmissionMapUv: ke && y(T.transmissionMap.channel),
				thicknessMapUv: je && y(T.thicknessMap.channel),
				alphaMapUv: ce && y(T.alphaMap.channel),
				vertexTangents: !!K.attributes.tangent && (he || Me),
				vertexColors: T.vertexColors,
				vertexAlphas: T.vertexColors === !0 && !!K.attributes.color && K.attributes.color.itemSize === 4,
				vertexUv1s: De,
				vertexUv2s: et,
				vertexUv3s: vt,
				pointsUvs: F.isPoints === !0 && !!K.attributes.uv && (J || ce),
				fog: !!U,
				useFog: T.fog === !0,
				fogExp2: U && U.isFogExp2,
				flatShading: T.flatShading === !0,
				sizeAttenuation: T.sizeAttenuation === !0,
				logarithmicDepthBuffer: h,
				skinning: F.isSkinnedMesh === !0,
				morphTargets: K.morphAttributes.position !== void 0,
				morphNormals: K.morphAttributes.normal !== void 0,
				morphColors: K.morphAttributes.color !== void 0,
				morphTargetsCount: te,
				morphTextureStride: fe,
				numDirLights: C.directional.length,
				numPointLights: C.point.length,
				numSpotLights: C.spot.length,
				numSpotLightMaps: C.spotLightMap.length,
				numRectAreaLights: C.rectArea.length,
				numHemiLights: C.hemi.length,
				numDirLightShadows: C.directionalShadowMap.length,
				numPointLightShadows: C.pointShadowMap.length,
				numSpotLightShadows: C.spotShadowMap.length,
				numSpotLightShadowsWithMaps: C.numSpotLightShadowsWithMaps,
				numClippingPlanes: o.numPlanes,
				numClipIntersection: o.numIntersection,
				dithering: T.dithering,
				shadowMapEnabled: r.shadowMap.enabled && V.length > 0,
				shadowMapType: r.shadowMap.type,
				toneMapping: T.toneMapped ? r.toneMapping : Fr,
				useLegacyLights: r.useLegacyLights,
				premultipliedAlpha: T.premultipliedAlpha,
				doubleSided: T.side === wn,
				flipSided: T.side === gn,
				useDepthPacking: T.depthPacking >= 0,
				depthPacking: T.depthPacking || 0,
				index0AttributeName: T.index0AttributeName,
				extensionDerivatives: Ie && T.extensions.derivatives === !0,
				extensionFragDepth: Ie && T.extensions.fragDepth === !0,
				extensionDrawBuffers: Ie && T.extensions.drawBuffers === !0,
				extensionShaderTextureLOD: Ie && T.extensions.shaderTextureLOD === !0,
				rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
				rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
				rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
				customProgramCacheKey: T.customProgramCacheKey()
			}
		}

		function p(T) {
			let C = [];
			if (T.shaderID ? C.push(T.shaderID) : (C.push(T.customVertexShaderID), C.push(T.customFragmentShaderID)), T.defines !== void 0)
				for (let V in T.defines) C.push(V), C.push(T.defines[V]);
			return T.isRawShaderMaterial === !1 && (_(C, T), v(C, T), C.push(r.outputColorSpace)), C.push(T.customProgramCacheKey), C.join()
		}

		function _(T, C) {
			T.push(C.precision), T.push(C.outputColorSpace), T.push(C.envMapMode), T.push(C.envMapCubeUVHeight), T.push(C.mapUv), T.push(C.alphaMapUv), T.push(C.lightMapUv), T.push(C.aoMapUv), T.push(C.bumpMapUv), T.push(C.normalMapUv), T.push(C.displacementMapUv), T.push(C.emissiveMapUv), T.push(C.metalnessMapUv), T.push(C.roughnessMapUv), T.push(C.anisotropyMapUv), T.push(C.clearcoatMapUv), T.push(C.clearcoatNormalMapUv), T.push(C.clearcoatRoughnessMapUv), T.push(C.iridescenceMapUv), T.push(C.iridescenceThicknessMapUv), T.push(C.sheenColorMapUv), T.push(C.sheenRoughnessMapUv), T.push(C.specularMapUv), T.push(C.specularColorMapUv), T.push(C.specularIntensityMapUv), T.push(C.transmissionMapUv), T.push(C.thicknessMapUv), T.push(C.combine), T.push(C.fogExp2), T.push(C.sizeAttenuation), T.push(C.morphTargetsCount), T.push(C.morphAttributeCount), T.push(C.numDirLights), T.push(C.numPointLights), T.push(C.numSpotLights), T.push(C.numSpotLightMaps), T.push(C.numHemiLights), T.push(C.numRectAreaLights), T.push(C.numDirLightShadows), T.push(C.numPointLightShadows), T.push(C.numSpotLightShadows), T.push(C.numSpotLightShadowsWithMaps), T.push(C.shadowMapType), T.push(C.toneMapping), T.push(C.numClippingPlanes), T.push(C.numClipIntersection), T.push(C.depthPacking)
		}

		function v(T, C) {
			a.disableAll(), C.isWebGL2 && a.enable(0), C.supportsVertexTextures && a.enable(1), C.instancing && a.enable(2), C.instancingColor && a.enable(3), C.matcap && a.enable(4), C.envMap && a.enable(5), C.normalMapObjectSpace && a.enable(6), C.normalMapTangentSpace && a.enable(7), C.clearcoat && a.enable(8), C.iridescence && a.enable(9), C.alphaTest && a.enable(10), C.vertexColors && a.enable(11), C.vertexAlphas && a.enable(12), C.vertexUv1s && a.enable(13), C.vertexUv2s && a.enable(14), C.vertexUv3s && a.enable(15), C.vertexTangents && a.enable(16), C.anisotropy && a.enable(17), T.push(a.mask), a.disableAll(), C.fog && a.enable(0), C.useFog && a.enable(1), C.flatShading && a.enable(2), C.logarithmicDepthBuffer && a.enable(3), C.skinning && a.enable(4), C.morphTargets && a.enable(5), C.morphNormals && a.enable(6), C.morphColors && a.enable(7), C.premultipliedAlpha && a.enable(8), C.shadowMapEnabled && a.enable(9), C.useLegacyLights && a.enable(10), C.doubleSided && a.enable(11), C.flipSided && a.enable(12), C.useDepthPacking && a.enable(13), C.dithering && a.enable(14), C.transmission && a.enable(15), C.sheen && a.enable(16), C.opaque && a.enable(17), C.pointsUvs && a.enable(18), T.push(a.mask)
		}

		function x(T) {
			let C = g[T.type],
				V;
			if (C) {
				let k = ar[C];
				V = Pv.clone(k.uniforms)
			} else V = T.uniforms;
			return V
		}

		function M(T, C) {
			let V;
			for (let k = 0, F = c.length; k < F; k++) {
				let U = c[k];
				if (U.cacheKey === C) {
					V = U, ++V.usedTimes;
					break
				}
			}
			return V === void 0 && (V = new FE(r, C, T, s), c.push(V)), V
		}

		function I(T) {
			if (--T.usedTimes === 0) {
				let C = c.indexOf(T);
				c[C] = c[c.length - 1], c.pop(), T.destroy()
			}
		}

		function w(T) {
			l.remove(T)
		}

		function L() {
			l.dispose()
		}
		return {
			getParameters: d,
			getProgramCacheKey: p,
			getUniforms: x,
			acquireProgram: M,
			releaseProgram: I,
			releaseShaderCache: w,
			programs: c,
			dispose: L
		}
	}

	function BE() {
		let r = new WeakMap;

		function e(s) {
			let o = r.get(s);
			return o === void 0 && (o = {}, r.set(s, o)), o
		}

		function t(s) {
			r.delete(s)
		}

		function n(s, o, a) {
			r.get(s)[o] = a
		}

		function i() {
			r = new WeakMap
		}
		return {
			get: e,
			remove: t,
			update: n,
			dispose: i
		}
	}

	function GE(r, e) {
		return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
	}

	function Wm(r, e) {
		return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
	}

	function Xm() {
		let r = [],
			e = 0,
			t = [],
			n = [],
			i = [];

		function s() {
			e = 0, t.length = 0, n.length = 0, i.length = 0
		}

		function o(h, f, m, g, y, d) {
			let p = r[e];
			return p === void 0 ? (p = {
				id: h.id,
				object: h,
				geometry: f,
				material: m,
				groupOrder: g,
				renderOrder: h.renderOrder,
				z: y,
				group: d
			}, r[e] = p) : (p.id = h.id, p.object = h, p.geometry = f, p.material = m, p.groupOrder = g, p.renderOrder = h.renderOrder, p.z = y, p.group = d), e++, p
		}

		function a(h, f, m, g, y, d) {
			let p = o(h, f, m, g, y, d);
			m.transmission > 0 ? n.push(p) : m.transparent === !0 ? i.push(p) : t.push(p)
		}

		function l(h, f, m, g, y, d) {
			let p = o(h, f, m, g, y, d);
			m.transmission > 0 ? n.unshift(p) : m.transparent === !0 ? i.unshift(p) : t.unshift(p)
		}

		function c(h, f) {
			t.length > 1 && t.sort(h || GE), n.length > 1 && n.sort(f || Wm), i.length > 1 && i.sort(f || Wm)
		}

		function u() {
			for (let h = e, f = r.length; h < f; h++) {
				let m = r[h];
				if (m.id === null) break;
				m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null
			}
		}
		return {
			opaque: t,
			transmissive: n,
			transparent: i,
			init: s,
			push: a,
			unshift: l,
			finish: u,
			sort: c
		}
	}

	function VE() {
		let r = new WeakMap;

		function e(n, i) {
			let s = r.get(n),
				o;
			return s === void 0 ? (o = new Xm, r.set(n, [o])) : i >= s.length ? (o = new Xm, s.push(o)) : o = s[i], o
		}

		function t() {
			r = new WeakMap
		}
		return {
			get: e,
			dispose: t
		}
	}

	function zE() {
		let r = {};
		return {
			get: function(e) {
				if (r[e.id] !== void 0) return r[e.id];
				let t;
				switch (e.type) {
					case "DirectionalLight":
						t = {
							direction: new re,
							color: new qe
						};
						break;
					case "SpotLight":
						t = {
							position: new re,
							direction: new re,
							color: new qe,
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;
					case "PointLight":
						t = {
							position: new re,
							color: new qe,
							distance: 0,
							decay: 0
						};
						break;
					case "HemisphereLight":
						t = {
							direction: new re,
							skyColor: new qe,
							groundColor: new qe
						};
						break;
					case "RectAreaLight":
						t = {
							color: new qe,
							position: new re,
							halfWidth: new re,
							halfHeight: new re
						};
						break
				}
				return r[e.id] = t, t
			}
		}
	}

	function HE() {
		let r = {};
		return {
			get: function(e) {
				if (r[e.id] !== void 0) return r[e.id];
				let t;
				switch (e.type) {
					case "DirectionalLight":
						t = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Ce
						};
						break;
					case "SpotLight":
						t = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Ce
						};
						break;
					case "PointLight":
						t = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Ce,
							shadowCameraNear: 1,
							shadowCameraFar: 1e3
						};
						break
				}
				return r[e.id] = t, t
			}
		}
	}
	var WE = 0;

	function XE(r, e) {
		return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
	}

	function qE(r, e) {
		let t = new zE,
			n = HE(),
			i = {
				version: 0,
				hash: {
					directionalLength: -1,
					pointLength: -1,
					spotLength: -1,
					rectAreaLength: -1,
					hemiLength: -1,
					numDirectionalShadows: -1,
					numPointShadows: -1,
					numSpotShadows: -1,
					numSpotMaps: -1
				},
				ambient: [0, 0, 0],
				probe: [],
				directional: [],
				directionalShadow: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotLightMap: [],
				spotShadow: [],
				spotShadowMap: [],
				spotLightMatrix: [],
				rectArea: [],
				rectAreaLTC1: null,
				rectAreaLTC2: null,
				point: [],
				pointShadow: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
				numSpotLightShadowsWithMaps: 0
			};
		for (let u = 0; u < 9; u++) i.probe.push(new re);
		let s = new re,
			o = new Je,
			a = new Je;

		function l(u, h) {
			let f = 0,
				m = 0,
				g = 0;
			for (let V = 0; V < 9; V++) i.probe[V].set(0, 0, 0);
			let y = 0,
				d = 0,
				p = 0,
				_ = 0,
				v = 0,
				x = 0,
				M = 0,
				I = 0,
				w = 0,
				L = 0;
			u.sort(XE);
			let T = h === !0 ? Math.PI : 1;
			for (let V = 0, k = u.length; V < k; V++) {
				let F = u[V],
					U = F.color,
					K = F.intensity,
					Z = F.distance,
					Y = F.shadow && F.shadow.map ? F.shadow.map.texture : null;
				if (F.isAmbientLight) f += U.r * K * T, m += U.g * K * T, g += U.b * K * T;
				else if (F.isLightProbe)
					for (let H = 0; H < 9; H++) i.probe[H].addScaledVector(F.sh.coefficients[H], K);
				else if (F.isDirectionalLight) {
					let H = t.get(F);
					if (H.color.copy(F.color).multiplyScalar(F.intensity * T), F.castShadow) {
						let oe = F.shadow,
							de = n.get(F);
						de.shadowBias = oe.bias, de.shadowNormalBias = oe.normalBias, de.shadowRadius = oe.radius, de.shadowMapSize = oe.mapSize, i.directionalShadow[y] = de, i.directionalShadowMap[y] = Y, i.directionalShadowMatrix[y] = F.shadow.matrix, x++
					}
					i.directional[y] = H, y++
				} else if (F.isSpotLight) {
					let H = t.get(F);
					H.position.setFromMatrixPosition(F.matrixWorld), H.color.copy(U).multiplyScalar(K * T), H.distance = Z, H.coneCos = Math.cos(F.angle), H.penumbraCos = Math.cos(F.angle * (1 - F.penumbra)), H.decay = F.decay, i.spot[p] = H;
					let oe = F.shadow;
					if (F.map && (i.spotLightMap[w] = F.map, w++, oe.updateMatrices(F), F.castShadow && L++), i.spotLightMatrix[p] = oe.matrix, F.castShadow) {
						let de = n.get(F);
						de.shadowBias = oe.bias, de.shadowNormalBias = oe.normalBias, de.shadowRadius = oe.radius, de.shadowMapSize = oe.mapSize, i.spotShadow[p] = de, i.spotShadowMap[p] = Y, I++
					}
					p++
				} else if (F.isRectAreaLight) {
					let H = t.get(F);
					H.color.copy(U).multiplyScalar(K), H.halfWidth.set(F.width * .5, 0, 0), H.halfHeight.set(0, F.height * .5, 0), i.rectArea[_] = H, _++
				} else if (F.isPointLight) {
					let H = t.get(F);
					if (H.color.copy(F.color).multiplyScalar(F.intensity * T), H.distance = F.distance, H.decay = F.decay, F.castShadow) {
						let oe = F.shadow,
							de = n.get(F);
						de.shadowBias = oe.bias, de.shadowNormalBias = oe.normalBias, de.shadowRadius = oe.radius, de.shadowMapSize = oe.mapSize, de.shadowCameraNear = oe.camera.near, de.shadowCameraFar = oe.camera.far, i.pointShadow[d] = de, i.pointShadowMap[d] = Y, i.pointShadowMatrix[d] = F.shadow.matrix, M++
					}
					i.point[d] = H, d++
				} else if (F.isHemisphereLight) {
					let H = t.get(F);
					H.skyColor.copy(F.color).multiplyScalar(K * T), H.groundColor.copy(F.groundColor).multiplyScalar(K * T), i.hemi[v] = H, v++
				}
			}
			_ > 0 && (e.isWebGL2 || r.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Ve.LTC_FLOAT_1, i.rectAreaLTC2 = Ve.LTC_FLOAT_2) : r.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = Ve.LTC_HALF_1, i.rectAreaLTC2 = Ve.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = f, i.ambient[1] = m, i.ambient[2] = g;
			let C = i.hash;
			(C.directionalLength !== y || C.pointLength !== d || C.spotLength !== p || C.rectAreaLength !== _ || C.hemiLength !== v || C.numDirectionalShadows !== x || C.numPointShadows !== M || C.numSpotShadows !== I || C.numSpotMaps !== w) && (i.directional.length = y, i.spot.length = p, i.rectArea.length = _, i.point.length = d, i.hemi.length = v, i.directionalShadow.length = x, i.directionalShadowMap.length = x, i.pointShadow.length = M, i.pointShadowMap.length = M, i.spotShadow.length = I, i.spotShadowMap.length = I, i.directionalShadowMatrix.length = x, i.pointShadowMatrix.length = M, i.spotLightMatrix.length = I + w - L, i.spotLightMap.length = w, i.numSpotLightShadowsWithMaps = L, C.directionalLength = y, C.pointLength = d, C.spotLength = p, C.rectAreaLength = _, C.hemiLength = v, C.numDirectionalShadows = x, C.numPointShadows = M, C.numSpotShadows = I, C.numSpotMaps = w, i.version = WE++)
		}

		function c(u, h) {
			let f = 0,
				m = 0,
				g = 0,
				y = 0,
				d = 0,
				p = h.matrixWorldInverse;
			for (let _ = 0, v = u.length; _ < v; _++) {
				let x = u[_];
				if (x.isDirectionalLight) {
					let M = i.directional[f];
					M.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(p), f++
				} else if (x.isSpotLight) {
					let M = i.spot[g];
					M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(p), M.direction.setFromMatrixPosition(x.matrixWorld), s.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(s), M.direction.transformDirection(p), g++
				} else if (x.isRectAreaLight) {
					let M = i.rectArea[y];
					M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(p), a.identity(), o.copy(x.matrixWorld), o.premultiply(p), a.extractRotation(o), M.halfWidth.set(x.width * .5, 0, 0), M.halfHeight.set(0, x.height * .5, 0), M.halfWidth.applyMatrix4(a), M.halfHeight.applyMatrix4(a), y++
				} else if (x.isPointLight) {
					let M = i.point[m];
					M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(p), m++
				} else if (x.isHemisphereLight) {
					let M = i.hemi[d];
					M.direction.setFromMatrixPosition(x.matrixWorld), M.direction.transformDirection(p), d++
				}
			}
		}
		return {
			setup: l,
			setupView: c,
			state: i
		}
	}

	function qm(r, e) {
		let t = new qE(r, e),
			n = [],
			i = [];

		function s() {
			n.length = 0, i.length = 0
		}

		function o(h) {
			n.push(h)
		}

		function a(h) {
			i.push(h)
		}

		function l(h) {
			t.setup(n, h)
		}

		function c(h) {
			t.setupView(n, h)
		}
		return {
			init: s,
			state: {
				lightsArray: n,
				shadowsArray: i,
				lights: t
			},
			setupLights: l,
			setupLightsView: c,
			pushLight: o,
			pushShadow: a
		}
	}

	function jE(r, e) {
		let t = new WeakMap;

		function n(s, o = 0) {
			let a = t.get(s),
				l;
			return a === void 0 ? (l = new qm(r, e), t.set(s, [l])) : o >= a.length ? (l = new qm(r, e), a.push(l)) : l = a[o], l
		}

		function i() {
			t = new WeakMap
		}
		return {
			get: n,
			dispose: i
		}
	}
	var Sf = class extends Vi {
			constructor(e) {
				super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Vy, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
			}
		},
		Af = class extends Vi {
			constructor(e) {
				super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
			}
		},
		YE = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
		KE = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

	function ZE(r, e, t) {
		let n = new Il,
			i = new Ce,
			s = new Ce,
			o = new Ct,
			a = new Sf({
				depthPacking: zy
			}),
			l = new Af,
			c = {},
			u = t.maxTextureSize,
			h = {
				[_i]: gn,
				[gn]: _i,
				[wn]: wn
			},
			f = new kr({
				defines: {
					VSM_SAMPLES: 8
				},
				uniforms: {
					shadow_pass: {
						value: null
					},
					resolution: {
						value: new Ce
					},
					radius: {
						value: 4
					}
				},
				vertexShader: YE,
				fragmentShader: KE
			}),
			m = f.clone();
		m.defines.HORIZONTAL_PASS = 1;
		let g = new St;
		g.setAttribute("position", new Ln(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
		let y = new Nt(g, f),
			d = this;
		this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = gg;
		let p = this.type;
		this.render = function(M, I, w) {
			if (d.enabled === !1 || d.autoUpdate === !1 && d.needsUpdate === !1 || M.length === 0) return;
			let L = r.getRenderTarget(),
				T = r.getActiveCubeFace(),
				C = r.getActiveMipmapLevel(),
				V = r.state;
			V.setBlending(is), V.buffers.color.setClear(1, 1, 1, 1), V.buffers.depth.setTest(!0), V.setScissorTest(!1);
			let k = p !== Lr && this.type === Lr,
				F = p === Lr && this.type !== Lr;
			for (let U = 0, K = M.length; U < K; U++) {
				let Z = M[U],
					Y = Z.shadow;
				if (Y === void 0) {
					console.warn("THREE.WebGLShadowMap:", Z, "has no shadow.");
					continue
				}
				if (Y.autoUpdate === !1 && Y.needsUpdate === !1) continue;
				i.copy(Y.mapSize);
				let H = Y.getFrameExtents();
				if (i.multiply(H), s.copy(Y.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / H.x), i.x = s.x * H.x, Y.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / H.y), i.y = s.y * H.y, Y.mapSize.y = s.y)), Y.map === null || k === !0 || F === !0) {
					let de = this.type !== Lr ? {
						minFilter: pn,
						magFilter: pn
					} : {};
					Y.map !== null && Y.map.dispose(), Y.map = new Ur(i.x, i.y, de), Y.map.texture.name = Z.name + ".shadowMap", Y.camera.updateProjectionMatrix()
				}
				r.setRenderTarget(Y.map), r.clear();
				let oe = Y.getViewportCount();
				for (let de = 0; de < oe; de++) {
					let te = Y.getViewport(de);
					o.set(s.x * te.x, s.y * te.y, s.x * te.z, s.y * te.w), V.viewport(o), Y.updateMatrices(Z, de), n = Y.getFrustum(), x(I, w, Y.camera, Z, this.type)
				}
				Y.isPointLightShadow !== !0 && this.type === Lr && _(Y, w), Y.needsUpdate = !1
			}
			p = this.type, d.needsUpdate = !1, r.setRenderTarget(L, T, C)
		};

		function _(M, I) {
			let w = e.update(y);
			f.defines.VSM_SAMPLES !== M.blurSamples && (f.defines.VSM_SAMPLES = M.blurSamples, m.defines.VSM_SAMPLES = M.blurSamples, f.needsUpdate = !0, m.needsUpdate = !0), M.mapPass === null && (M.mapPass = new Ur(i.x, i.y)), f.uniforms.shadow_pass.value = M.map.texture, f.uniforms.resolution.value = M.mapSize, f.uniforms.radius.value = M.radius, r.setRenderTarget(M.mapPass), r.clear(), r.renderBufferDirect(I, null, w, f, y, null), m.uniforms.shadow_pass.value = M.mapPass.texture, m.uniforms.resolution.value = M.mapSize, m.uniforms.radius.value = M.radius, r.setRenderTarget(M.map), r.clear(), r.renderBufferDirect(I, null, w, m, y, null)
		}

		function v(M, I, w, L) {
			let T = null,
				C = w.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
			if (C !== void 0) T = C;
			else if (T = w.isPointLight === !0 ? l : a, r.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0) {
				let V = T.uuid,
					k = I.uuid,
					F = c[V];
				F === void 0 && (F = {}, c[V] = F);
				let U = F[k];
				U === void 0 && (U = T.clone(), F[k] = U), T = U
			}
			if (T.visible = I.visible, T.wireframe = I.wireframe, L === Lr ? T.side = I.shadowSide !== null ? I.shadowSide : I.side : T.side = I.shadowSide !== null ? I.shadowSide : h[I.side], T.alphaMap = I.alphaMap, T.alphaTest = I.alphaTest, T.map = I.map, T.clipShadows = I.clipShadows, T.clippingPlanes = I.clippingPlanes, T.clipIntersection = I.clipIntersection, T.displacementMap = I.displacementMap, T.displacementScale = I.displacementScale, T.displacementBias = I.displacementBias, T.wireframeLinewidth = I.wireframeLinewidth, T.linewidth = I.linewidth, w.isPointLight === !0 && T.isMeshDistanceMaterial === !0) {
				let V = r.properties.get(T);
				V.light = w
			}
			return T
		}

		function x(M, I, w, L, T) {
			if (M.visible === !1) return;
			if (M.layers.test(I.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && T === Lr) && (!M.frustumCulled || n.intersectsObject(M))) {
				M.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, M.matrixWorld);
				let k = e.update(M),
					F = M.material;
				if (Array.isArray(F)) {
					let U = k.groups;
					for (let K = 0, Z = U.length; K < Z; K++) {
						let Y = U[K],
							H = F[Y.materialIndex];
						if (H && H.visible) {
							let oe = v(M, H, L, T);
							r.renderBufferDirect(w, null, k, oe, M, Y)
						}
					}
				} else if (F.visible) {
					let U = v(M, F, L, T);
					r.renderBufferDirect(w, null, k, U, M, null)
				}
			}
			let V = M.children;
			for (let k = 0, F = V.length; k < F; k++) x(V[k], I, w, L, T)
		}
	}

	function JE(r, e, t) {
		let n = t.isWebGL2;

		function i() {
			let ce = !1,
				Le = new Ct,
				ve = null,
				Ie = new Ct(0, 0, 0, 0);
			return {
				setMask: function(De) {
					ve !== De && !ce && (r.colorMask(De, De, De, De), ve = De)
				},
				setLocked: function(De) {
					ce = De
				},
				setClear: function(De, et, vt, Mt, ft) {
					ft === !0 && (De *= Mt, et *= Mt, vt *= Mt), Le.set(De, et, vt, Mt), Ie.equals(Le) === !1 && (r.clearColor(De, et, vt, Mt), Ie.copy(Le))
				},
				reset: function() {
					ce = !1, ve = null, Ie.set(-1, 0, 0, 0)
				}
			}
		}

		function s() {
			let ce = !1,
				Le = null,
				ve = null,
				Ie = null;
			return {
				setTest: function(De) {
					De ? A(r.DEPTH_TEST) : G(r.DEPTH_TEST)
				},
				setMask: function(De) {
					Le !== De && !ce && (r.depthMask(De), Le = De)
				},
				setFunc: function(De) {
					if (ve !== De) {
						switch (De) {
							case gy:
								r.depthFunc(r.NEVER);
								break;
							case yy:
								r.depthFunc(r.ALWAYS);
								break;
							case vy:
								r.depthFunc(r.LESS);
								break;
							case ff:
								r.depthFunc(r.LEQUAL);
								break;
							case xy:
								r.depthFunc(r.EQUAL);
								break;
							case _y:
								r.depthFunc(r.GEQUAL);
								break;
							case Ty:
								r.depthFunc(r.GREATER);
								break;
							case Ey:
								r.depthFunc(r.NOTEQUAL);
								break;
							default:
								r.depthFunc(r.LEQUAL)
						}
						ve = De
					}
				},
				setLocked: function(De) {
					ce = De
				},
				setClear: function(De) {
					Ie !== De && (r.clearDepth(De), Ie = De)
				},
				reset: function() {
					ce = !1, Le = null, ve = null, Ie = null
				}
			}
		}

		function o() {
			let ce = !1,
				Le = null,
				ve = null,
				Ie = null,
				De = null,
				et = null,
				vt = null,
				Mt = null,
				ft = null;
			return {
				setTest: function(Ue) {
					ce || (Ue ? A(r.STENCIL_TEST) : G(r.STENCIL_TEST))
				},
				setMask: function(Ue) {
					Le !== Ue && !ce && (r.stencilMask(Ue), Le = Ue)
				},
				setFunc: function(Ue, Ye, Be) {
					(ve !== Ue || Ie !== Ye || De !== Be) && (r.stencilFunc(Ue, Ye, Be), ve = Ue, Ie = Ye, De = Be)
				},
				setOp: function(Ue, Ye, Be) {
					(et !== Ue || vt !== Ye || Mt !== Be) && (r.stencilOp(Ue, Ye, Be), et = Ue, vt = Ye, Mt = Be)
				},
				setLocked: function(Ue) {
					ce = Ue
				},
				setClear: function(Ue) {
					ft !== Ue && (r.clearStencil(Ue), ft = Ue)
				},
				reset: function() {
					ce = !1, Le = null, ve = null, Ie = null, De = null, et = null, vt = null, Mt = null, ft = null
				}
			}
		}
		let a = new i,
			l = new s,
			c = new o,
			u = new WeakMap,
			h = new WeakMap,
			f = {},
			m = {},
			g = new WeakMap,
			y = [],
			d = null,
			p = !1,
			_ = null,
			v = null,
			x = null,
			M = null,
			I = null,
			w = null,
			L = null,
			T = !1,
			C = null,
			V = null,
			k = null,
			F = null,
			U = null,
			K = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
			Z = !1,
			Y = 0,
			H = r.getParameter(r.VERSION);
		H.indexOf("WebGL") !== -1 ? (Y = parseFloat(/^WebGL (\d)/.exec(H)[1]), Z = Y >= 1) : H.indexOf("OpenGL ES") !== -1 && (Y = parseFloat(/^OpenGL ES (\d)/.exec(H)[1]), Z = Y >= 2);
		let oe = null,
			de = {},
			te = r.getParameter(r.SCISSOR_BOX),
			fe = r.getParameter(r.VIEWPORT),
			me = new Ct().fromArray(te),
			P = new Ct().fromArray(fe);

		function b(ce, Le, ve, Ie) {
			let De = new Uint8Array(4),
				et = r.createTexture();
			r.bindTexture(ce, et), r.texParameteri(ce, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(ce, r.TEXTURE_MAG_FILTER, r.NEAREST);
			for (let vt = 0; vt < ve; vt++) n && (ce === r.TEXTURE_3D || ce === r.TEXTURE_2D_ARRAY) ? r.texImage3D(Le, 0, r.RGBA, 1, 1, Ie, 0, r.RGBA, r.UNSIGNED_BYTE, De) : r.texImage2D(Le + vt, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, De);
			return et
		}
		let S = {};
		S[r.TEXTURE_2D] = b(r.TEXTURE_2D, r.TEXTURE_2D, 1), S[r.TEXTURE_CUBE_MAP] = b(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (S[r.TEXTURE_2D_ARRAY] = b(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), S[r.TEXTURE_3D] = b(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), A(r.DEPTH_TEST), l.setFunc(ff), ye(!1), Ee(Rp), A(r.CULL_FACE), Q(is);

		function A(ce) {
			f[ce] !== !0 && (r.enable(ce), f[ce] = !0)
		}

		function G(ce) {
			f[ce] !== !1 && (r.disable(ce), f[ce] = !1)
		}

		function J(ce, Le) {
			return m[ce] !== Le ? (r.bindFramebuffer(ce, Le), m[ce] = Le, n && (ce === r.DRAW_FRAMEBUFFER && (m[r.FRAMEBUFFER] = Le), ce === r.FRAMEBUFFER && (m[r.DRAW_FRAMEBUFFER] = Le)), !0) : !1
		}

		function $(ce, Le) {
			let ve = y,
				Ie = !1;
			if (ce)
				if (ve = g.get(Le), ve === void 0 && (ve = [], g.set(Le, ve)), ce.isWebGLMultipleRenderTargets) {
					let De = ce.texture;
					if (ve.length !== De.length || ve[0] !== r.COLOR_ATTACHMENT0) {
						for (let et = 0, vt = De.length; et < vt; et++) ve[et] = r.COLOR_ATTACHMENT0 + et;
						ve.length = De.length, Ie = !0
					}
				} else ve[0] !== r.COLOR_ATTACHMENT0 && (ve[0] = r.COLOR_ATTACHMENT0, Ie = !0);
			else ve[0] !== r.BACK && (ve[0] = r.BACK, Ie = !0);
			Ie && (t.isWebGL2 ? r.drawBuffers(ve) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ve))
		}

		function le(ce) {
			return d !== ce ? (r.useProgram(ce), d = ce, !0) : !1
		}
		let N = {
			[Yo]: r.FUNC_ADD,
			[sy]: r.FUNC_SUBTRACT,
			[oy]: r.FUNC_REVERSE_SUBTRACT
		};
		if (n) N[Np] = r.MIN, N[Op] = r.MAX;
		else {
			let ce = e.get("EXT_blend_minmax");
			ce !== null && (N[Np] = ce.MIN_EXT, N[Op] = ce.MAX_EXT)
		}
		let pe = {
			[ay]: r.ZERO,
			[ly]: r.ONE,
			[cy]: r.SRC_COLOR,
			[yg]: r.SRC_ALPHA,
			[my]: r.SRC_ALPHA_SATURATE,
			[dy]: r.DST_COLOR,
			[hy]: r.DST_ALPHA,
			[uy]: r.ONE_MINUS_SRC_COLOR,
			[vg]: r.ONE_MINUS_SRC_ALPHA,
			[py]: r.ONE_MINUS_DST_COLOR,
			[fy]: r.ONE_MINUS_DST_ALPHA
		};

		function Q(ce, Le, ve, Ie, De, et, vt, Mt) {
			if (ce === is) {
				p === !0 && (G(r.BLEND), p = !1);
				return
			}
			if (p === !1 && (A(r.BLEND), p = !0), ce !== ry) {
				if (ce !== _ || Mt !== T) {
					if ((v !== Yo || I !== Yo) && (r.blendEquation(r.FUNC_ADD), v = Yo, I = Yo), Mt) switch (ce) {
						case Jo:
							r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
							break;
						case Ip:
							r.blendFunc(r.ONE, r.ONE);
							break;
						case Pp:
							r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
							break;
						case Lp:
							r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", ce);
							break
					} else switch (ce) {
						case Jo:
							r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
							break;
						case Ip:
							r.blendFunc(r.SRC_ALPHA, r.ONE);
							break;
						case Pp:
							r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
							break;
						case Lp:
							r.blendFunc(r.ZERO, r.SRC_COLOR);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", ce);
							break
					}
					x = null, M = null, w = null, L = null, _ = ce, T = Mt
				}
				return
			}
			De = De || Le, et = et || ve, vt = vt || Ie, (Le !== v || De !== I) && (r.blendEquationSeparate(N[Le], N[De]), v = Le, I = De), (ve !== x || Ie !== M || et !== w || vt !== L) && (r.blendFuncSeparate(pe[ve], pe[Ie], pe[et], pe[vt]), x = ve, M = Ie, w = et, L = vt), _ = ce, T = !1
		}

		function he(ce, Le) {
			ce.side === wn ? G(r.CULL_FACE) : A(r.CULL_FACE);
			let ve = ce.side === gn;
			Le && (ve = !ve), ye(ve), ce.blending === Jo && ce.transparent === !1 ? Q(is) : Q(ce.blending, ce.blendEquation, ce.blendSrc, ce.blendDst, ce.blendEquationAlpha, ce.blendSrcAlpha, ce.blendDstAlpha, ce.premultipliedAlpha), l.setFunc(ce.depthFunc), l.setTest(ce.depthTest), l.setMask(ce.depthWrite), a.setMask(ce.colorWrite);
			let Ie = ce.stencilWrite;
			c.setTest(Ie), Ie && (c.setMask(ce.stencilWriteMask), c.setFunc(ce.stencilFunc, ce.stencilRef, ce.stencilFuncMask), c.setOp(ce.stencilFail, ce.stencilZFail, ce.stencilZPass)), q(ce.polygonOffset, ce.polygonOffsetFactor, ce.polygonOffsetUnits), ce.alphaToCoverage === !0 ? A(r.SAMPLE_ALPHA_TO_COVERAGE) : G(r.SAMPLE_ALPHA_TO_COVERAGE)
		}

		function ye(ce) {
			C !== ce && (ce ? r.frontFace(r.CW) : r.frontFace(r.CCW), C = ce)
		}

		function Ee(ce) {
			ce !== ty ? (A(r.CULL_FACE), ce !== V && (ce === Rp ? r.cullFace(r.BACK) : ce === ny ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : G(r.CULL_FACE), V = ce
		}

		function ie(ce) {
			ce !== k && (Z && r.lineWidth(ce), k = ce)
		}

		function q(ce, Le, ve) {
			ce ? (A(r.POLYGON_OFFSET_FILL), (F !== Le || U !== ve) && (r.polygonOffset(Le, ve), F = Le, U = ve)) : G(r.POLYGON_OFFSET_FILL)
		}

		function Me(ce) {
			ce ? A(r.SCISSOR_TEST) : G(r.SCISSOR_TEST)
		}

		function Pe(ce) {
			ce === void 0 && (ce = r.TEXTURE0 + K - 1), oe !== ce && (r.activeTexture(ce), oe = ce)
		}

		function Ke(ce, Le, ve) {
			ve === void 0 && (oe === null ? ve = r.TEXTURE0 + K - 1 : ve = oe);
			let Ie = de[ve];
			Ie === void 0 && (Ie = {
				type: void 0,
				texture: void 0
			}, de[ve] = Ie), (Ie.type !== ce || Ie.texture !== Le) && (oe !== ve && (r.activeTexture(ve), oe = ve), r.bindTexture(ce, Le || S[ce]), Ie.type = ce, Ie.texture = Le)
		}

		function R() {
			let ce = de[oe];
			ce !== void 0 && ce.type !== void 0 && (r.bindTexture(ce.type, null), ce.type = void 0, ce.texture = void 0)
		}

		function E() {
			try {
				r.compressedTexImage2D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function B() {
			try {
				r.compressedTexImage3D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function ne() {
			try {
				r.texSubImage2D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function X() {
			try {
				r.texSubImage3D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function ae() {
			try {
				r.compressedTexSubImage2D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function ge() {
			try {
				r.compressedTexSubImage3D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function ue() {
			try {
				r.texStorage2D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function se() {
			try {
				r.texStorage3D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function _e() {
			try {
				r.texImage2D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function Se() {
			try {
				r.texImage3D.apply(r, arguments)
			} catch (ce) {
				console.error("THREE.WebGLState:", ce)
			}
		}

		function Ne(ce) {
			me.equals(ce) === !1 && (r.scissor(ce.x, ce.y, ce.z, ce.w), me.copy(ce))
		}

		function Fe(ce) {
			P.equals(ce) === !1 && (r.viewport(ce.x, ce.y, ce.z, ce.w), P.copy(ce))
		}

		function ke(ce, Le) {
			let ve = h.get(Le);
			ve === void 0 && (ve = new WeakMap, h.set(Le, ve));
			let Ie = ve.get(ce);
			Ie === void 0 && (Ie = r.getUniformBlockIndex(Le, ce.name), ve.set(ce, Ie))
		}

		function je(ce, Le) {
			let Ie = h.get(Le).get(ce);
			u.get(Le) !== Ie && (r.uniformBlockBinding(Le, Ie, ce.__bindingPointIndex), u.set(Le, Ie))
		}

		function We() {
			r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), n === !0 && (r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null)), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), f = {}, oe = null, de = {}, m = {}, g = new WeakMap, y = [], d = null, p = !1, _ = null, v = null, x = null, M = null, I = null, w = null, L = null, T = !1, C = null, V = null, k = null, F = null, U = null, me.set(0, 0, r.canvas.width, r.canvas.height), P.set(0, 0, r.canvas.width, r.canvas.height), a.reset(), l.reset(), c.reset()
		}
		return {
			buffers: {
				color: a,
				depth: l,
				stencil: c
			},
			enable: A,
			disable: G,
			bindFramebuffer: J,
			drawBuffers: $,
			useProgram: le,
			setBlending: Q,
			setMaterial: he,
			setFlipSided: ye,
			setCullFace: Ee,
			setLineWidth: ie,
			setPolygonOffset: q,
			setScissorTest: Me,
			activeTexture: Pe,
			bindTexture: Ke,
			unbindTexture: R,
			compressedTexImage2D: E,
			compressedTexImage3D: B,
			texImage2D: _e,
			texImage3D: Se,
			updateUBOMapping: ke,
			uniformBlockBinding: je,
			texStorage2D: ue,
			texStorage3D: se,
			texSubImage2D: ne,
			texSubImage3D: X,
			compressedTexSubImage2D: ae,
			compressedTexSubImage3D: ge,
			scissor: Ne,
			viewport: Fe,
			reset: We
		}
	}

	function $E(r, e, t, n, i, s, o) {
		let a = i.isWebGL2,
			l = i.maxTextures,
			c = i.maxCubemapSize,
			u = i.maxTextureSize,
			h = i.maxSamples,
			f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
			m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
			g = new WeakMap,
			y, d = new WeakMap,
			p = !1;
		try {
			p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
		} catch {}

		function _(R, E) {
			return p ? new OffscreenCanvas(R, E) : wl("canvas")
		}

		function v(R, E, B, ne) {
			let X = 1;
			if ((R.width > ne || R.height > ne) && (X = ne / Math.max(R.width, R.height)), X < 1 || E === !0)
				if (typeof HTMLImageElement < "u" && R instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && R instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && R instanceof ImageBitmap) {
					let ae = E ? vu : Math.floor,
						ge = ae(X * R.width),
						ue = ae(X * R.height);
					y === void 0 && (y = _(ge, ue));
					let se = B ? _(ge, ue) : y;
					return se.width = ge, se.height = ue, se.getContext("2d").drawImage(R, 0, 0, ge, ue), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + R.width + "x" + R.height + ") to (" + ge + "x" + ue + ")."), se
				} else return "data" in R && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + R.width + "x" + R.height + ")."), R;
			return R
		}

		function x(R) {
			return mf(R.width) && mf(R.height)
		}

		function M(R) {
			return a ? !1 : R.wrapS !== Wt || R.wrapT !== Wt || R.minFilter !== pn && R.minFilter !== mn
		}

		function I(R, E) {
			return R.generateMipmaps && E && R.minFilter !== pn && R.minFilter !== mn
		}

		function w(R) {
			r.generateMipmap(R)
		}

		function L(R, E, B, ne, X = !1) {
			if (a === !1) return E;
			if (R !== null) {
				if (r[R] !== void 0) return r[R];
				console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + R + "'")
			}
			let ae = E;
			return E === r.RED && (B === r.FLOAT && (ae = r.R32F), B === r.HALF_FLOAT && (ae = r.R16F), B === r.UNSIGNED_BYTE && (ae = r.R8)), E === r.RG && (B === r.FLOAT && (ae = r.RG32F), B === r.HALF_FLOAT && (ae = r.RG16F), B === r.UNSIGNED_BYTE && (ae = r.RG8)), E === r.RGBA && (B === r.FLOAT && (ae = r.RGBA32F), B === r.HALF_FLOAT && (ae = r.RGBA16F), B === r.UNSIGNED_BYTE && (ae = ne === ot && X === !1 ? r.SRGB8_ALPHA8 : r.RGBA8), B === r.UNSIGNED_SHORT_4_4_4_4 && (ae = r.RGBA4), B === r.UNSIGNED_SHORT_5_5_5_1 && (ae = r.RGB5_A1)), (ae === r.R16F || ae === r.R32F || ae === r.RG16F || ae === r.RG32F || ae === r.RGBA16F || ae === r.RGBA32F) && e.get("EXT_color_buffer_float"), ae
		}

		function T(R, E, B) {
			return I(R, B) === !0 || R.isFramebufferTexture && R.minFilter !== pn && R.minFilter !== mn ? Math.log2(Math.max(E.width, E.height)) + 1 : R.mipmaps !== void 0 && R.mipmaps.length > 0 ? R.mipmaps.length : R.isCompressedTexture && Array.isArray(R.image) ? E.mipmaps.length : 1
		}

		function C(R) {
			return R === pn || R === Dp || R === Ch ? r.NEAREST : r.LINEAR
		}

		function V(R) {
			let E = R.target;
			E.removeEventListener("dispose", V), F(E), E.isVideoTexture && g.delete(E)
		}

		function k(R) {
			let E = R.target;
			E.removeEventListener("dispose", k), K(E)
		}

		function F(R) {
			let E = n.get(R);
			if (E.__webglInit === void 0) return;
			let B = R.source,
				ne = d.get(B);
			if (ne) {
				let X = ne[E.__cacheKey];
				X.usedTimes--, X.usedTimes === 0 && U(R), Object.keys(ne).length === 0 && d.delete(B)
			}
			n.remove(R)
		}

		function U(R) {
			let E = n.get(R);
			r.deleteTexture(E.__webglTexture);
			let B = R.source,
				ne = d.get(B);
			delete ne[E.__cacheKey], o.memory.textures--
		}

		function K(R) {
			let E = R.texture,
				B = n.get(R),
				ne = n.get(E);
			if (ne.__webglTexture !== void 0 && (r.deleteTexture(ne.__webglTexture), o.memory.textures--), R.depthTexture && R.depthTexture.dispose(), R.isWebGLCubeRenderTarget)
				for (let X = 0; X < 6; X++) r.deleteFramebuffer(B.__webglFramebuffer[X]), B.__webglDepthbuffer && r.deleteRenderbuffer(B.__webglDepthbuffer[X]);
			else {
				if (r.deleteFramebuffer(B.__webglFramebuffer), B.__webglDepthbuffer && r.deleteRenderbuffer(B.__webglDepthbuffer), B.__webglMultisampledFramebuffer && r.deleteFramebuffer(B.__webglMultisampledFramebuffer), B.__webglColorRenderbuffer)
					for (let X = 0; X < B.__webglColorRenderbuffer.length; X++) B.__webglColorRenderbuffer[X] && r.deleteRenderbuffer(B.__webglColorRenderbuffer[X]);
				B.__webglDepthRenderbuffer && r.deleteRenderbuffer(B.__webglDepthRenderbuffer)
			}
			if (R.isWebGLMultipleRenderTargets)
				for (let X = 0, ae = E.length; X < ae; X++) {
					let ge = n.get(E[X]);
					ge.__webglTexture && (r.deleteTexture(ge.__webglTexture), o.memory.textures--), n.remove(E[X])
				}
			n.remove(E), n.remove(R)
		}
		let Z = 0;

		function Y() {
			Z = 0
		}

		function H() {
			let R = Z;
			return R >= l && console.warn("THREE.WebGLTextures: Trying to use " + R + " texture units while this GPU supports only " + l), Z += 1, R
		}

		function oe(R) {
			let E = [];
			return E.push(R.wrapS), E.push(R.wrapT), E.push(R.wrapR || 0), E.push(R.magFilter), E.push(R.minFilter), E.push(R.anisotropy), E.push(R.internalFormat), E.push(R.format), E.push(R.type), E.push(R.generateMipmaps), E.push(R.premultiplyAlpha), E.push(R.flipY), E.push(R.unpackAlignment), E.push(R.colorSpace), E.join()
		}

		function de(R, E) {
			let B = n.get(R);
			if (R.isVideoTexture && Pe(R), R.isRenderTargetTexture === !1 && R.version > 0 && B.__version !== R.version) {
				let ne = R.image;
				if (ne === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
				else if (ne.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
				else {
					J(B, R, E);
					return
				}
			}
			t.bindTexture(r.TEXTURE_2D, B.__webglTexture, r.TEXTURE0 + E)
		}

		function te(R, E) {
			let B = n.get(R);
			if (R.version > 0 && B.__version !== R.version) {
				J(B, R, E);
				return
			}
			t.bindTexture(r.TEXTURE_2D_ARRAY, B.__webglTexture, r.TEXTURE0 + E)
		}

		function fe(R, E) {
			let B = n.get(R);
			if (R.version > 0 && B.__version !== R.version) {
				J(B, R, E);
				return
			}
			t.bindTexture(r.TEXTURE_3D, B.__webglTexture, r.TEXTURE0 + E)
		}

		function me(R, E) {
			let B = n.get(R);
			if (R.version > 0 && B.__version !== R.version) {
				$(B, R, E);
				return
			}
			t.bindTexture(r.TEXTURE_CUBE_MAP, B.__webglTexture, r.TEXTURE0 + E)
		}
		let P = {
				[Qt]: r.REPEAT,
				[Wt]: r.CLAMP_TO_EDGE,
				[ia]: r.MIRRORED_REPEAT
			},
			b = {
				[pn]: r.NEAREST,
				[Dp]: r.NEAREST_MIPMAP_NEAREST,
				[Ch]: r.NEAREST_MIPMAP_LINEAR,
				[mn]: r.LINEAR,
				[Iy]: r.LINEAR_MIPMAP_NEAREST,
				[ki]: r.LINEAR_MIPMAP_LINEAR
			},
			S = {
				[Xy]: r.NEVER,
				[$y]: r.ALWAYS,
				[qy]: r.LESS,
				[Yy]: r.LEQUAL,
				[jy]: r.EQUAL,
				[Jy]: r.GEQUAL,
				[Ky]: r.GREATER,
				[Zy]: r.NOTEQUAL
			};

		function A(R, E, B) {
			if (B ? (r.texParameteri(R, r.TEXTURE_WRAP_S, P[E.wrapS]), r.texParameteri(R, r.TEXTURE_WRAP_T, P[E.wrapT]), (R === r.TEXTURE_3D || R === r.TEXTURE_2D_ARRAY) && r.texParameteri(R, r.TEXTURE_WRAP_R, P[E.wrapR]), r.texParameteri(R, r.TEXTURE_MAG_FILTER, b[E.magFilter]), r.texParameteri(R, r.TEXTURE_MIN_FILTER, b[E.minFilter])) : (r.texParameteri(R, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(R, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), (R === r.TEXTURE_3D || R === r.TEXTURE_2D_ARRAY) && r.texParameteri(R, r.TEXTURE_WRAP_R, r.CLAMP_TO_EDGE), (E.wrapS !== Wt || E.wrapT !== Wt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), r.texParameteri(R, r.TEXTURE_MAG_FILTER, C(E.magFilter)), r.texParameteri(R, r.TEXTURE_MIN_FILTER, C(E.minFilter)), E.minFilter !== pn && E.minFilter !== mn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), E.compareFunction && (r.texParameteri(R, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(R, r.TEXTURE_COMPARE_FUNC, S[E.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
				let ne = e.get("EXT_texture_filter_anisotropic");
				if (E.magFilter === pn || E.minFilter !== Ch && E.minFilter !== ki || E.type === Or && e.has("OES_texture_float_linear") === !1 || a === !1 && E.type === Al && e.has("OES_texture_half_float_linear") === !1) return;
				(E.anisotropy > 1 || n.get(E).__currentAnisotropy) && (r.texParameterf(R, ne.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(E.anisotropy, i.getMaxAnisotropy())), n.get(E).__currentAnisotropy = E.anisotropy)
			}
		}

		function G(R, E) {
			let B = !1;
			R.__webglInit === void 0 && (R.__webglInit = !0, E.addEventListener("dispose", V));
			let ne = E.source,
				X = d.get(ne);
			X === void 0 && (X = {}, d.set(ne, X));
			let ae = oe(E);
			if (ae !== R.__cacheKey) {
				X[ae] === void 0 && (X[ae] = {
					texture: r.createTexture(),
					usedTimes: 0
				}, o.memory.textures++, B = !0), X[ae].usedTimes++;
				let ge = X[R.__cacheKey];
				ge !== void 0 && (X[R.__cacheKey].usedTimes--, ge.usedTimes === 0 && U(E)), R.__cacheKey = ae, R.__webglTexture = X[ae].texture
			}
			return B
		}

		function J(R, E, B) {
			let ne = r.TEXTURE_2D;
			(E.isDataArrayTexture || E.isCompressedArrayTexture) && (ne = r.TEXTURE_2D_ARRAY), E.isData3DTexture && (ne = r.TEXTURE_3D);
			let X = G(R, E),
				ae = E.source;
			t.bindTexture(ne, R.__webglTexture, r.TEXTURE0 + B);
			let ge = n.get(ae);
			if (ae.version !== ge.__version || X === !0) {
				t.activeTexture(r.TEXTURE0 + B), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
				let ue = M(E) && x(E.image) === !1,
					se = v(E.image, ue, !1, u);
				se = Ke(E, se);
				let _e = x(se) || a,
					Se = s.convert(E.format, E.colorSpace),
					Ne = s.convert(E.type),
					Fe = L(E.internalFormat, Se, Ne, E.colorSpace);
				A(ne, E, _e);
				let ke, je = E.mipmaps,
					We = a && E.isVideoTexture !== !0,
					ce = ge.__version === void 0 || X === !0,
					Le = T(E, se, _e);
				if (E.isDepthTexture) Fe = r.DEPTH_COMPONENT, a ? E.type === Or ? Fe = r.DEPTH_COMPONENT32F : E.type === ns ? Fe = r.DEPTH_COMPONENT24 : E.type === Bs ? Fe = r.DEPTH24_STENCIL8 : Fe = r.DEPTH_COMPONENT16 : E.type === Or && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), E.format === Gs && Fe === r.DEPTH_COMPONENT && E.type !== Jf && E.type !== ns && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), E.type = ns, Ne = s.convert(E.type)), E.format === ra && Fe === r.DEPTH_COMPONENT && (Fe = r.DEPTH_STENCIL, E.type !== Bs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), E.type = Bs, Ne = s.convert(E.type))), ce && (We ? t.texStorage2D(r.TEXTURE_2D, 1, Fe, se.width, se.height) : t.texImage2D(r.TEXTURE_2D, 0, Fe, se.width, se.height, 0, Se, Ne, null));
				else if (E.isDataTexture)
					if (je.length > 0 && _e) {
						We && ce && t.texStorage2D(r.TEXTURE_2D, Le, Fe, je[0].width, je[0].height);
						for (let ve = 0, Ie = je.length; ve < Ie; ve++) ke = je[ve], We ? t.texSubImage2D(r.TEXTURE_2D, ve, 0, 0, ke.width, ke.height, Se, Ne, ke.data) : t.texImage2D(r.TEXTURE_2D, ve, Fe, ke.width, ke.height, 0, Se, Ne, ke.data);
						E.generateMipmaps = !1
					} else We ? (ce && t.texStorage2D(r.TEXTURE_2D, Le, Fe, se.width, se.height), t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, se.width, se.height, Se, Ne, se.data)) : t.texImage2D(r.TEXTURE_2D, 0, Fe, se.width, se.height, 0, Se, Ne, se.data);
				else if (E.isCompressedTexture)
					if (E.isCompressedArrayTexture) {
						We && ce && t.texStorage3D(r.TEXTURE_2D_ARRAY, Le, Fe, je[0].width, je[0].height, se.depth);
						for (let ve = 0, Ie = je.length; ve < Ie; ve++) ke = je[ve], E.format !== xi ? Se !== null ? We ? t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, ve, 0, 0, 0, ke.width, ke.height, se.depth, Se, ke.data, 0, 0) : t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, ve, Fe, ke.width, ke.height, se.depth, 0, ke.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : We ? t.texSubImage3D(r.TEXTURE_2D_ARRAY, ve, 0, 0, 0, ke.width, ke.height, se.depth, Se, Ne, ke.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, ve, Fe, ke.width, ke.height, se.depth, 0, Se, Ne, ke.data)
					} else {
						We && ce && t.texStorage2D(r.TEXTURE_2D, Le, Fe, je[0].width, je[0].height);
						for (let ve = 0, Ie = je.length; ve < Ie; ve++) ke = je[ve], E.format !== xi ? Se !== null ? We ? t.compressedTexSubImage2D(r.TEXTURE_2D, ve, 0, 0, ke.width, ke.height, Se, ke.data) : t.compressedTexImage2D(r.TEXTURE_2D, ve, Fe, ke.width, ke.height, 0, ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : We ? t.texSubImage2D(r.TEXTURE_2D, ve, 0, 0, ke.width, ke.height, Se, Ne, ke.data) : t.texImage2D(r.TEXTURE_2D, ve, Fe, ke.width, ke.height, 0, Se, Ne, ke.data)
					}
				else if (E.isDataArrayTexture) We ? (ce && t.texStorage3D(r.TEXTURE_2D_ARRAY, Le, Fe, se.width, se.height, se.depth), t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, se.width, se.height, se.depth, Se, Ne, se.data)) : t.texImage3D(r.TEXTURE_2D_ARRAY, 0, Fe, se.width, se.height, se.depth, 0, Se, Ne, se.data);
				else if (E.isData3DTexture) We ? (ce && t.texStorage3D(r.TEXTURE_3D, Le, Fe, se.width, se.height, se.depth), t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, se.width, se.height, se.depth, Se, Ne, se.data)) : t.texImage3D(r.TEXTURE_3D, 0, Fe, se.width, se.height, se.depth, 0, Se, Ne, se.data);
				else if (E.isFramebufferTexture) {
					if (ce)
						if (We) t.texStorage2D(r.TEXTURE_2D, Le, Fe, se.width, se.height);
						else {
							let ve = se.width,
								Ie = se.height;
							for (let De = 0; De < Le; De++) t.texImage2D(r.TEXTURE_2D, De, Fe, ve, Ie, 0, Se, Ne, null), ve >>= 1, Ie >>= 1
						}
				} else if (je.length > 0 && _e) {
					We && ce && t.texStorage2D(r.TEXTURE_2D, Le, Fe, je[0].width, je[0].height);
					for (let ve = 0, Ie = je.length; ve < Ie; ve++) ke = je[ve], We ? t.texSubImage2D(r.TEXTURE_2D, ve, 0, 0, Se, Ne, ke) : t.texImage2D(r.TEXTURE_2D, ve, Fe, Se, Ne, ke);
					E.generateMipmaps = !1
				} else We ? (ce && t.texStorage2D(r.TEXTURE_2D, Le, Fe, se.width, se.height), t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Se, Ne, se)) : t.texImage2D(r.TEXTURE_2D, 0, Fe, Se, Ne, se);
				I(E, _e) && w(ne), ge.__version = ae.version, E.onUpdate && E.onUpdate(E)
			}
			R.__version = E.version
		}

		function $(R, E, B) {
			if (E.image.length !== 6) return;
			let ne = G(R, E),
				X = E.source;
			t.bindTexture(r.TEXTURE_CUBE_MAP, R.__webglTexture, r.TEXTURE0 + B);
			let ae = n.get(X);
			if (X.version !== ae.__version || ne === !0) {
				t.activeTexture(r.TEXTURE0 + B), r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
				let ge = E.isCompressedTexture || E.image[0].isCompressedTexture,
					ue = E.image[0] && E.image[0].isDataTexture,
					se = [];
				for (let ve = 0; ve < 6; ve++) !ge && !ue ? se[ve] = v(E.image[ve], !1, !0, c) : se[ve] = ue ? E.image[ve].image : E.image[ve], se[ve] = Ke(E, se[ve]);
				let _e = se[0],
					Se = x(_e) || a,
					Ne = s.convert(E.format, E.colorSpace),
					Fe = s.convert(E.type),
					ke = L(E.internalFormat, Ne, Fe, E.colorSpace),
					je = a && E.isVideoTexture !== !0,
					We = ae.__version === void 0 || ne === !0,
					ce = T(E, _e, Se);
				A(r.TEXTURE_CUBE_MAP, E, Se);
				let Le;
				if (ge) {
					je && We && t.texStorage2D(r.TEXTURE_CUBE_MAP, ce, ke, _e.width, _e.height);
					for (let ve = 0; ve < 6; ve++) {
						Le = se[ve].mipmaps;
						for (let Ie = 0; Ie < Le.length; Ie++) {
							let De = Le[Ie];
							E.format !== xi ? Ne !== null ? je ? t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie, 0, 0, De.width, De.height, Ne, De.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie, ke, De.width, De.height, 0, De.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : je ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie, 0, 0, De.width, De.height, Ne, Fe, De.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie, ke, De.width, De.height, 0, Ne, Fe, De.data)
						}
					}
				} else {
					Le = E.mipmaps, je && We && (Le.length > 0 && ce++, t.texStorage2D(r.TEXTURE_CUBE_MAP, ce, ke, se[0].width, se[0].height));
					for (let ve = 0; ve < 6; ve++)
						if (ue) {
							je ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, 0, 0, se[ve].width, se[ve].height, Ne, Fe, se[ve].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, ke, se[ve].width, se[ve].height, 0, Ne, Fe, se[ve].data);
							for (let Ie = 0; Ie < Le.length; Ie++) {
								let et = Le[Ie].image[ve].image;
								je ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie + 1, 0, 0, et.width, et.height, Ne, Fe, et.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie + 1, ke, et.width, et.height, 0, Ne, Fe, et.data)
							}
						} else {
							je ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, 0, 0, Ne, Fe, se[ve]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, 0, ke, Ne, Fe, se[ve]);
							for (let Ie = 0; Ie < Le.length; Ie++) {
								let De = Le[Ie];
								je ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie + 1, 0, 0, Ne, Fe, De.image[ve]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ve, Ie + 1, ke, Ne, Fe, De.image[ve])
							}
						}
				}
				I(E, Se) && w(r.TEXTURE_CUBE_MAP), ae.__version = X.version, E.onUpdate && E.onUpdate(E)
			}
			R.__version = E.version
		}

		function le(R, E, B, ne, X) {
			let ae = s.convert(B.format, B.colorSpace),
				ge = s.convert(B.type),
				ue = L(B.internalFormat, ae, ge, B.colorSpace);
			n.get(E).__hasExternalTextures || (X === r.TEXTURE_3D || X === r.TEXTURE_2D_ARRAY ? t.texImage3D(X, 0, ue, E.width, E.height, E.depth, 0, ae, ge, null) : t.texImage2D(X, 0, ue, E.width, E.height, 0, ae, ge, null)), t.bindFramebuffer(r.FRAMEBUFFER, R), Me(E) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, ne, X, n.get(B).__webglTexture, 0, q(E)) : (X === r.TEXTURE_2D || X >= r.TEXTURE_CUBE_MAP_POSITIVE_X && X <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, ne, X, n.get(B).__webglTexture, 0), t.bindFramebuffer(r.FRAMEBUFFER, null)
		}

		function N(R, E, B) {
			if (r.bindRenderbuffer(r.RENDERBUFFER, R), E.depthBuffer && !E.stencilBuffer) {
				let ne = r.DEPTH_COMPONENT16;
				if (B || Me(E)) {
					let X = E.depthTexture;
					X && X.isDepthTexture && (X.type === Or ? ne = r.DEPTH_COMPONENT32F : X.type === ns && (ne = r.DEPTH_COMPONENT24));
					let ae = q(E);
					Me(E) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ae, ne, E.width, E.height) : r.renderbufferStorageMultisample(r.RENDERBUFFER, ae, ne, E.width, E.height)
				} else r.renderbufferStorage(r.RENDERBUFFER, ne, E.width, E.height);
				r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, R)
			} else if (E.depthBuffer && E.stencilBuffer) {
				let ne = q(E);
				B && Me(E) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ne, r.DEPTH24_STENCIL8, E.width, E.height) : Me(E) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ne, r.DEPTH24_STENCIL8, E.width, E.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, E.width, E.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, R)
			} else {
				let ne = E.isWebGLMultipleRenderTargets === !0 ? E.texture : [E.texture];
				for (let X = 0; X < ne.length; X++) {
					let ae = ne[X],
						ge = s.convert(ae.format, ae.colorSpace),
						ue = s.convert(ae.type),
						se = L(ae.internalFormat, ge, ue, ae.colorSpace),
						_e = q(E);
					B && Me(E) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, _e, se, E.width, E.height) : Me(E) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, _e, se, E.width, E.height) : r.renderbufferStorage(r.RENDERBUFFER, se, E.width, E.height)
				}
			}
			r.bindRenderbuffer(r.RENDERBUFFER, null)
		}

		function pe(R, E) {
			if (E && E.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
			if (t.bindFramebuffer(r.FRAMEBUFFER, R), !(E.depthTexture && E.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
			(!n.get(E.depthTexture).__webglTexture || E.depthTexture.image.width !== E.width || E.depthTexture.image.height !== E.height) && (E.depthTexture.image.width = E.width, E.depthTexture.image.height = E.height, E.depthTexture.needsUpdate = !0), de(E.depthTexture, 0);
			let ne = n.get(E.depthTexture).__webglTexture,
				X = q(E);
			if (E.depthTexture.format === Gs) Me(E) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ne, 0, X) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ne, 0);
			else if (E.depthTexture.format === ra) Me(E) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ne, 0, X) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ne, 0);
			else throw new Error("Unknown depthTexture format")
		}

		function Q(R) {
			let E = n.get(R),
				B = R.isWebGLCubeRenderTarget === !0;
			if (R.depthTexture && !E.__autoAllocateDepthBuffer) {
				if (B) throw new Error("target.depthTexture not supported in Cube render targets");
				pe(E.__webglFramebuffer, R)
			} else if (B) {
				E.__webglDepthbuffer = [];
				for (let ne = 0; ne < 6; ne++) t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer[ne]), E.__webglDepthbuffer[ne] = r.createRenderbuffer(), N(E.__webglDepthbuffer[ne], R, !1)
			} else t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer), E.__webglDepthbuffer = r.createRenderbuffer(), N(E.__webglDepthbuffer, R, !1);
			t.bindFramebuffer(r.FRAMEBUFFER, null)
		}

		function he(R, E, B) {
			let ne = n.get(R);
			E !== void 0 && le(ne.__webglFramebuffer, R, R.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D), B !== void 0 && Q(R)
		}

		function ye(R) {
			let E = R.texture,
				B = n.get(R),
				ne = n.get(E);
			R.addEventListener("dispose", k), R.isWebGLMultipleRenderTargets !== !0 && (ne.__webglTexture === void 0 && (ne.__webglTexture = r.createTexture()), ne.__version = E.version, o.memory.textures++);
			let X = R.isWebGLCubeRenderTarget === !0,
				ae = R.isWebGLMultipleRenderTargets === !0,
				ge = x(R) || a;
			if (X) {
				B.__webglFramebuffer = [];
				for (let ue = 0; ue < 6; ue++) B.__webglFramebuffer[ue] = r.createFramebuffer()
			} else {
				if (B.__webglFramebuffer = r.createFramebuffer(), ae)
					if (i.drawBuffers) {
						let ue = R.texture;
						for (let se = 0, _e = ue.length; se < _e; se++) {
							let Se = n.get(ue[se]);
							Se.__webglTexture === void 0 && (Se.__webglTexture = r.createTexture(), o.memory.textures++)
						}
					} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
				if (a && R.samples > 0 && Me(R) === !1) {
					let ue = ae ? E : [E];
					B.__webglMultisampledFramebuffer = r.createFramebuffer(), B.__webglColorRenderbuffer = [], t.bindFramebuffer(r.FRAMEBUFFER, B.__webglMultisampledFramebuffer);
					for (let se = 0; se < ue.length; se++) {
						let _e = ue[se];
						B.__webglColorRenderbuffer[se] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, B.__webglColorRenderbuffer[se]);
						let Se = s.convert(_e.format, _e.colorSpace),
							Ne = s.convert(_e.type),
							Fe = L(_e.internalFormat, Se, Ne, _e.colorSpace, R.isXRRenderTarget === !0),
							ke = q(R);
						r.renderbufferStorageMultisample(r.RENDERBUFFER, ke, Fe, R.width, R.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + se, r.RENDERBUFFER, B.__webglColorRenderbuffer[se])
					}
					r.bindRenderbuffer(r.RENDERBUFFER, null), R.depthBuffer && (B.__webglDepthRenderbuffer = r.createRenderbuffer(), N(B.__webglDepthRenderbuffer, R, !0)), t.bindFramebuffer(r.FRAMEBUFFER, null)
				}
			}
			if (X) {
				t.bindTexture(r.TEXTURE_CUBE_MAP, ne.__webglTexture), A(r.TEXTURE_CUBE_MAP, E, ge);
				for (let ue = 0; ue < 6; ue++) le(B.__webglFramebuffer[ue], R, E, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ue);
				I(E, ge) && w(r.TEXTURE_CUBE_MAP), t.unbindTexture()
			} else if (ae) {
				let ue = R.texture;
				for (let se = 0, _e = ue.length; se < _e; se++) {
					let Se = ue[se],
						Ne = n.get(Se);
					t.bindTexture(r.TEXTURE_2D, Ne.__webglTexture), A(r.TEXTURE_2D, Se, ge), le(B.__webglFramebuffer, R, Se, r.COLOR_ATTACHMENT0 + se, r.TEXTURE_2D), I(Se, ge) && w(r.TEXTURE_2D)
				}
				t.unbindTexture()
			} else {
				let ue = r.TEXTURE_2D;
				(R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) && (a ? ue = R.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(ue, ne.__webglTexture), A(ue, E, ge), le(B.__webglFramebuffer, R, E, r.COLOR_ATTACHMENT0, ue), I(E, ge) && w(ue), t.unbindTexture()
			}
			R.depthBuffer && Q(R)
		}

		function Ee(R) {
			let E = x(R) || a,
				B = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture];
			for (let ne = 0, X = B.length; ne < X; ne++) {
				let ae = B[ne];
				if (I(ae, E)) {
					let ge = R.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D,
						ue = n.get(ae).__webglTexture;
					t.bindTexture(ge, ue), w(ge), t.unbindTexture()
				}
			}
		}

		function ie(R) {
			if (a && R.samples > 0 && Me(R) === !1) {
				let E = R.isWebGLMultipleRenderTargets ? R.texture : [R.texture],
					B = R.width,
					ne = R.height,
					X = r.COLOR_BUFFER_BIT,
					ae = [],
					ge = R.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
					ue = n.get(R),
					se = R.isWebGLMultipleRenderTargets === !0;
				if (se)
					for (let _e = 0; _e < E.length; _e++) t.bindFramebuffer(r.FRAMEBUFFER, ue.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + _e, r.RENDERBUFFER, null), t.bindFramebuffer(r.FRAMEBUFFER, ue.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + _e, r.TEXTURE_2D, null, 0);
				t.bindFramebuffer(r.READ_FRAMEBUFFER, ue.__webglMultisampledFramebuffer), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ue.__webglFramebuffer);
				for (let _e = 0; _e < E.length; _e++) {
					ae.push(r.COLOR_ATTACHMENT0 + _e), R.depthBuffer && ae.push(ge);
					let Se = ue.__ignoreDepthValues !== void 0 ? ue.__ignoreDepthValues : !1;
					if (Se === !1 && (R.depthBuffer && (X |= r.DEPTH_BUFFER_BIT), R.stencilBuffer && (X |= r.STENCIL_BUFFER_BIT)), se && r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, ue.__webglColorRenderbuffer[_e]), Se === !0 && (r.invalidateFramebuffer(r.READ_FRAMEBUFFER, [ge]), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [ge])), se) {
						let Ne = n.get(E[_e]).__webglTexture;
						r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Ne, 0)
					}
					r.blitFramebuffer(0, 0, B, ne, 0, 0, B, ne, X, r.NEAREST), m && r.invalidateFramebuffer(r.READ_FRAMEBUFFER, ae)
				}
				if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), se)
					for (let _e = 0; _e < E.length; _e++) {
						t.bindFramebuffer(r.FRAMEBUFFER, ue.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + _e, r.RENDERBUFFER, ue.__webglColorRenderbuffer[_e]);
						let Se = n.get(E[_e]).__webglTexture;
						t.bindFramebuffer(r.FRAMEBUFFER, ue.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + _e, r.TEXTURE_2D, Se, 0)
					}
				t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ue.__webglMultisampledFramebuffer)
			}
		}

		function q(R) {
			return Math.min(h, R.samples)
		}

		function Me(R) {
			let E = n.get(R);
			return a && R.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && E.__useRenderToTexture !== !1
		}

		function Pe(R) {
			let E = o.render.frame;
			g.get(R) !== E && (g.set(R, E), R.update())
		}

		function Ke(R, E) {
			let B = R.colorSpace,
				ne = R.format,
				X = R.type;
			return R.isCompressedTexture === !0 || R.format === pf || B !== Bn && B !== zs && (B === ot ? a === !1 ? e.has("EXT_sRGB") === !0 && ne === xi ? (R.format = pf, R.minFilter = mn, R.generateMipmaps = !1) : E = Hs.sRGBToLinear(E) : (ne !== xi || X !== rs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", B)), E
		}
		this.allocateTextureUnit = H, this.resetTextureUnits = Y, this.setTexture2D = de, this.setTexture2DArray = te, this.setTexture3D = fe, this.setTextureCube = me, this.rebindTextures = he, this.setupRenderTarget = ye, this.updateRenderTargetMipmap = Ee, this.updateMultisampleRenderTarget = ie, this.setupDepthRenderbuffer = Q, this.setupFrameBufferTexture = le, this.useMultisampledRTT = Me
	}

	function QE(r, e, t) {
		let n = t.isWebGL2;

		function i(s, o = zs) {
			let a;
			if (s === rs) return r.UNSIGNED_BYTE;
			if (s === Tg) return r.UNSIGNED_SHORT_4_4_4_4;
			if (s === Eg) return r.UNSIGNED_SHORT_5_5_5_1;
			if (s === Py) return r.BYTE;
			if (s === Ly) return r.SHORT;
			if (s === Jf) return r.UNSIGNED_SHORT;
			if (s === _g) return r.INT;
			if (s === ns) return r.UNSIGNED_INT;
			if (s === Or) return r.FLOAT;
			if (s === Al) return n ? r.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
			if (s === Ny) return r.ALPHA;
			if (s === xi) return r.RGBA;
			if (s === Oy) return r.LUMINANCE;
			if (s === Dy) return r.LUMINANCE_ALPHA;
			if (s === Gs) return r.DEPTH_COMPONENT;
			if (s === ra) return r.DEPTH_STENCIL;
			if (s === pf) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
			if (s === Fy) return r.RED;
			if (s === Mg) return r.RED_INTEGER;
			if (s === Uy) return r.RG;
			if (s === bg) return r.RG_INTEGER;
			if (s === Sg) return r.RGBA_INTEGER;
			if (s === Rh || s === Ih || s === Ph || s === Lh)
				if (o === ot)
					if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
						if (s === Rh) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if (s === Ih) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if (s === Ph) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if (s === Lh) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
					} else return null;
			else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
				if (s === Rh) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (s === Ih) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (s === Ph) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (s === Lh) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
			} else return null;
			if (s === Fp || s === Up || s === kp || s === Bp)
				if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
					if (s === Fp) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (s === Up) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (s === kp) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (s === Bp) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
				} else return null;
			if (s === ky) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
			if (s === Gp || s === Vp)
				if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
					if (s === Gp) return o === ot ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
					if (s === Vp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
				} else return null;
			if (s === zp || s === Hp || s === Wp || s === Xp || s === qp || s === jp || s === Yp || s === Kp || s === Zp || s === Jp || s === $p || s === Qp || s === em || s === tm)
				if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
					if (s === zp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if (s === Hp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if (s === Wp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if (s === Xp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if (s === qp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if (s === jp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if (s === Yp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if (s === Kp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if (s === Zp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if (s === Jp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if (s === $p) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if (s === Qp) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if (s === em) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if (s === tm) return o === ot ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
				} else return null;
			if (s === Nh)
				if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
					if (s === Nh) return o === ot ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
				} else return null;
			if (s === By || s === nm || s === im || s === rm)
				if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
					if (s === Nh) return a.COMPRESSED_RED_RGTC1_EXT;
					if (s === nm) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
					if (s === im) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
					if (s === rm) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
				} else return null;
			return s === Bs ? n ? r.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : r[s] !== void 0 ? r[s] : null
		}
		return {
			convert: i
		}
	}
	var wf = class extends Yt {
			constructor(e = []) {
				super(), this.isArrayCamera = !0, this.cameras = e
			}
		},
		cn = class extends Rt {
			constructor() {
				super(), this.isGroup = !0, this.type = "Group"
			}
		},
		eM = {
			type: "move"
		},
		El = class {
			constructor() {
				this._targetRay = null, this._grip = null, this._hand = null
			}
			getHandSpace() {
				return this._hand === null && (this._hand = new cn, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
					pinching: !1
				}), this._hand
			}
			getTargetRaySpace() {
				return this._targetRay === null && (this._targetRay = new cn, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new re, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new re), this._targetRay
			}
			getGripSpace() {
				return this._grip === null && (this._grip = new cn, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new re, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new re), this._grip
			}
			dispatchEvent(e) {
				return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
			}
			connect(e) {
				if (e && e.hand) {
					let t = this._hand;
					if (t)
						for (let n of e.hand.values()) this._getHandJoint(t, n)
				}
				return this.dispatchEvent({
					type: "connected",
					data: e
				}), this
			}
			disconnect(e) {
				return this.dispatchEvent({
					type: "disconnected",
					data: e
				}), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
			}
			update(e, t, n) {
				let i = null,
					s = null,
					o = null,
					a = this._targetRay,
					l = this._grip,
					c = this._hand;
				if (e && t.session.visibilityState !== "visible-blurred") {
					if (c && e.hand) {
						o = !0;
						for (let y of e.hand.values()) {
							let d = t.getJointPose(y, n),
								p = this._getHandJoint(c, y);
							d !== null && (p.matrix.fromArray(d.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = d.radius), p.visible = d !== null
						}
						let u = c.joints["index-finger-tip"],
							h = c.joints["thumb-tip"],
							f = u.position.distanceTo(h.position),
							m = .02,
							g = .005;
						c.inputState.pinching && f > m + g ? (c.inputState.pinching = !1, this.dispatchEvent({
							type: "pinchend",
							handedness: e.handedness,
							target: this
						})) : !c.inputState.pinching && f <= m - g && (c.inputState.pinching = !0, this.dispatchEvent({
							type: "pinchstart",
							handedness: e.handedness,
							target: this
						}))
					} else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
					a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(eM)))
				}
				return a !== null && (a.visible = i !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this
			}
			_getHandJoint(e, t) {
				if (e.joints[t.jointName] === void 0) {
					let n = new cn;
					n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
				}
				return e.joints[t.jointName]
			}
		},
		Cf = class extends Gn {
			constructor(e, t, n, i, s, o, a, l, c, u) {
				if (u = u !== void 0 ? u : Gs, u !== Gs && u !== ra) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
				n === void 0 && u === Gs && (n = ns), n === void 0 && u === ra && (n = Bs), super(null, i, s, o, a, l, u, n, c), this.isDepthTexture = !0, this.image = {
					width: e,
					height: t
				}, this.magFilter = a !== void 0 ? a : pn, this.minFilter = l !== void 0 ? l : pn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
			}
			copy(e) {
				return super.copy(e), this.compareFunction = e.compareFunction, this
			}
			toJSON(e) {
				let t = super.toJSON(e);
				return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
			}
		},
		Rf = class extends os {
			constructor(e, t) {
				super();
				let n = this,
					i = null,
					s = 1,
					o = null,
					a = "local-floor",
					l = 1,
					c = null,
					u = null,
					h = null,
					f = null,
					m = null,
					g = null,
					y = t.getContextAttributes(),
					d = null,
					p = null,
					_ = [],
					v = [],
					x = new Yt;
				x.layers.enable(1), x.viewport = new Ct;
				let M = new Yt;
				M.layers.enable(2), M.viewport = new Ct;
				let I = [x, M],
					w = new wf;
				w.layers.enable(1), w.layers.enable(2);
				let L = null,
					T = null;
				this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(te) {
					let fe = _[te];
					return fe === void 0 && (fe = new El, _[te] = fe), fe.getTargetRaySpace()
				}, this.getControllerGrip = function(te) {
					let fe = _[te];
					return fe === void 0 && (fe = new El, _[te] = fe), fe.getGripSpace()
				}, this.getHand = function(te) {
					let fe = _[te];
					return fe === void 0 && (fe = new El, _[te] = fe), fe.getHandSpace()
				};

				function C(te) {
					let fe = v.indexOf(te.inputSource);
					if (fe === -1) return;
					let me = _[fe];
					me !== void 0 && (me.update(te.inputSource, te.frame, c || o), me.dispatchEvent({
						type: te.type,
						data: te.inputSource
					}))
				}

				function V() {
					i.removeEventListener("select", C), i.removeEventListener("selectstart", C), i.removeEventListener("selectend", C), i.removeEventListener("squeeze", C), i.removeEventListener("squeezestart", C), i.removeEventListener("squeezeend", C), i.removeEventListener("end", V), i.removeEventListener("inputsourceschange", k);
					for (let te = 0; te < _.length; te++) {
						let fe = v[te];
						fe !== null && (v[te] = null, _[te].disconnect(fe))
					}
					L = null, T = null, e.setRenderTarget(d), m = null, f = null, h = null, i = null, p = null, de.stop(), n.isPresenting = !1, n.dispatchEvent({
						type: "sessionend"
					})
				}
				this.setFramebufferScaleFactor = function(te) {
					s = te, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
				}, this.setReferenceSpaceType = function(te) {
					a = te, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
				}, this.getReferenceSpace = function() {
					return c || o
				}, this.setReferenceSpace = function(te) {
					c = te
				}, this.getBaseLayer = function() {
					return f !== null ? f : m
				}, this.getBinding = function() {
					return h
				}, this.getFrame = function() {
					return g
				}, this.getSession = function() {
					return i
				}, this.setSession = async function(te) {
					if (i = te, i !== null) {
						if (d = e.getRenderTarget(), i.addEventListener("select", C), i.addEventListener("selectstart", C), i.addEventListener("selectend", C), i.addEventListener("squeeze", C), i.addEventListener("squeezestart", C), i.addEventListener("squeezeend", C), i.addEventListener("end", V), i.addEventListener("inputsourceschange", k), y.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
							let fe = {
								antialias: i.renderState.layers === void 0 ? y.antialias : !0,
								alpha: !0,
								depth: y.depth,
								stencil: y.stencil,
								framebufferScaleFactor: s
							};
							m = new XRWebGLLayer(i, t, fe), i.updateRenderState({
								baseLayer: m
							}), p = new Ur(m.framebufferWidth, m.framebufferHeight, {
								format: xi,
								type: rs,
								colorSpace: e.outputColorSpace,
								stencilBuffer: y.stencil
							})
						} else {
							let fe = null,
								me = null,
								P = null;
							y.depth && (P = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, fe = y.stencil ? ra : Gs, me = y.stencil ? Bs : ns);
							let b = {
								colorFormat: t.RGBA8,
								depthFormat: P,
								scaleFactor: s
							};
							h = new XRWebGLBinding(i, t), f = h.createProjectionLayer(b), i.updateRenderState({
								layers: [f]
							}), p = new Ur(f.textureWidth, f.textureHeight, {
								format: xi,
								type: rs,
								depthTexture: new Cf(f.textureWidth, f.textureHeight, me, void 0, void 0, void 0, void 0, void 0, void 0, fe),
								stencilBuffer: y.stencil,
								colorSpace: e.outputColorSpace,
								samples: y.antialias ? 4 : 0
							});
							let S = e.properties.get(p);
							S.__ignoreDepthValues = f.ignoreDepthValues
						}
						p.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await i.requestReferenceSpace(a), de.setContext(i), de.start(), n.isPresenting = !0, n.dispatchEvent({
							type: "sessionstart"
						})
					}
				}, this.getEnvironmentBlendMode = function() {
					if (i !== null) return i.environmentBlendMode
				};

				function k(te) {
					for (let fe = 0; fe < te.removed.length; fe++) {
						let me = te.removed[fe],
							P = v.indexOf(me);
						P >= 0 && (v[P] = null, _[P].disconnect(me))
					}
					for (let fe = 0; fe < te.added.length; fe++) {
						let me = te.added[fe],
							P = v.indexOf(me);
						if (P === -1) {
							for (let S = 0; S < _.length; S++)
								if (S >= v.length) {
									v.push(me), P = S;
									break
								} else if (v[S] === null) {
								v[S] = me, P = S;
								break
							}
							if (P === -1) break
						}
						let b = _[P];
						b && b.connect(me)
					}
				}
				let F = new re,
					U = new re;

				function K(te, fe, me) {
					F.setFromMatrixPosition(fe.matrixWorld), U.setFromMatrixPosition(me.matrixWorld);
					let P = F.distanceTo(U),
						b = fe.projectionMatrix.elements,
						S = me.projectionMatrix.elements,
						A = b[14] / (b[10] - 1),
						G = b[14] / (b[10] + 1),
						J = (b[9] + 1) / b[5],
						$ = (b[9] - 1) / b[5],
						le = (b[8] - 1) / b[0],
						N = (S[8] + 1) / S[0],
						pe = A * le,
						Q = A * N,
						he = P / (-le + N),
						ye = he * -le;
					fe.matrixWorld.decompose(te.position, te.quaternion, te.scale), te.translateX(ye), te.translateZ(he), te.matrixWorld.compose(te.position, te.quaternion, te.scale), te.matrixWorldInverse.copy(te.matrixWorld).invert();
					let Ee = A + he,
						ie = G + he,
						q = pe - ye,
						Me = Q + (P - ye),
						Pe = J * G / ie * Ee,
						Ke = $ * G / ie * Ee;
					te.projectionMatrix.makePerspective(q, Me, Pe, Ke, Ee, ie), te.projectionMatrixInverse.copy(te.projectionMatrix).invert()
				}

				function Z(te, fe) {
					fe === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(fe.matrixWorld, te.matrix), te.matrixWorldInverse.copy(te.matrixWorld).invert()
				}
				this.updateCamera = function(te) {
					if (i === null) return;
					w.near = M.near = x.near = te.near, w.far = M.far = x.far = te.far, (L !== w.near || T !== w.far) && (i.updateRenderState({
						depthNear: w.near,
						depthFar: w.far
					}), L = w.near, T = w.far);
					let fe = te.parent,
						me = w.cameras;
					Z(w, fe);
					for (let P = 0; P < me.length; P++) Z(me[P], fe);
					me.length === 2 ? K(w, x, M) : w.projectionMatrix.copy(x.projectionMatrix), Y(te, w, fe)
				};

				function Y(te, fe, me) {
					me === null ? te.matrix.copy(fe.matrixWorld) : (te.matrix.copy(me.matrixWorld), te.matrix.invert(), te.matrix.multiply(fe.matrixWorld)), te.matrix.decompose(te.position, te.quaternion, te.scale), te.updateMatrixWorld(!0);
					let P = te.children;
					for (let b = 0, S = P.length; b < S; b++) P[b].updateMatrixWorld(!0);
					te.projectionMatrix.copy(fe.projectionMatrix), te.projectionMatrixInverse.copy(fe.projectionMatrixInverse), te.isPerspectiveCamera && (te.fov = sa * 2 * Math.atan(1 / te.projectionMatrix.elements[5]), te.zoom = 1)
				}
				this.getCamera = function() {
					return w
				}, this.getFoveation = function() {
					if (!(f === null && m === null)) return l
				}, this.setFoveation = function(te) {
					l = te, f !== null && (f.fixedFoveation = te), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = te)
				};
				let H = null;

				function oe(te, fe) {
					if (u = fe.getViewerPose(c || o), g = fe, u !== null) {
						let me = u.views;
						m !== null && (e.setRenderTargetFramebuffer(p, m.framebuffer), e.setRenderTarget(p));
						let P = !1;
						me.length !== w.cameras.length && (w.cameras.length = 0, P = !0);
						for (let b = 0; b < me.length; b++) {
							let S = me[b],
								A = null;
							if (m !== null) A = m.getViewport(S);
							else {
								let J = h.getViewSubImage(f, S);
								A = J.viewport, b === 0 && (e.setRenderTargetTextures(p, J.colorTexture, f.ignoreDepthValues ? void 0 : J.depthStencilTexture), e.setRenderTarget(p))
							}
							let G = I[b];
							G === void 0 && (G = new Yt, G.layers.enable(b), G.viewport = new Ct, I[b] = G), G.matrix.fromArray(S.transform.matrix), G.matrix.decompose(G.position, G.quaternion, G.scale), G.projectionMatrix.fromArray(S.projectionMatrix), G.projectionMatrixInverse.copy(G.projectionMatrix).invert(), G.viewport.set(A.x, A.y, A.width, A.height), b === 0 && (w.matrix.copy(G.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), P === !0 && w.cameras.push(G)
						}
					}
					for (let me = 0; me < _.length; me++) {
						let P = v[me],
							b = _[me];
						P !== null && b !== void 0 && b.update(P, fe, c || o)
					}
					H && H(te, fe), fe.detectedPlanes && n.dispatchEvent({
						type: "planesdetected",
						data: fe
					}), g = null
				}
				let de = new Lg;
				de.setAnimationLoop(oe), this.setAnimationLoop = function(te) {
					H = te
				}, this.dispose = function() {}
			}
		};

	function tM(r, e) {
		function t(d, p) {
			d.matrixAutoUpdate === !0 && d.updateMatrix(), p.value.copy(d.matrix)
		}

		function n(d, p) {
			p.color.getRGB(d.fogColor.value, Pg(r)), p.isFog ? (d.fogNear.value = p.near, d.fogFar.value = p.far) : p.isFogExp2 && (d.fogDensity.value = p.density)
		}

		function i(d, p, _, v, x) {
			p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(d, p) : p.isMeshToonMaterial ? (s(d, p), h(d, p)) : p.isMeshPhongMaterial ? (s(d, p), u(d, p)) : p.isMeshStandardMaterial ? (s(d, p), f(d, p), p.isMeshPhysicalMaterial && m(d, p, x)) : p.isMeshMatcapMaterial ? (s(d, p), g(d, p)) : p.isMeshDepthMaterial ? s(d, p) : p.isMeshDistanceMaterial ? (s(d, p), y(d, p)) : p.isMeshNormalMaterial ? s(d, p) : p.isLineBasicMaterial ? (o(d, p), p.isLineDashedMaterial && a(d, p)) : p.isPointsMaterial ? l(d, p, _, v) : p.isSpriteMaterial ? c(d, p) : p.isShadowMaterial ? (d.color.value.copy(p.color), d.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
		}

		function s(d, p) {
			d.opacity.value = p.opacity, p.color && d.diffuse.value.copy(p.color), p.emissive && d.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (d.map.value = p.map, t(p.map, d.mapTransform)), p.alphaMap && (d.alphaMap.value = p.alphaMap, t(p.alphaMap, d.alphaMapTransform)), p.bumpMap && (d.bumpMap.value = p.bumpMap, t(p.bumpMap, d.bumpMapTransform), d.bumpScale.value = p.bumpScale, p.side === gn && (d.bumpScale.value *= -1)), p.normalMap && (d.normalMap.value = p.normalMap, t(p.normalMap, d.normalMapTransform), d.normalScale.value.copy(p.normalScale), p.side === gn && d.normalScale.value.negate()), p.displacementMap && (d.displacementMap.value = p.displacementMap, t(p.displacementMap, d.displacementMapTransform), d.displacementScale.value = p.displacementScale, d.displacementBias.value = p.displacementBias), p.emissiveMap && (d.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, d.emissiveMapTransform)), p.specularMap && (d.specularMap.value = p.specularMap, t(p.specularMap, d.specularMapTransform)), p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest);
			let _ = e.get(p).envMap;
			if (_ && (d.envMap.value = _, d.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, d.reflectivity.value = p.reflectivity, d.ior.value = p.ior, d.refractionRatio.value = p.refractionRatio), p.lightMap) {
				d.lightMap.value = p.lightMap;
				let v = r.useLegacyLights === !0 ? Math.PI : 1;
				d.lightMapIntensity.value = p.lightMapIntensity * v, t(p.lightMap, d.lightMapTransform)
			}
			p.aoMap && (d.aoMap.value = p.aoMap, d.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, d.aoMapTransform))
		}

		function o(d, p) {
			d.diffuse.value.copy(p.color), d.opacity.value = p.opacity, p.map && (d.map.value = p.map, t(p.map, d.mapTransform))
		}

		function a(d, p) {
			d.dashSize.value = p.dashSize, d.totalSize.value = p.dashSize + p.gapSize, d.scale.value = p.scale
		}

		function l(d, p, _, v) {
			d.diffuse.value.copy(p.color), d.opacity.value = p.opacity, d.size.value = p.size * _, d.scale.value = v * .5, p.map && (d.map.value = p.map, t(p.map, d.uvTransform)), p.alphaMap && (d.alphaMap.value = p.alphaMap, t(p.alphaMap, d.alphaMapTransform)), p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest)
		}

		function c(d, p) {
			d.diffuse.value.copy(p.color), d.opacity.value = p.opacity, d.rotation.value = p.rotation, p.map && (d.map.value = p.map, t(p.map, d.mapTransform)), p.alphaMap && (d.alphaMap.value = p.alphaMap, t(p.alphaMap, d.alphaMapTransform)), p.alphaTest > 0 && (d.alphaTest.value = p.alphaTest)
		}

		function u(d, p) {
			d.specular.value.copy(p.specular), d.shininess.value = Math.max(p.shininess, 1e-4)
		}

		function h(d, p) {
			p.gradientMap && (d.gradientMap.value = p.gradientMap)
		}

		function f(d, p) {
			d.metalness.value = p.metalness, p.metalnessMap && (d.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, d.metalnessMapTransform)), d.roughness.value = p.roughness, p.roughnessMap && (d.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, d.roughnessMapTransform)), e.get(p).envMap && (d.envMapIntensity.value = p.envMapIntensity)
		}

		function m(d, p, _) {
			d.ior.value = p.ior, p.sheen > 0 && (d.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), d.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (d.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, d.sheenColorMapTransform)), p.sheenRoughnessMap && (d.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, d.sheenRoughnessMapTransform))), p.clearcoat > 0 && (d.clearcoat.value = p.clearcoat, d.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (d.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, d.clearcoatMapTransform)), p.clearcoatRoughnessMap && (d.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, d.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (d.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, d.clearcoatNormalMapTransform), d.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === gn && d.clearcoatNormalScale.value.negate())), p.iridescence > 0 && (d.iridescence.value = p.iridescence, d.iridescenceIOR.value = p.iridescenceIOR, d.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], d.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (d.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, d.iridescenceMapTransform)), p.iridescenceThicknessMap && (d.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, d.iridescenceThicknessMapTransform))), p.transmission > 0 && (d.transmission.value = p.transmission, d.transmissionSamplerMap.value = _.texture, d.transmissionSamplerSize.value.set(_.width, _.height), p.transmissionMap && (d.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, d.transmissionMapTransform)), d.thickness.value = p.thickness, p.thicknessMap && (d.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, d.thicknessMapTransform)), d.attenuationDistance.value = p.attenuationDistance, d.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (d.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (d.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, d.anisotropyMapTransform))), d.specularIntensity.value = p.specularIntensity, d.specularColor.value.copy(p.specularColor), p.specularColorMap && (d.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, d.specularColorMapTransform)), p.specularIntensityMap && (d.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, d.specularIntensityMapTransform))
		}

		function g(d, p) {
			p.matcap && (d.matcap.value = p.matcap)
		}

		function y(d, p) {
			let _ = e.get(p).light;
			d.referencePosition.value.setFromMatrixPosition(_.matrixWorld), d.nearDistance.value = _.shadow.camera.near, d.farDistance.value = _.shadow.camera.far
		}
		return {
			refreshFogUniforms: n,
			refreshMaterialUniforms: i
		}
	}

	function nM(r, e, t, n) {
		let i = {},
			s = {},
			o = [],
			a = t.isWebGL2 ? r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

		function l(_, v) {
			let x = v.program;
			n.uniformBlockBinding(_, x)
		}

		function c(_, v) {
			let x = i[_.id];
			x === void 0 && (g(_), x = u(_), i[_.id] = x, _.addEventListener("dispose", d));
			let M = v.program;
			n.updateUBOMapping(_, M);
			let I = e.render.frame;
			s[_.id] !== I && (f(_), s[_.id] = I)
		}

		function u(_) {
			let v = h();
			_.__bindingPointIndex = v;
			let x = r.createBuffer(),
				M = _.__size,
				I = _.usage;
			return r.bindBuffer(r.UNIFORM_BUFFER, x), r.bufferData(r.UNIFORM_BUFFER, M, I), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, v, x), x
		}

		function h() {
			for (let _ = 0; _ < a; _++)
				if (o.indexOf(_) === -1) return o.push(_), _;
			return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
		}

		function f(_) {
			let v = i[_.id],
				x = _.uniforms,
				M = _.__cache;
			r.bindBuffer(r.UNIFORM_BUFFER, v);
			for (let I = 0, w = x.length; I < w; I++) {
				let L = x[I];
				if (m(L, I, M) === !0) {
					let T = L.__offset,
						C = Array.isArray(L.value) ? L.value : [L.value],
						V = 0;
					for (let k = 0; k < C.length; k++) {
						let F = C[k],
							U = y(F);
						typeof F == "number" ? (L.__data[0] = F, r.bufferSubData(r.UNIFORM_BUFFER, T + V, L.__data)) : F.isMatrix3 ? (L.__data[0] = F.elements[0], L.__data[1] = F.elements[1], L.__data[2] = F.elements[2], L.__data[3] = F.elements[0], L.__data[4] = F.elements[3], L.__data[5] = F.elements[4], L.__data[6] = F.elements[5], L.__data[7] = F.elements[0], L.__data[8] = F.elements[6], L.__data[9] = F.elements[7], L.__data[10] = F.elements[8], L.__data[11] = F.elements[0]) : (F.toArray(L.__data, V), V += U.storage / Float32Array.BYTES_PER_ELEMENT)
					}
					r.bufferSubData(r.UNIFORM_BUFFER, T, L.__data)
				}
			}
			r.bindBuffer(r.UNIFORM_BUFFER, null)
		}

		function m(_, v, x) {
			let M = _.value;
			if (x[v] === void 0) {
				if (typeof M == "number") x[v] = M;
				else {
					let I = Array.isArray(M) ? M : [M],
						w = [];
					for (let L = 0; L < I.length; L++) w.push(I[L].clone());
					x[v] = w
				}
				return !0
			} else if (typeof M == "number") {
				if (x[v] !== M) return x[v] = M, !0
			} else {
				let I = Array.isArray(x[v]) ? x[v] : [x[v]],
					w = Array.isArray(M) ? M : [M];
				for (let L = 0; L < I.length; L++) {
					let T = I[L];
					if (T.equals(w[L]) === !1) return T.copy(w[L]), !0
				}
			}
			return !1
		}

		function g(_) {
			let v = _.uniforms,
				x = 0,
				M = 16,
				I = 0;
			for (let w = 0, L = v.length; w < L; w++) {
				let T = v[w],
					C = {
						boundary: 0,
						storage: 0
					},
					V = Array.isArray(T.value) ? T.value : [T.value];
				for (let k = 0, F = V.length; k < F; k++) {
					let U = V[k],
						K = y(U);
					C.boundary += K.boundary, C.storage += K.storage
				}
				if (T.__data = new Float32Array(C.storage / Float32Array.BYTES_PER_ELEMENT), T.__offset = x, w > 0) {
					I = x % M;
					let k = M - I;
					I !== 0 && k - C.boundary < 0 && (x += M - I, T.__offset = x)
				}
				x += C.storage
			}
			return I = x % M, I > 0 && (x += M - I), _.__size = x, _.__cache = {}, this
		}

		function y(_) {
			let v = {
				boundary: 0,
				storage: 0
			};
			return typeof _ == "number" ? (v.boundary = 4, v.storage = 4) : _.isVector2 ? (v.boundary = 8, v.storage = 8) : _.isVector3 || _.isColor ? (v.boundary = 16, v.storage = 12) : _.isVector4 ? (v.boundary = 16, v.storage = 16) : _.isMatrix3 ? (v.boundary = 48, v.storage = 48) : _.isMatrix4 ? (v.boundary = 64, v.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), v
		}

		function d(_) {
			let v = _.target;
			v.removeEventListener("dispose", d);
			let x = o.indexOf(v.__bindingPointIndex);
			o.splice(x, 1), r.deleteBuffer(i[v.id]), delete i[v.id], delete s[v.id]
		}

		function p() {
			for (let _ in i) r.deleteBuffer(i[_]);
			o = [], i = {}, s = {}
		}
		return {
			bind: l,
			update: c,
			dispose: p
		}
	}

	function iM() {
		let r = wl("canvas");
		return r.style.display = "block", r
	}
	var qs = class {
			constructor(e = {}) {
				let {
					canvas: t = iM(),
					context: n = null,
					depth: i = !0,
					stencil: s = !0,
					alpha: o = !1,
					antialias: a = !1,
					premultipliedAlpha: l = !0,
					preserveDrawingBuffer: c = !1,
					powerPreference: u = "default",
					failIfMajorPerformanceCaveat: h = !1
				} = e;
				this.isWebGLRenderer = !0;
				let f;
				n !== null ? f = n.getContextAttributes().alpha : f = o;
				let m = new Uint32Array(4),
					g = new Int32Array(4),
					y = null,
					d = null,
					p = [],
					_ = [];
				this.domElement = t, this.debug = {
					checkShaderErrors: !0,
					onShaderError: null
				}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = ot, this.useLegacyLights = !0, this.toneMapping = Fr, this.toneMappingExposure = 1;
				let v = this,
					x = !1,
					M = 0,
					I = 0,
					w = null,
					L = -1,
					T = null,
					C = new Ct,
					V = new Ct,
					k = null,
					F = new qe(0),
					U = 0,
					K = t.width,
					Z = t.height,
					Y = 1,
					H = null,
					oe = null,
					de = new Ct(0, 0, K, Z),
					te = new Ct(0, 0, K, Z),
					fe = !1,
					me = new Il,
					P = !1,
					b = !1,
					S = null,
					A = new Je,
					G = new Ce,
					J = new re,
					$ = {
						background: null,
						fog: null,
						environment: null,
						overrideMaterial: null,
						isScene: !0
					};

				function le() {
					return w === null ? Y : 1
				}
				let N = n;

				function pe(ee, Te) {
					for (let Ae = 0; Ae < ee.length; Ae++) {
						let xe = ee[Ae],
							we = t.getContext(xe, Te);
						if (we !== null) return we
					}
					return null
				}
				try {
					let ee = {
						alpha: !0,
						depth: i,
						stencil: s,
						antialias: a,
						premultipliedAlpha: l,
						preserveDrawingBuffer: c,
						powerPreference: u,
						failIfMajorPerformanceCaveat: h
					};
					if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Zf}`), t.addEventListener("webglcontextlost", Le, !1), t.addEventListener("webglcontextrestored", ve, !1), t.addEventListener("webglcontextcreationerror", Ie, !1), N === null) {
						let Te = ["webgl2", "webgl", "experimental-webgl"];
						if (v.isWebGL1Renderer === !0 && Te.shift(), N = pe(Te, ee), N === null) throw pe(Te) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
					}
					typeof WebGLRenderingContext < "u" && N instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), N.getShaderPrecisionFormat === void 0 && (N.getShaderPrecisionFormat = function() {
						return {
							rangeMin: 1,
							rangeMax: 1,
							precision: 1
						}
					})
				} catch (ee) {
					throw console.error("THREE.WebGLRenderer: " + ee.message), ee
				}
				let Q, he, ye, Ee, ie, q, Me, Pe, Ke, R, E, B, ne, X, ae, ge, ue, se, _e, Se, Ne, Fe, ke, je;

				function We() {
					Q = new MT(N), he = new yT(N, Q, e), Q.init(he), Fe = new QE(N, Q, he), ye = new JE(N, Q, he), Ee = new AT(N), ie = new BE, q = new $E(N, Q, ye, ie, he, Fe, Ee), Me = new xT(v), Pe = new ET(v), Ke = new Fv(N, he), ke = new mT(N, Q, Ke, he), R = new bT(N, Ke, Ee, ke), E = new IT(N, R, Ke, Ee), _e = new RT(N, he, q), ge = new vT(ie), B = new kE(v, Me, Pe, Q, he, ke, ge), ne = new tM(v, ie), X = new VE, ae = new jE(Q, he), se = new pT(v, Me, Pe, ye, E, f, l), ue = new ZE(v, E, he), je = new nM(N, Ee, he, ye), Se = new gT(N, Q, Ee, he), Ne = new ST(N, Q, Ee, he), Ee.programs = B.programs, v.capabilities = he, v.extensions = Q, v.properties = ie, v.renderLists = X, v.shadowMap = ue, v.state = ye, v.info = Ee
				}
				We();
				let ce = new Rf(v, N);
				this.xr = ce, this.getContext = function() {
					return N
				}, this.getContextAttributes = function() {
					return N.getContextAttributes()
				}, this.forceContextLoss = function() {
					let ee = Q.get("WEBGL_lose_context");
					ee && ee.loseContext()
				}, this.forceContextRestore = function() {
					let ee = Q.get("WEBGL_lose_context");
					ee && ee.restoreContext()
				}, this.getPixelRatio = function() {
					return Y
				}, this.setPixelRatio = function(ee) {
					ee !== void 0 && (Y = ee, this.setSize(K, Z, !1))
				}, this.getSize = function(ee) {
					return ee.set(K, Z)
				}, this.setSize = function(ee, Te, Ae = !0) {
					if (ce.isPresenting) {
						console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
						return
					}
					K = ee, Z = Te, t.width = Math.floor(ee * Y), t.height = Math.floor(Te * Y), Ae === !0 && (t.style.width = ee + "px", t.style.height = Te + "px"), this.setViewport(0, 0, ee, Te)
				}, this.getDrawingBufferSize = function(ee) {
					return ee.set(K * Y, Z * Y).floor()
				}, this.setDrawingBufferSize = function(ee, Te, Ae) {
					K = ee, Z = Te, Y = Ae, t.width = Math.floor(ee * Ae), t.height = Math.floor(Te * Ae), this.setViewport(0, 0, ee, Te)
				}, this.getCurrentViewport = function(ee) {
					return ee.copy(C)
				}, this.getViewport = function(ee) {
					return ee.copy(de)
				}, this.setViewport = function(ee, Te, Ae, xe) {
					ee.isVector4 ? de.set(ee.x, ee.y, ee.z, ee.w) : de.set(ee, Te, Ae, xe), ye.viewport(C.copy(de).multiplyScalar(Y).floor())
				}, this.getScissor = function(ee) {
					return ee.copy(te)
				}, this.setScissor = function(ee, Te, Ae, xe) {
					ee.isVector4 ? te.set(ee.x, ee.y, ee.z, ee.w) : te.set(ee, Te, Ae, xe), ye.scissor(V.copy(te).multiplyScalar(Y).floor())
				}, this.getScissorTest = function() {
					return fe
				}, this.setScissorTest = function(ee) {
					ye.setScissorTest(fe = ee)
				}, this.setOpaqueSort = function(ee) {
					H = ee
				}, this.setTransparentSort = function(ee) {
					oe = ee
				}, this.getClearColor = function(ee) {
					return ee.copy(se.getClearColor())
				}, this.setClearColor = function() {
					se.setClearColor.apply(se, arguments)
				}, this.getClearAlpha = function() {
					return se.getClearAlpha()
				}, this.setClearAlpha = function() {
					se.setClearAlpha.apply(se, arguments)
				}, this.clear = function(ee = !0, Te = !0, Ae = !0) {
					let xe = 0;
					if (ee) {
						let we = !1;
						if (w !== null) {
							let $e = w.texture.format;
							we = $e === Sg || $e === bg || $e === Mg
						}
						if (we) {
							let $e = w.texture.type,
								lt = $e === rs || $e === ns || $e === Jf || $e === Bs || $e === Tg || $e === Eg,
								dt = se.getClearColor(),
								it = se.getClearAlpha(),
								gt = dt.r,
								mt = dt.g,
								xt = dt.b;
							lt ? (m[0] = gt, m[1] = mt, m[2] = xt, m[3] = it, N.clearBufferuiv(N.COLOR, 0, m)) : (g[0] = gt, g[1] = mt, g[2] = xt, g[3] = it, N.clearBufferiv(N.COLOR, 0, g))
						} else xe |= N.COLOR_BUFFER_BIT
					}
					Te && (xe |= N.DEPTH_BUFFER_BIT), Ae && (xe |= N.STENCIL_BUFFER_BIT), N.clear(xe)
				}, this.clearColor = function() {
					this.clear(!0, !1, !1)
				}, this.clearDepth = function() {
					this.clear(!1, !0, !1)
				}, this.clearStencil = function() {
					this.clear(!1, !1, !0)
				}, this.dispose = function() {
					t.removeEventListener("webglcontextlost", Le, !1), t.removeEventListener("webglcontextrestored", ve, !1), t.removeEventListener("webglcontextcreationerror", Ie, !1), X.dispose(), ae.dispose(), ie.dispose(), Me.dispose(), Pe.dispose(), E.dispose(), ke.dispose(), je.dispose(), B.dispose(), ce.dispose(), ce.removeEventListener("sessionstart", Ue), ce.removeEventListener("sessionend", Ye), S && (S.dispose(), S = null), Be.stop()
				};

				function Le(ee) {
					ee.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
				}

				function ve() {
					console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
					let ee = Ee.autoReset,
						Te = ue.enabled,
						Ae = ue.autoUpdate,
						xe = ue.needsUpdate,
						we = ue.type;
					We(), Ee.autoReset = ee, ue.enabled = Te, ue.autoUpdate = Ae, ue.needsUpdate = xe, ue.type = we
				}

				function Ie(ee) {
					console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ee.statusMessage)
				}

				function De(ee) {
					let Te = ee.target;
					Te.removeEventListener("dispose", De), et(Te)
				}

				function et(ee) {
					vt(ee), ie.remove(ee)
				}

				function vt(ee) {
					let Te = ie.get(ee).programs;
					Te !== void 0 && (Te.forEach(function(Ae) {
						B.releaseProgram(Ae)
					}), ee.isShaderMaterial && B.releaseShaderCache(ee))
				}
				this.renderBufferDirect = function(ee, Te, Ae, xe, we, $e) {
					Te === null && (Te = $);
					let lt = we.isMesh && we.matrixWorld.determinant() < 0,
						dt = uc(ee, Te, Ae, xe, we);
					ye.setMaterial(xe, lt);
					let it = Ae.index,
						gt = 1;
					xe.wireframe === !0 && (it = R.getWireframeAttribute(Ae), gt = 2);
					let mt = Ae.drawRange,
						xt = Ae.attributes.position,
						Kt = mt.start * gt,
						Zt = (mt.start + mt.count) * gt;
					$e !== null && (Kt = Math.max(Kt, $e.start * gt), Zt = Math.min(Zt, ($e.start + $e.count) * gt)), it !== null ? (Kt = Math.max(Kt, 0), Zt = Math.min(Zt, it.count)) : xt != null && (Kt = Math.max(Kt, 0), Zt = Math.min(Zt, xt.count));
					let oi = Zt - Kt;
					if (oi < 0 || oi === 1 / 0) return;
					ke.setup(we, xe, dt, Ae, it);
					let Ri, an = Se;
					if (it !== null && (Ri = Ke.get(it), an = Ne, an.setIndex(Ri)), we.isMesh) xe.wireframe === !0 ? (ye.setLineWidth(xe.wireframeLinewidth * le()), an.setMode(N.LINES)) : an.setMode(N.TRIANGLES);
					else if (we.isLine) {
						let bt = xe.linewidth;
						bt === void 0 && (bt = 1), ye.setLineWidth(bt * le()), we.isLineSegments ? an.setMode(N.LINES) : we.isLineLoop ? an.setMode(N.LINE_LOOP) : an.setMode(N.LINE_STRIP)
					} else we.isPoints ? an.setMode(N.POINTS) : we.isSprite && an.setMode(N.TRIANGLES);
					if (we.isInstancedMesh) an.renderInstances(Kt, oi, we.count);
					else if (Ae.isInstancedBufferGeometry) {
						let bt = Ae._maxInstanceCount !== void 0 ? Ae._maxInstanceCount : 1 / 0,
							no = Math.min(Ae.instanceCount, bt);
						an.renderInstances(Kt, oi, no)
					} else an.render(Kt, oi)
				}, this.compile = function(ee, Te) {
					function Ae(xe, we, $e) {
						xe.transparent === !0 && xe.side === wn && xe.forceSinglePass === !1 ? (xe.side = gn, xe.needsUpdate = !0, Ci(xe, we, $e), xe.side = _i, xe.needsUpdate = !0, Ci(xe, we, $e), xe.side = wn) : Ci(xe, we, $e)
					}
					d = ae.get(ee), d.init(), _.push(d), ee.traverseVisible(function(xe) {
						xe.isLight && xe.layers.test(Te.layers) && (d.pushLight(xe), xe.castShadow && d.pushShadow(xe))
					}), d.setupLights(v.useLegacyLights), ee.traverse(function(xe) {
						let we = xe.material;
						if (we)
							if (Array.isArray(we))
								for (let $e = 0; $e < we.length; $e++) {
									let lt = we[$e];
									Ae(lt, ee, xe)
								} else Ae(we, ee, xe)
					}), _.pop(), d = null
				};
				let Mt = null;

				function ft(ee) {
					Mt && Mt(ee)
				}

				function Ue() {
					Be.stop()
				}

				function Ye() {
					Be.start()
				}
				let Be = new Lg;
				Be.setAnimationLoop(ft), typeof self < "u" && Be.setContext(self), this.setAnimationLoop = function(ee) {
					Mt = ee, ce.setAnimationLoop(ee), ee === null ? Be.stop() : Be.start()
				}, ce.addEventListener("sessionstart", Ue), ce.addEventListener("sessionend", Ye), this.render = function(ee, Te) {
					if (Te !== void 0 && Te.isCamera !== !0) {
						console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
						return
					}
					if (x === !0) return;
					ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(), Te.parent === null && Te.matrixWorldAutoUpdate === !0 && Te.updateMatrixWorld(), ce.enabled === !0 && ce.isPresenting === !0 && (ce.cameraAutoUpdate === !0 && ce.updateCamera(Te), Te = ce.getCamera()), ee.isScene === !0 && ee.onBeforeRender(v, ee, Te, w), d = ae.get(ee, _.length), d.init(), _.push(d), A.multiplyMatrices(Te.projectionMatrix, Te.matrixWorldInverse), me.setFromProjectionMatrix(A), b = this.localClippingEnabled, P = ge.init(this.clippingPlanes, b), y = X.get(ee, p.length), y.init(), p.push(y), tt(ee, Te, 0, v.sortObjects), y.finish(), v.sortObjects === !0 && y.sort(H, oe), this.info.render.frame++, P === !0 && ge.beginShadows();
					let Ae = d.state.shadowsArray;
					if (ue.render(Ae, ee, Te), P === !0 && ge.endShadows(), this.info.autoReset === !0 && this.info.reset(), se.render(y, ee), d.setupLights(v.useLegacyLights), Te.isArrayCamera) {
						let xe = Te.cameras;
						for (let we = 0, $e = xe.length; we < $e; we++) {
							let lt = xe[we];
							st(y, ee, lt, lt.viewport)
						}
					} else st(y, ee, Te);
					w !== null && (q.updateMultisampleRenderTarget(w), q.updateRenderTargetMipmap(w)), ee.isScene === !0 && ee.onAfterRender(v, ee, Te), ke.resetDefaultState(), L = -1, T = null, _.pop(), _.length > 0 ? d = _[_.length - 1] : d = null, p.pop(), p.length > 0 ? y = p[p.length - 1] : y = null
				};

				function tt(ee, Te, Ae, xe) {
					if (ee.visible === !1) return;
					if (ee.layers.test(Te.layers)) {
						if (ee.isGroup) Ae = ee.renderOrder;
						else if (ee.isLOD) ee.autoUpdate === !0 && ee.update(Te);
						else if (ee.isLight) d.pushLight(ee), ee.castShadow && d.pushShadow(ee);
						else if (ee.isSprite) {
							if (!ee.frustumCulled || me.intersectsSprite(ee)) {
								xe && J.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(A);
								let lt = E.update(ee),
									dt = ee.material;
								dt.visible && y.push(ee, lt, dt, Ae, J.z, null)
							}
						} else if ((ee.isMesh || ee.isLine || ee.isPoints) && (!ee.frustumCulled || me.intersectsObject(ee))) {
							let lt = E.update(ee),
								dt = ee.material;
							if (xe && (ee.boundingSphere !== void 0 ? (ee.boundingSphere === null && ee.computeBoundingSphere(), J.copy(ee.boundingSphere.center)) : (lt.boundingSphere === null && lt.computeBoundingSphere(), J.copy(lt.boundingSphere.center)), J.applyMatrix4(ee.matrixWorld).applyMatrix4(A)), Array.isArray(dt)) {
								let it = lt.groups;
								for (let gt = 0, mt = it.length; gt < mt; gt++) {
									let xt = it[gt],
										Kt = dt[xt.materialIndex];
									Kt && Kt.visible && y.push(ee, lt, Kt, Ae, J.z, xt)
								}
							} else dt.visible && y.push(ee, lt, dt, Ae, J.z, null)
						}
					}
					let $e = ee.children;
					for (let lt = 0, dt = $e.length; lt < dt; lt++) tt($e[lt], Te, Ae, xe)
				}

				function st(ee, Te, Ae, xe) {
					let we = ee.opaque,
						$e = ee.transmissive,
						lt = ee.transparent;
					d.setupLightsView(Ae), P === !0 && ge.setGlobalState(v.clippingPlanes, Ae), $e.length > 0 && zt(we, $e, Te, Ae), xe && ye.viewport(C.copy(xe)), we.length > 0 && Hn(we, Te, Ae), $e.length > 0 && Hn($e, Te, Ae), lt.length > 0 && Hn(lt, Te, Ae), ye.buffers.depth.setTest(!0), ye.buffers.depth.setMask(!0), ye.buffers.color.setMask(!0), ye.setPolygonOffset(!1)
				}

				function zt(ee, Te, Ae, xe) {
					let we = he.isWebGL2;
					S === null && (S = new Ur(1, 1, {
						generateMipmaps: !0,
						type: Q.has("EXT_color_buffer_half_float") ? Al : rs,
						minFilter: ki,
						samples: we ? 4 : 0
					})), v.getDrawingBufferSize(G), we ? S.setSize(G.x, G.y) : S.setSize(vu(G.x), vu(G.y));
					let $e = v.getRenderTarget();
					v.setRenderTarget(S), v.getClearColor(F), U = v.getClearAlpha(), U < 1 && v.setClearColor(16777215, .5), v.clear();
					let lt = v.toneMapping;
					v.toneMapping = Fr, Hn(ee, Ae, xe), q.updateMultisampleRenderTarget(S), q.updateRenderTargetMipmap(S);
					let dt = !1;
					for (let it = 0, gt = Te.length; it < gt; it++) {
						let mt = Te[it],
							xt = mt.object,
							Kt = mt.geometry,
							Zt = mt.material,
							oi = mt.group;
						if (Zt.side === wn && xt.layers.test(xe.layers)) {
							let Ri = Zt.side;
							Zt.side = gn, Zt.needsUpdate = !0, si(xt, Ae, xe, Kt, Zt, oi), Zt.side = Ri, Zt.needsUpdate = !0, dt = !0
						}
					}
					dt === !0 && (q.updateMultisampleRenderTarget(S), q.updateRenderTargetMipmap(S)), v.setRenderTarget($e), v.setClearColor(F, U), v.toneMapping = lt
				}

				function Hn(ee, Te, Ae) {
					let xe = Te.isScene === !0 ? Te.overrideMaterial : null;
					for (let we = 0, $e = ee.length; we < $e; we++) {
						let lt = ee[we],
							dt = lt.object,
							it = lt.geometry,
							gt = xe === null ? lt.material : xe,
							mt = lt.group;
						dt.layers.test(Ae.layers) && si(dt, Te, Ae, it, gt, mt)
					}
				}

				function si(ee, Te, Ae, xe, we, $e) {
					ee.onBeforeRender(v, Te, Ae, xe, we, $e), ee.modelViewMatrix.multiplyMatrices(Ae.matrixWorldInverse, ee.matrixWorld), ee.normalMatrix.getNormalMatrix(ee.modelViewMatrix), we.onBeforeRender(v, Te, Ae, xe, ee, $e), we.transparent === !0 && we.side === wn && we.forceSinglePass === !1 ? (we.side = gn, we.needsUpdate = !0, v.renderBufferDirect(Ae, Te, xe, we, ee, $e), we.side = _i, we.needsUpdate = !0, v.renderBufferDirect(Ae, Te, xe, we, ee, $e), we.side = wn) : v.renderBufferDirect(Ae, Te, xe, we, ee, $e), ee.onAfterRender(v, Te, Ae, xe, we, $e)
				}

				function Ci(ee, Te, Ae) {
					Te.isScene !== !0 && (Te = $);
					let xe = ie.get(ee),
						we = d.state.lights,
						$e = d.state.shadowsArray,
						lt = we.state.version,
						dt = B.getParameters(ee, we.state, $e, Te, Ae),
						it = B.getProgramCacheKey(dt),
						gt = xe.programs;
					xe.environment = ee.isMeshStandardMaterial ? Te.environment : null, xe.fog = Te.fog, xe.envMap = (ee.isMeshStandardMaterial ? Pe : Me).get(ee.envMap || xe.environment), gt === void 0 && (ee.addEventListener("dispose", De), gt = new Map, xe.programs = gt);
					let mt = gt.get(it);
					if (mt !== void 0) {
						if (xe.currentProgram === mt && xe.lightsStateVersion === lt) return cc(ee, dt), mt
					} else dt.uniforms = B.getUniforms(ee), ee.onBuild(Ae, dt, v), ee.onBeforeCompile(dt, v), mt = B.acquireProgram(dt, it), gt.set(it, mt), xe.uniforms = dt.uniforms;
					let xt = xe.uniforms;
					(!ee.isShaderMaterial && !ee.isRawShaderMaterial || ee.clipping === !0) && (xt.clippingPlanes = ge.uniform), cc(ee, dt), xe.needsLights = Th(ee), xe.lightsStateVersion = lt, xe.needsLights && (xt.ambientLightColor.value = we.state.ambient, xt.lightProbe.value = we.state.probe, xt.directionalLights.value = we.state.directional, xt.directionalLightShadows.value = we.state.directionalShadow, xt.spotLights.value = we.state.spot, xt.spotLightShadows.value = we.state.spotShadow, xt.rectAreaLights.value = we.state.rectArea, xt.ltc_1.value = we.state.rectAreaLTC1, xt.ltc_2.value = we.state.rectAreaLTC2, xt.pointLights.value = we.state.point, xt.pointLightShadows.value = we.state.pointShadow, xt.hemisphereLights.value = we.state.hemi, xt.directionalShadowMap.value = we.state.directionalShadowMap, xt.directionalShadowMatrix.value = we.state.directionalShadowMatrix, xt.spotShadowMap.value = we.state.spotShadowMap, xt.spotLightMatrix.value = we.state.spotLightMatrix, xt.spotLightMap.value = we.state.spotLightMap, xt.pointShadowMap.value = we.state.pointShadowMap, xt.pointShadowMatrix.value = we.state.pointShadowMatrix);
					let Kt = mt.getUniforms(),
						Zt = ea.seqWithValue(Kt.seq, xt);
					return xe.currentProgram = mt, xe.uniformsList = Zt, mt
				}

				function cc(ee, Te) {
					let Ae = ie.get(ee);
					Ae.outputColorSpace = Te.outputColorSpace, Ae.instancing = Te.instancing, Ae.skinning = Te.skinning, Ae.morphTargets = Te.morphTargets, Ae.morphNormals = Te.morphNormals, Ae.morphColors = Te.morphColors, Ae.morphTargetsCount = Te.morphTargetsCount, Ae.numClippingPlanes = Te.numClippingPlanes, Ae.numIntersection = Te.numClipIntersection, Ae.vertexAlphas = Te.vertexAlphas, Ae.vertexTangents = Te.vertexTangents, Ae.toneMapping = Te.toneMapping
				}

				function uc(ee, Te, Ae, xe, we) {
					Te.isScene !== !0 && (Te = $), q.resetTextureUnits();
					let $e = Te.fog,
						lt = xe.isMeshStandardMaterial ? Te.environment : null,
						dt = w === null ? v.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : Bn,
						it = (xe.isMeshStandardMaterial ? Pe : Me).get(xe.envMap || lt),
						gt = xe.vertexColors === !0 && !!Ae.attributes.color && Ae.attributes.color.itemSize === 4,
						mt = !!Ae.attributes.tangent && (!!xe.normalMap || xe.anisotropy > 0),
						xt = !!Ae.morphAttributes.position,
						Kt = !!Ae.morphAttributes.normal,
						Zt = !!Ae.morphAttributes.color,
						oi = xe.toneMapped ? v.toneMapping : Fr,
						Ri = Ae.morphAttributes.position || Ae.morphAttributes.normal || Ae.morphAttributes.color,
						an = Ri !== void 0 ? Ri.length : 0,
						bt = ie.get(xe),
						no = d.state.lights;
					if (P === !0 && (b === !0 || ee !== T)) {
						let Dn = ee === T && xe.id === L;
						ge.setState(xe, ee, Dn)
					}
					let qt = !1;
					xe.version === bt.__version ? (bt.needsLights && bt.lightsStateVersion !== no.state.version || bt.outputColorSpace !== dt || we.isInstancedMesh && bt.instancing === !1 || !we.isInstancedMesh && bt.instancing === !0 || we.isSkinnedMesh && bt.skinning === !1 || !we.isSkinnedMesh && bt.skinning === !0 || bt.envMap !== it || xe.fog === !0 && bt.fog !== $e || bt.numClippingPlanes !== void 0 && (bt.numClippingPlanes !== ge.numPlanes || bt.numIntersection !== ge.numIntersection) || bt.vertexAlphas !== gt || bt.vertexTangents !== mt || bt.morphTargets !== xt || bt.morphNormals !== Kt || bt.morphColors !== Zt || bt.toneMapping !== oi || he.isWebGL2 === !0 && bt.morphTargetsCount !== an) && (qt = !0) : (qt = !0, bt.__version = xe.version);
					let vr = bt.currentProgram;
					qt === !0 && (vr = Ci(xe, Te, we));
					let Ka = !1,
						Ts = !1,
						io = !1,
						Rn = vr.getUniforms(),
						xr = bt.uniforms;
					if (ye.useProgram(vr.program) && (Ka = !0, Ts = !0, io = !0), xe.id !== L && (L = xe.id, Ts = !0), Ka || T !== ee) {
						if (Rn.setValue(N, "projectionMatrix", ee.projectionMatrix), he.logarithmicDepthBuffer && Rn.setValue(N, "logDepthBufFC", 2 / (Math.log(ee.far + 1) / Math.LN2)), T !== ee && (T = ee, Ts = !0, io = !0), xe.isShaderMaterial || xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshStandardMaterial || xe.envMap) {
							let Dn = Rn.map.cameraPosition;
							Dn !== void 0 && Dn.setValue(N, J.setFromMatrixPosition(ee.matrixWorld))
						}(xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshLambertMaterial || xe.isMeshBasicMaterial || xe.isMeshStandardMaterial || xe.isShaderMaterial) && Rn.setValue(N, "isOrthographic", ee.isOrthographicCamera === !0), (xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshLambertMaterial || xe.isMeshBasicMaterial || xe.isMeshStandardMaterial || xe.isShaderMaterial || xe.isShadowMaterial || we.isSkinnedMesh) && Rn.setValue(N, "viewMatrix", ee.matrixWorldInverse)
					}
					if (we.isSkinnedMesh) {
						Rn.setOptional(N, we, "bindMatrix"), Rn.setOptional(N, we, "bindMatrixInverse");
						let Dn = we.skeleton;
						Dn && (he.floatVertexTextures ? (Dn.boneTexture === null && Dn.computeBoneTexture(), Rn.setValue(N, "boneTexture", Dn.boneTexture, q), Rn.setValue(N, "boneTextureSize", Dn.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
					}
					let Za = Ae.morphAttributes;
					if ((Za.position !== void 0 || Za.normal !== void 0 || Za.color !== void 0 && he.isWebGL2 === !0) && _e.update(we, Ae, vr), (Ts || bt.receiveShadow !== we.receiveShadow) && (bt.receiveShadow = we.receiveShadow, Rn.setValue(N, "receiveShadow", we.receiveShadow)), xe.isMeshGouraudMaterial && xe.envMap !== null && (xr.envMap.value = it, xr.flipEnvMap.value = it.isCubeTexture && it.isRenderTargetTexture === !1 ? -1 : 1), Ts && (Rn.setValue(N, "toneMappingExposure", v.toneMappingExposure), bt.needsLights && _h(xr, io), $e && xe.fog === !0 && ne.refreshFogUniforms(xr, $e), ne.refreshMaterialUniforms(xr, xe, Y, Z, S), ea.upload(N, bt.uniformsList, xr, q)), xe.isShaderMaterial && xe.uniformsNeedUpdate === !0 && (ea.upload(N, bt.uniformsList, xr, q), xe.uniformsNeedUpdate = !1), xe.isSpriteMaterial && Rn.setValue(N, "center", we.center), Rn.setValue(N, "modelViewMatrix", we.modelViewMatrix), Rn.setValue(N, "normalMatrix", we.normalMatrix), Rn.setValue(N, "modelMatrix", we.matrixWorld), xe.isShaderMaterial || xe.isRawShaderMaterial) {
						let Dn = xe.uniformsGroups;
						for (let en = 0, Ja = Dn.length; en < Ja; en++)
							if (he.isWebGL2) {
								let hc = Dn[en];
								je.update(hc, vr), je.bind(hc, vr)
							} else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
					}
					return vr
				}

				function _h(ee, Te) {
					ee.ambientLightColor.needsUpdate = Te, ee.lightProbe.needsUpdate = Te, ee.directionalLights.needsUpdate = Te, ee.directionalLightShadows.needsUpdate = Te, ee.pointLights.needsUpdate = Te, ee.pointLightShadows.needsUpdate = Te, ee.spotLights.needsUpdate = Te, ee.spotLightShadows.needsUpdate = Te, ee.rectAreaLights.needsUpdate = Te, ee.hemisphereLights.needsUpdate = Te
				}

				function Th(ee) {
					return ee.isMeshLambertMaterial || ee.isMeshToonMaterial || ee.isMeshPhongMaterial || ee.isMeshStandardMaterial || ee.isShadowMaterial || ee.isShaderMaterial && ee.lights === !0
				}
				this.getActiveCubeFace = function() {
					return M
				}, this.getActiveMipmapLevel = function() {
					return I
				}, this.getRenderTarget = function() {
					return w
				}, this.setRenderTargetTextures = function(ee, Te, Ae) {
					ie.get(ee.texture).__webglTexture = Te, ie.get(ee.depthTexture).__webglTexture = Ae;
					let xe = ie.get(ee);
					xe.__hasExternalTextures = !0, xe.__hasExternalTextures && (xe.__autoAllocateDepthBuffer = Ae === void 0, xe.__autoAllocateDepthBuffer || Q.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), xe.__useRenderToTexture = !1))
				}, this.setRenderTargetFramebuffer = function(ee, Te) {
					let Ae = ie.get(ee);
					Ae.__webglFramebuffer = Te, Ae.__useDefaultFramebuffer = Te === void 0
				}, this.setRenderTarget = function(ee, Te = 0, Ae = 0) {
					w = ee, M = Te, I = Ae;
					let xe = !0,
						we = null,
						$e = !1,
						lt = !1;
					if (ee) {
						let it = ie.get(ee);
						it.__useDefaultFramebuffer !== void 0 ? (ye.bindFramebuffer(N.FRAMEBUFFER, null), xe = !1) : it.__webglFramebuffer === void 0 ? q.setupRenderTarget(ee) : it.__hasExternalTextures && q.rebindTextures(ee, ie.get(ee.texture).__webglTexture, ie.get(ee.depthTexture).__webglTexture);
						let gt = ee.texture;
						(gt.isData3DTexture || gt.isDataArrayTexture || gt.isCompressedArrayTexture) && (lt = !0);
						let mt = ie.get(ee).__webglFramebuffer;
						ee.isWebGLCubeRenderTarget ? (we = mt[Te], $e = !0) : he.isWebGL2 && ee.samples > 0 && q.useMultisampledRTT(ee) === !1 ? we = ie.get(ee).__webglMultisampledFramebuffer : we = mt, C.copy(ee.viewport), V.copy(ee.scissor), k = ee.scissorTest
					} else C.copy(de).multiplyScalar(Y).floor(), V.copy(te).multiplyScalar(Y).floor(), k = fe;
					if (ye.bindFramebuffer(N.FRAMEBUFFER, we) && he.drawBuffers && xe && ye.drawBuffers(ee, we), ye.viewport(C), ye.scissor(V), ye.setScissorTest(k), $e) {
						let it = ie.get(ee.texture);
						N.framebufferTexture2D(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0, N.TEXTURE_CUBE_MAP_POSITIVE_X + Te, it.__webglTexture, Ae)
					} else if (lt) {
						let it = ie.get(ee.texture),
							gt = Te || 0;
						N.framebufferTextureLayer(N.FRAMEBUFFER, N.COLOR_ATTACHMENT0, it.__webglTexture, Ae || 0, gt)
					}
					L = -1
				}, this.readRenderTargetPixels = function(ee, Te, Ae, xe, we, $e, lt) {
					if (!(ee && ee.isWebGLRenderTarget)) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
						return
					}
					let dt = ie.get(ee).__webglFramebuffer;
					if (ee.isWebGLCubeRenderTarget && lt !== void 0 && (dt = dt[lt]), dt) {
						ye.bindFramebuffer(N.FRAMEBUFFER, dt);
						try {
							let it = ee.texture,
								gt = it.format,
								mt = it.type;
							if (gt !== xi && Fe.convert(gt) !== N.getParameter(N.IMPLEMENTATION_COLOR_READ_FORMAT)) {
								console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
								return
							}
							let xt = mt === Al && (Q.has("EXT_color_buffer_half_float") || he.isWebGL2 && Q.has("EXT_color_buffer_float"));
							if (mt !== rs && Fe.convert(mt) !== N.getParameter(N.IMPLEMENTATION_COLOR_READ_TYPE) && !(mt === Or && (he.isWebGL2 || Q.has("OES_texture_float") || Q.has("WEBGL_color_buffer_float"))) && !xt) {
								console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
								return
							}
							Te >= 0 && Te <= ee.width - xe && Ae >= 0 && Ae <= ee.height - we && N.readPixels(Te, Ae, xe, we, Fe.convert(gt), Fe.convert(mt), $e)
						} finally {
							let it = w !== null ? ie.get(w).__webglFramebuffer : null;
							ye.bindFramebuffer(N.FRAMEBUFFER, it)
						}
					}
				}, this.copyFramebufferToTexture = function(ee, Te, Ae = 0) {
					let xe = Math.pow(2, -Ae),
						we = Math.floor(Te.image.width * xe),
						$e = Math.floor(Te.image.height * xe);
					q.setTexture2D(Te, 0), N.copyTexSubImage2D(N.TEXTURE_2D, Ae, 0, 0, ee.x, ee.y, we, $e), ye.unbindTexture()
				}, this.copyTextureToTexture = function(ee, Te, Ae, xe = 0) {
					let we = Te.image.width,
						$e = Te.image.height,
						lt = Fe.convert(Ae.format),
						dt = Fe.convert(Ae.type);
					q.setTexture2D(Ae, 0), N.pixelStorei(N.UNPACK_FLIP_Y_WEBGL, Ae.flipY), N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ae.premultiplyAlpha), N.pixelStorei(N.UNPACK_ALIGNMENT, Ae.unpackAlignment), Te.isDataTexture ? N.texSubImage2D(N.TEXTURE_2D, xe, ee.x, ee.y, we, $e, lt, dt, Te.image.data) : Te.isCompressedTexture ? N.compressedTexSubImage2D(N.TEXTURE_2D, xe, ee.x, ee.y, Te.mipmaps[0].width, Te.mipmaps[0].height, lt, Te.mipmaps[0].data) : N.texSubImage2D(N.TEXTURE_2D, xe, ee.x, ee.y, lt, dt, Te.image), xe === 0 && Ae.generateMipmaps && N.generateMipmap(N.TEXTURE_2D), ye.unbindTexture()
				}, this.copyTextureToTexture3D = function(ee, Te, Ae, xe, we = 0) {
					if (v.isWebGL1Renderer) {
						console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
						return
					}
					let $e = ee.max.x - ee.min.x + 1,
						lt = ee.max.y - ee.min.y + 1,
						dt = ee.max.z - ee.min.z + 1,
						it = Fe.convert(xe.format),
						gt = Fe.convert(xe.type),
						mt;
					if (xe.isData3DTexture) q.setTexture3D(xe, 0), mt = N.TEXTURE_3D;
					else if (xe.isDataArrayTexture) q.setTexture2DArray(xe, 0), mt = N.TEXTURE_2D_ARRAY;
					else {
						console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
						return
					}
					N.pixelStorei(N.UNPACK_FLIP_Y_WEBGL, xe.flipY), N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, xe.premultiplyAlpha), N.pixelStorei(N.UNPACK_ALIGNMENT, xe.unpackAlignment);
					let xt = N.getParameter(N.UNPACK_ROW_LENGTH),
						Kt = N.getParameter(N.UNPACK_IMAGE_HEIGHT),
						Zt = N.getParameter(N.UNPACK_SKIP_PIXELS),
						oi = N.getParameter(N.UNPACK_SKIP_ROWS),
						Ri = N.getParameter(N.UNPACK_SKIP_IMAGES),
						an = Ae.isCompressedTexture ? Ae.mipmaps[0] : Ae.image;
					N.pixelStorei(N.UNPACK_ROW_LENGTH, an.width), N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, an.height), N.pixelStorei(N.UNPACK_SKIP_PIXELS, ee.min.x), N.pixelStorei(N.UNPACK_SKIP_ROWS, ee.min.y), N.pixelStorei(N.UNPACK_SKIP_IMAGES, ee.min.z), Ae.isDataTexture || Ae.isData3DTexture ? N.texSubImage3D(mt, we, Te.x, Te.y, Te.z, $e, lt, dt, it, gt, an.data) : Ae.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), N.compressedTexSubImage3D(mt, we, Te.x, Te.y, Te.z, $e, lt, dt, it, an.data)) : N.texSubImage3D(mt, we, Te.x, Te.y, Te.z, $e, lt, dt, it, gt, an), N.pixelStorei(N.UNPACK_ROW_LENGTH, xt), N.pixelStorei(N.UNPACK_IMAGE_HEIGHT, Kt), N.pixelStorei(N.UNPACK_SKIP_PIXELS, Zt), N.pixelStorei(N.UNPACK_SKIP_ROWS, oi), N.pixelStorei(N.UNPACK_SKIP_IMAGES, Ri), we === 0 && xe.generateMipmaps && N.generateMipmap(mt), ye.unbindTexture()
				}, this.initTexture = function(ee) {
					ee.isCubeTexture ? q.setTextureCube(ee, 0) : ee.isData3DTexture ? q.setTexture3D(ee, 0) : ee.isDataArrayTexture || ee.isCompressedArrayTexture ? q.setTexture2DArray(ee, 0) : q.setTexture2D(ee, 0), ye.unbindTexture()
				}, this.resetState = function() {
					M = 0, I = 0, w = null, ye.reset(), ke.reset()
				}, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
					detail: this
				}))
			}
			get coordinateSystem() {
				return Dr
			}
			get physicallyCorrectLights() {
				return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights
			}
			set physicallyCorrectLights(e) {
				console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e
			}
			get outputEncoding() {
				return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === ot ? Vs : Ag
			}
			set outputEncoding(e) {
				console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Vs ? ot : Bn
			}
		},
		If = class extends qs {};
	If.prototype.isWebGL1Renderer = !0;
	var ur = class extends Rt {
		constructor() {
			super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
				detail: this
			}))
		}
		copy(e, t) {
			return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
		}
		toJSON(e) {
			let t = super.toJSON(e);
			return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t
		}
	};
	var jm = new re,
		Ym = new Ct,
		Km = new Ct,
		rM = new re,
		Zm = new Je,
		jo = new re,
		nf = new Gi,
		Jm = new Je,
		rf = new Ws,
		la = class extends Nt {
			constructor(e, t) {
				super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Je, this.bindMatrixInverse = new Je, this.boundingBox = null, this.boundingSphere = null
			}
			computeBoundingBox() {
				let e = this.geometry;
				this.boundingBox === null && (this.boundingBox = new Bi), this.boundingBox.makeEmpty();
				let t = e.getAttribute("position");
				for (let n = 0; n < t.count; n++) jo.fromBufferAttribute(t, n), this.applyBoneTransform(n, jo), this.boundingBox.expandByPoint(jo)
			}
			computeBoundingSphere() {
				let e = this.geometry;
				this.boundingSphere === null && (this.boundingSphere = new Gi), this.boundingSphere.makeEmpty();
				let t = e.getAttribute("position");
				for (let n = 0; n < t.count; n++) jo.fromBufferAttribute(t, n), this.applyBoneTransform(n, jo), this.boundingSphere.expandByPoint(jo)
			}
			copy(e, t) {
				return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
			}
			raycast(e, t) {
				let n = this.material,
					i = this.matrixWorld;
				n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), nf.copy(this.boundingSphere), nf.applyMatrix4(i), e.ray.intersectsSphere(nf) !== !1 && (Jm.copy(i).invert(), rf.copy(e.ray).applyMatrix4(Jm), !(this.boundingBox !== null && rf.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, rf)))
			}
			getVertexPosition(e, t) {
				return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
			}
			bind(e, t) {
				this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
			}
			pose() {
				this.skeleton.pose()
			}
			normalizeSkinWeights() {
				let e = new Ct,
					t = this.geometry.attributes.skinWeight;
				for (let n = 0, i = t.count; n < i; n++) {
					e.fromBufferAttribute(t, n);
					let s = 1 / e.manhattanLength();
					s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
				}
			}
			updateMatrixWorld(e) {
				super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
			}
			applyBoneTransform(e, t) {
				let n = this.skeleton,
					i = this.geometry;
				Ym.fromBufferAttribute(i.attributes.skinIndex, e), Km.fromBufferAttribute(i.attributes.skinWeight, e), jm.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
				for (let s = 0; s < 4; s++) {
					let o = Km.getComponent(s);
					if (o !== 0) {
						let a = Ym.getComponent(s);
						Zm.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(rM.copy(jm).applyMatrix4(Zm), o)
					}
				}
				return t.applyMatrix4(this.bindMatrixInverse)
			}
			boneTransform(e, t) {
				return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t)
			}
		},
		as = class extends Rt {
			constructor() {
				super(), this.isBone = !0, this.type = "Bone"
			}
		},
		ca = class extends Gn {
			constructor(e = null, t = 1, n = 1, i, s, o, a, l, c = pn, u = pn, h, f) {
				super(null, o, a, l, c, u, i, s, h, f), this.isDataTexture = !0, this.image = {
					data: e,
					width: t,
					height: n
				}, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
			}
		},
		$m = new Je,
		sM = new Je,
		ua = class r {
			constructor(e = [], t = []) {
				this.uuid = Gr(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init()
			}
			init() {
				let e = this.bones,
					t = this.boneInverses;
				if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
				else if (e.length !== t.length) {
					console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
					for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Je)
				}
			}
			calculateInverses() {
				this.boneInverses.length = 0;
				for (let e = 0, t = this.bones.length; e < t; e++) {
					let n = new Je;
					this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
				}
			}
			pose() {
				for (let e = 0, t = this.bones.length; e < t; e++) {
					let n = this.bones[e];
					n && n.matrixWorld.copy(this.boneInverses[e]).invert()
				}
				for (let e = 0, t = this.bones.length; e < t; e++) {
					let n = this.bones[e];
					n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
				}
			}
			update() {
				let e = this.bones,
					t = this.boneInverses,
					n = this.boneMatrices,
					i = this.boneTexture;
				for (let s = 0, o = e.length; s < o; s++) {
					let a = e[s] ? e[s].matrixWorld : sM;
					$m.multiplyMatrices(a, t[s]), $m.toArray(n, s * 16)
				}
				i !== null && (i.needsUpdate = !0)
			}
			clone() {
				return new r(this.bones, this.boneInverses)
			}
			computeBoneTexture() {
				let e = Math.sqrt(this.bones.length * 4);
				e = Cg(e), e = Math.max(e, 4);
				let t = new Float32Array(e * e * 4);
				t.set(this.boneMatrices);
				let n = new ca(t, e, e, xi, Or);
				return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
			}
			getBoneByName(e) {
				for (let t = 0, n = this.bones.length; t < n; t++) {
					let i = this.bones[t];
					if (i.name === e) return i
				}
			}
			dispose() {
				this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
			}
			fromJSON(e, t) {
				this.uuid = e.uuid;
				for (let n = 0, i = e.bones.length; n < i; n++) {
					let s = e.bones[n],
						o = t[s];
					o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new as), this.bones.push(o), this.boneInverses.push(new Je().fromArray(e.boneInverses[n]))
				}
				return this.init(), this
			}
			toJSON() {
				let e = {
					metadata: {
						version: 4.6,
						type: "Skeleton",
						generator: "Skeleton.toJSON"
					},
					bones: [],
					boneInverses: []
				};
				e.uuid = this.uuid;
				let t = this.bones,
					n = this.boneInverses;
				for (let i = 0, s = t.length; i < s; i++) {
					let o = t[i];
					e.bones.push(o.uuid);
					let a = n[i];
					e.boneInverses.push(a.toArray())
				}
				return e
			}
		};
	var Ei = class extends Vi {
			constructor(e) {
				super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new qe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
			}
		},
		Qm = new re,
		eg = new re,
		tg = new Je,
		sf = new Ws,
		su = new Gi,
		js = class extends Rt {
			constructor(e = new St, t = new Ei) {
				super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
			}
			copy(e, t) {
				return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
			}
			computeLineDistances() {
				let e = this.geometry;
				if (e.index === null) {
					let t = e.attributes.position,
						n = [0];
					for (let i = 1, s = t.count; i < s; i++) Qm.fromBufferAttribute(t, i - 1), eg.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += Qm.distanceTo(eg);
					e.setAttribute("lineDistance", new ze(n, 1))
				} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				return this
			}
			raycast(e, t) {
				let n = this.geometry,
					i = this.matrixWorld,
					s = e.params.Line.threshold,
					o = n.drawRange;
				if (n.boundingSphere === null && n.computeBoundingSphere(), su.copy(n.boundingSphere), su.applyMatrix4(i), su.radius += s, e.ray.intersectsSphere(su) === !1) return;
				tg.copy(i).invert(), sf.copy(e.ray).applyMatrix4(tg);
				let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					l = a * a,
					c = new re,
					u = new re,
					h = new re,
					f = new re,
					m = this.isLineSegments ? 2 : 1,
					g = n.index,
					d = n.attributes.position;
				if (g !== null) {
					let p = Math.max(0, o.start),
						_ = Math.min(g.count, o.start + o.count);
					for (let v = p, x = _ - 1; v < x; v += m) {
						let M = g.getX(v),
							I = g.getX(v + 1);
						if (c.fromBufferAttribute(d, M), u.fromBufferAttribute(d, I), sf.distanceSqToSegment(c, u, f, h) > l) continue;
						f.applyMatrix4(this.matrixWorld);
						let L = e.ray.origin.distanceTo(f);
						L < e.near || L > e.far || t.push({
							distance: L,
							point: h.clone().applyMatrix4(this.matrixWorld),
							index: v,
							face: null,
							faceIndex: null,
							object: this
						})
					}
				} else {
					let p = Math.max(0, o.start),
						_ = Math.min(d.count, o.start + o.count);
					for (let v = p, x = _ - 1; v < x; v += m) {
						if (c.fromBufferAttribute(d, v), u.fromBufferAttribute(d, v + 1), sf.distanceSqToSegment(c, u, f, h) > l) continue;
						f.applyMatrix4(this.matrixWorld);
						let I = e.ray.origin.distanceTo(f);
						I < e.near || I > e.far || t.push({
							distance: I,
							point: h.clone().applyMatrix4(this.matrixWorld),
							index: v,
							face: null,
							faceIndex: null,
							object: this
						})
					}
				}
			}
			updateMorphTargets() {
				let t = this.geometry.morphAttributes,
					n = Object.keys(t);
				if (n.length > 0) {
					let i = t[n[0]];
					if (i !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, o = i.length; s < o; s++) {
							let a = i[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
						}
					}
				}
			}
		},
		ng = new re,
		ig = new re,
		ls = class extends js {
			constructor(e, t) {
				super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
			}
			computeLineDistances() {
				let e = this.geometry;
				if (e.index === null) {
					let t = e.attributes.position,
						n = [];
					for (let i = 0, s = t.count; i < s; i += 2) ng.fromBufferAttribute(t, i), ig.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + ng.distanceTo(ig);
					e.setAttribute("lineDistance", new ze(n, 1))
				} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				return this
			}
		};
	var Ll = class extends Vi {
			constructor(e) {
				super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new qe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
			}
		},
		rg = new Je,
		Pf = new Ws,
		ou = new Gi,
		au = new re,
		bu = class extends Rt {
			constructor(e = new St, t = new Ll) {
				super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
			}
			copy(e, t) {
				return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
			}
			raycast(e, t) {
				let n = this.geometry,
					i = this.matrixWorld,
					s = e.params.Points.threshold,
					o = n.drawRange;
				if (n.boundingSphere === null && n.computeBoundingSphere(), ou.copy(n.boundingSphere), ou.applyMatrix4(i), ou.radius += s, e.ray.intersectsSphere(ou) === !1) return;
				rg.copy(i).invert(), Pf.copy(e.ray).applyMatrix4(rg);
				let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					l = a * a,
					c = n.index,
					h = n.attributes.position;
				if (c !== null) {
					let f = Math.max(0, o.start),
						m = Math.min(c.count, o.start + o.count);
					for (let g = f, y = m; g < y; g++) {
						let d = c.getX(g);
						au.fromBufferAttribute(h, d), sg(au, d, l, i, e, t, this)
					}
				} else {
					let f = Math.max(0, o.start),
						m = Math.min(h.count, o.start + o.count);
					for (let g = f, y = m; g < y; g++) au.fromBufferAttribute(h, g), sg(au, g, l, i, e, t, this)
				}
			}
			updateMorphTargets() {
				let t = this.geometry.morphAttributes,
					n = Object.keys(t);
				if (n.length > 0) {
					let i = t[n[0]];
					if (i !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, o = i.length; s < o; s++) {
							let a = i[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
						}
					}
				}
			}
		};

	function sg(r, e, t, n, i, s, o) {
		let a = Pf.distanceSqToPoint(r);
		if (a < t) {
			let l = new re;
			Pf.closestPointToPoint(r, l), l.applyMatrix4(n);
			let c = i.ray.origin.distanceTo(l);
			if (c < i.near || c > i.far) return;
			s.push({
				distance: c,
				distanceToRay: Math.sqrt(a),
				point: l,
				index: e,
				face: null,
				object: o
			})
		}
	}
	var ei = class {
			constructor() {
				this.type = "Curve", this.arcLengthDivisions = 200
			}
			getPoint() {
				return console.warn("THREE.Curve: .getPoint() not implemented."), null
			}
			getPointAt(e, t) {
				let n = this.getUtoTmapping(e);
				return this.getPoint(n, t)
			}
			getPoints(e = 5) {
				let t = [];
				for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
				return t
			}
			getSpacedPoints(e = 5) {
				let t = [];
				for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
				return t
			}
			getLength() {
				let e = this.getLengths();
				return e[e.length - 1]
			}
			getLengths(e = this.arcLengthDivisions) {
				if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
				this.needsUpdate = !1;
				let t = [],
					n, i = this.getPoint(0),
					s = 0;
				t.push(0);
				for (let o = 1; o <= e; o++) n = this.getPoint(o / e), s += n.distanceTo(i), t.push(s), i = n;
				return this.cacheArcLengths = t, t
			}
			updateArcLengths() {
				this.needsUpdate = !0, this.getLengths()
			}
			getUtoTmapping(e, t) {
				let n = this.getLengths(),
					i = 0,
					s = n.length,
					o;
				t ? o = t : o = e * n[s - 1];
				let a = 0,
					l = s - 1,
					c;
				for (; a <= l;)
					if (i = Math.floor(a + (l - a) / 2), c = n[i] - o, c < 0) a = i + 1;
					else if (c > 0) l = i - 1;
				else {
					l = i;
					break
				}
				if (i = l, n[i] === o) return i / (s - 1);
				let u = n[i],
					f = n[i + 1] - u,
					m = (o - u) / f;
				return (i + m) / (s - 1)
			}
			getTangent(e, t) {
				let i = e - 1e-4,
					s = e + 1e-4;
				i < 0 && (i = 0), s > 1 && (s = 1);
				let o = this.getPoint(i),
					a = this.getPoint(s),
					l = t || (o.isVector2 ? new Ce : new re);
				return l.copy(a).sub(o).normalize(), l
			}
			getTangentAt(e, t) {
				let n = this.getUtoTmapping(e);
				return this.getTangent(n, t)
			}
			computeFrenetFrames(e, t) {
				let n = new re,
					i = [],
					s = [],
					o = [],
					a = new re,
					l = new Je;
				for (let m = 0; m <= e; m++) {
					let g = m / e;
					i[m] = this.getTangentAt(g, new re)
				}
				s[0] = new re, o[0] = new re;
				let c = Number.MAX_VALUE,
					u = Math.abs(i[0].x),
					h = Math.abs(i[0].y),
					f = Math.abs(i[0].z);
				u <= c && (c = u, n.set(1, 0, 0)), h <= c && (c = h, n.set(0, 1, 0)), f <= c && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), s[0].crossVectors(i[0], a), o[0].crossVectors(i[0], s[0]);
				for (let m = 1; m <= e; m++) {
					if (s[m] = s[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(i[m - 1], i[m]), a.length() > Number.EPSILON) {
						a.normalize();
						let g = Math.acos(Pn(i[m - 1].dot(i[m]), -1, 1));
						s[m].applyMatrix4(l.makeRotationAxis(a, g))
					}
					o[m].crossVectors(i[m], s[m])
				}
				if (t === !0) {
					let m = Math.acos(Pn(s[0].dot(s[e]), -1, 1));
					m /= e, i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
					for (let g = 1; g <= e; g++) s[g].applyMatrix4(l.makeRotationAxis(i[g], m * g)), o[g].crossVectors(i[g], s[g])
				}
				return {
					tangents: i,
					normals: s,
					binormals: o
				}
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				return this.arcLengthDivisions = e.arcLengthDivisions, this
			}
			toJSON() {
				let e = {
					metadata: {
						version: 4.6,
						type: "Curve",
						generator: "Curve.toJSON"
					}
				};
				return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
			}
			fromJSON(e) {
				return this.arcLengthDivisions = e.arcLengthDivisions, this
			}
		},
		Nl = class extends ei {
			constructor(e = 0, t = 0, n = 1, i = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
				super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
			}
			getPoint(e, t) {
				let n = t || new Ce,
					i = Math.PI * 2,
					s = this.aEndAngle - this.aStartAngle,
					o = Math.abs(s) < Number.EPSILON;
				for (; s < 0;) s += i;
				for (; s > i;) s -= i;
				s < Number.EPSILON && (o ? s = 0 : s = i), this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
				let a = this.aStartAngle + e * s,
					l = this.aX + this.xRadius * Math.cos(a),
					c = this.aY + this.yRadius * Math.sin(a);
				if (this.aRotation !== 0) {
					let u = Math.cos(this.aRotation),
						h = Math.sin(this.aRotation),
						f = l - this.aX,
						m = c - this.aY;
					l = f * u - m * h + this.aX, c = f * h + m * u + this.aY
				}
				return n.set(l, c)
			}
			copy(e) {
				return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
			}
			toJSON() {
				let e = super.toJSON();
				return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
			}
		},
		Lf = class extends Nl {
			constructor(e, t, n, i, s, o) {
				super(e, t, n, n, i, s, o), this.isArcCurve = !0, this.type = "ArcCurve"
			}
		};

	function ed() {
		let r = 0,
			e = 0,
			t = 0,
			n = 0;

		function i(s, o, a, l) {
			r = s, e = a, t = -3 * s + 3 * o - 2 * a - l, n = 2 * s - 2 * o + a + l
		}
		return {
			initCatmullRom: function(s, o, a, l, c) {
				i(o, a, c * (a - s), c * (l - o))
			},
			initNonuniformCatmullRom: function(s, o, a, l, c, u, h) {
				let f = (o - s) / c - (a - s) / (c + u) + (a - o) / u,
					m = (a - o) / u - (l - o) / (u + h) + (l - a) / h;
				f *= u, m *= u, i(o, a, f, m)
			},
			calc: function(s) {
				let o = s * s,
					a = o * s;
				return r + e * s + t * o + n * a
			}
		}
	}
	var lu = new re,
		of = new ed,
		af = new ed,
		lf = new ed,
		Nf = class extends ei {
			constructor(e = [], t = !1, n = "centripetal", i = .5) {
				super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i
			}
			getPoint(e, t = new re) {
				let n = t,
					i = this.points,
					s = i.length,
					o = (s - (this.closed ? 0 : 1)) * e,
					a = Math.floor(o),
					l = o - a;
				this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
				let c, u;
				this.closed || a > 0 ? c = i[(a - 1) % s] : (lu.subVectors(i[0], i[1]).add(i[0]), c = lu);
				let h = i[a % s],
					f = i[(a + 1) % s];
				if (this.closed || a + 2 < s ? u = i[(a + 2) % s] : (lu.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), u = lu), this.curveType === "centripetal" || this.curveType === "chordal") {
					let m = this.curveType === "chordal" ? .5 : .25,
						g = Math.pow(c.distanceToSquared(h), m),
						y = Math.pow(h.distanceToSquared(f), m),
						d = Math.pow(f.distanceToSquared(u), m);
					y < 1e-4 && (y = 1), g < 1e-4 && (g = y), d < 1e-4 && (d = y), of.initNonuniformCatmullRom(c.x, h.x, f.x, u.x, g, y, d), af.initNonuniformCatmullRom(c.y, h.y, f.y, u.y, g, y, d), lf.initNonuniformCatmullRom(c.z, h.z, f.z, u.z, g, y, d)
				} else this.curveType === "catmullrom" && (of.initCatmullRom(c.x, h.x, f.x, u.x, this.tension), af.initCatmullRom(c.y, h.y, f.y, u.y, this.tension), lf.initCatmullRom(c.z, h.z, f.z, u.z, this.tension));
				return n.set(of.calc(l), af.calc(l), lf.calc(l)), n
			}
			copy(e) {
				super.copy(e), this.points = [];
				for (let t = 0, n = e.points.length; t < n; t++) {
					let i = e.points[t];
					this.points.push(i.clone())
				}
				return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
			}
			toJSON() {
				let e = super.toJSON();
				e.points = [];
				for (let t = 0, n = this.points.length; t < n; t++) {
					let i = this.points[t];
					e.points.push(i.toArray())
				}
				return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
			}
			fromJSON(e) {
				super.fromJSON(e), this.points = [];
				for (let t = 0, n = e.points.length; t < n; t++) {
					let i = e.points[t];
					this.points.push(new re().fromArray(i))
				}
				return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
			}
		};

	function og(r, e, t, n, i) {
		let s = (n - e) * .5,
			o = (i - t) * .5,
			a = r * r,
			l = r * a;
		return (2 * t - 2 * n + s + o) * l + (-3 * t + 3 * n - 2 * s - o) * a + s * r + t
	}

	function oM(r, e) {
		let t = 1 - r;
		return t * t * e
	}

	function aM(r, e) {
		return 2 * (1 - r) * r * e
	}

	function lM(r, e) {
		return r * r * e
	}

	function Ml(r, e, t, n) {
		return oM(r, e) + aM(r, t) + lM(r, n)
	}

	function cM(r, e) {
		let t = 1 - r;
		return t * t * t * e
	}

	function uM(r, e) {
		let t = 1 - r;
		return 3 * t * t * r * e
	}

	function hM(r, e) {
		return 3 * (1 - r) * r * r * e
	}

	function fM(r, e) {
		return r * r * r * e
	}

	function bl(r, e, t, n, i) {
		return cM(r, e) + uM(r, t) + hM(r, n) + fM(r, i)
	}
	var Su = class extends ei {
			constructor(e = new Ce, t = new Ce, n = new Ce, i = new Ce) {
				super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
			}
			getPoint(e, t = new Ce) {
				let n = t,
					i = this.v0,
					s = this.v1,
					o = this.v2,
					a = this.v3;
				return n.set(bl(e, i.x, s.x, o.x, a.x), bl(e, i.y, s.y, o.y, a.y)), n
			}
			copy(e) {
				return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
			}
			toJSON() {
				let e = super.toJSON();
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
			}
		},
		Of = class extends ei {
			constructor(e = new re, t = new re, n = new re, i = new re) {
				super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
			}
			getPoint(e, t = new re) {
				let n = t,
					i = this.v0,
					s = this.v1,
					o = this.v2,
					a = this.v3;
				return n.set(bl(e, i.x, s.x, o.x, a.x), bl(e, i.y, s.y, o.y, a.y), bl(e, i.z, s.z, o.z, a.z)), n
			}
			copy(e) {
				return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
			}
			toJSON() {
				let e = super.toJSON();
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
			}
		},
		Ol = class extends ei {
			constructor(e = new Ce, t = new Ce) {
				super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
			}
			getPoint(e, t = new Ce) {
				let n = t;
				return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
			}
			getPointAt(e, t) {
				return this.getPoint(e, t)
			}
			getTangent(e, t = new Ce) {
				return t.subVectors(this.v2, this.v1).normalize()
			}
			getTangentAt(e, t) {
				return this.getTangent(e, t)
			}
			copy(e) {
				return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}
			toJSON() {
				let e = super.toJSON();
				return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}
		},
		Df = class extends ei {
			constructor(e = new re, t = new re) {
				super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
			}
			getPoint(e, t = new re) {
				let n = t;
				return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
			}
			getPointAt(e, t) {
				return this.getPoint(e, t)
			}
			getTangent(e, t = new re) {
				return t.subVectors(this.v2, this.v1).normalize()
			}
			getTangentAt(e, t) {
				return this.getTangent(e, t)
			}
			copy(e) {
				return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}
			toJSON() {
				let e = super.toJSON();
				return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}
		},
		Au = class extends ei {
			constructor(e = new Ce, t = new Ce, n = new Ce) {
				super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
			}
			getPoint(e, t = new Ce) {
				let n = t,
					i = this.v0,
					s = this.v1,
					o = this.v2;
				return n.set(Ml(e, i.x, s.x, o.x), Ml(e, i.y, s.y, o.y)), n
			}
			copy(e) {
				return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}
			toJSON() {
				let e = super.toJSON();
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}
		},
		Ff = class extends ei {
			constructor(e = new re, t = new re, n = new re) {
				super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
			}
			getPoint(e, t = new re) {
				let n = t,
					i = this.v0,
					s = this.v1,
					o = this.v2;
				return n.set(Ml(e, i.x, s.x, o.x), Ml(e, i.y, s.y, o.y), Ml(e, i.z, s.z, o.z)), n
			}
			copy(e) {
				return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
			}
			toJSON() {
				let e = super.toJSON();
				return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
			}
		},
		wu = class extends ei {
			constructor(e = []) {
				super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
			}
			getPoint(e, t = new Ce) {
				let n = t,
					i = this.points,
					s = (i.length - 1) * e,
					o = Math.floor(s),
					a = s - o,
					l = i[o === 0 ? o : o - 1],
					c = i[o],
					u = i[o > i.length - 2 ? i.length - 1 : o + 1],
					h = i[o > i.length - 3 ? i.length - 1 : o + 2];
				return n.set(og(a, l.x, c.x, u.x, h.x), og(a, l.y, c.y, u.y, h.y)), n
			}
			copy(e) {
				super.copy(e), this.points = [];
				for (let t = 0, n = e.points.length; t < n; t++) {
					let i = e.points[t];
					this.points.push(i.clone())
				}
				return this
			}
			toJSON() {
				let e = super.toJSON();
				e.points = [];
				for (let t = 0, n = this.points.length; t < n; t++) {
					let i = this.points[t];
					e.points.push(i.toArray())
				}
				return e
			}
			fromJSON(e) {
				super.fromJSON(e), this.points = [];
				for (let t = 0, n = e.points.length; t < n; t++) {
					let i = e.points[t];
					this.points.push(new Ce().fromArray(i))
				}
				return this
			}
		},
		Ug = Object.freeze({
			__proto__: null,
			ArcCurve: Lf,
			CatmullRomCurve3: Nf,
			CubicBezierCurve: Su,
			CubicBezierCurve3: Of,
			EllipseCurve: Nl,
			LineCurve: Ol,
			LineCurve3: Df,
			QuadraticBezierCurve: Au,
			QuadraticBezierCurve3: Ff,
			SplineCurve: wu
		}),
		Uf = class extends ei {
			constructor() {
				super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
			}
			add(e) {
				this.curves.push(e)
			}
			closePath() {
				let e = this.curves[0].getPoint(0),
					t = this.curves[this.curves.length - 1].getPoint(1);
				e.equals(t) || this.curves.push(new Ol(t, e))
			}
			getPoint(e, t) {
				let n = e * this.getLength(),
					i = this.getCurveLengths(),
					s = 0;
				for (; s < i.length;) {
					if (i[s] >= n) {
						let o = i[s] - n,
							a = this.curves[s],
							l = a.getLength(),
							c = l === 0 ? 0 : 1 - o / l;
						return a.getPointAt(c, t)
					}
					s++
				}
				return null
			}
			getLength() {
				let e = this.getCurveLengths();
				return e[e.length - 1]
			}
			updateArcLengths() {
				this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
			}
			getCurveLengths() {
				if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
				let e = [],
					t = 0;
				for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
				return this.cacheLengths = e, e
			}
			getSpacedPoints(e = 40) {
				let t = [];
				for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
				return this.autoClose && t.push(t[0]), t
			}
			getPoints(e = 12) {
				let t = [],
					n;
				for (let i = 0, s = this.curves; i < s.length; i++) {
					let o = s[i],
						a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
						l = o.getPoints(a);
					for (let c = 0; c < l.length; c++) {
						let u = l[c];
						n && n.equals(u) || (t.push(u), n = u)
					}
				}
				return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
			}
			copy(e) {
				super.copy(e), this.curves = [];
				for (let t = 0, n = e.curves.length; t < n; t++) {
					let i = e.curves[t];
					this.curves.push(i.clone())
				}
				return this.autoClose = e.autoClose, this
			}
			toJSON() {
				let e = super.toJSON();
				e.autoClose = this.autoClose, e.curves = [];
				for (let t = 0, n = this.curves.length; t < n; t++) {
					let i = this.curves[t];
					e.curves.push(i.toJSON())
				}
				return e
			}
			fromJSON(e) {
				super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
				for (let t = 0, n = e.curves.length; t < n; t++) {
					let i = e.curves[t];
					this.curves.push(new Ug[i.type]().fromJSON(i))
				}
				return this
			}
		},
		Br = class extends Uf {
			constructor(e) {
				super(), this.type = "Path", this.currentPoint = new Ce, e && this.setFromPoints(e)
			}
			setFromPoints(e) {
				this.moveTo(e[0].x, e[0].y);
				for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
				return this
			}
			moveTo(e, t) {
				return this.currentPoint.set(e, t), this
			}
			lineTo(e, t) {
				let n = new Ol(this.currentPoint.clone(), new Ce(e, t));
				return this.curves.push(n), this.currentPoint.set(e, t), this
			}
			quadraticCurveTo(e, t, n, i) {
				let s = new Au(this.currentPoint.clone(), new Ce(e, t), new Ce(n, i));
				return this.curves.push(s), this.currentPoint.set(n, i), this
			}
			bezierCurveTo(e, t, n, i, s, o) {
				let a = new Su(this.currentPoint.clone(), new Ce(e, t), new Ce(n, i), new Ce(s, o));
				return this.curves.push(a), this.currentPoint.set(s, o), this
			}
			splineThru(e) {
				let t = [this.currentPoint.clone()].concat(e),
					n = new wu(t);
				return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
			}
			arc(e, t, n, i, s, o) {
				let a = this.currentPoint.x,
					l = this.currentPoint.y;
				return this.absarc(e + a, t + l, n, i, s, o), this
			}
			absarc(e, t, n, i, s, o) {
				return this.absellipse(e, t, n, n, i, s, o), this
			}
			ellipse(e, t, n, i, s, o, a, l) {
				let c = this.currentPoint.x,
					u = this.currentPoint.y;
				return this.absellipse(e + c, t + u, n, i, s, o, a, l), this
			}
			absellipse(e, t, n, i, s, o, a, l) {
				let c = new Nl(e, t, n, i, s, o, a, l);
				if (this.curves.length > 0) {
					let h = c.getPoint(0);
					h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
				}
				this.curves.push(c);
				let u = c.getPoint(1);
				return this.currentPoint.copy(u), this
			}
			copy(e) {
				return super.copy(e), this.currentPoint.copy(e.currentPoint), this
			}
			toJSON() {
				let e = super.toJSON();
				return e.currentPoint = this.currentPoint.toArray(), e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
			}
		};
	var Dl = class r extends St {
			constructor(e = 1, t = 1, n = 1, i = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
				super(), this.type = "CylinderGeometry", this.parameters = {
					radiusTop: e,
					radiusBottom: t,
					height: n,
					radialSegments: i,
					heightSegments: s,
					openEnded: o,
					thetaStart: a,
					thetaLength: l
				};
				let c = this;
				i = Math.floor(i), s = Math.floor(s);
				let u = [],
					h = [],
					f = [],
					m = [],
					g = 0,
					y = [],
					d = n / 2,
					p = 0;
				_(), o === !1 && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(u), this.setAttribute("position", new ze(h, 3)), this.setAttribute("normal", new ze(f, 3)), this.setAttribute("uv", new ze(m, 2));

				function _() {
					let x = new re,
						M = new re,
						I = 0,
						w = (t - e) / n;
					for (let L = 0; L <= s; L++) {
						let T = [],
							C = L / s,
							V = C * (t - e) + e;
						for (let k = 0; k <= i; k++) {
							let F = k / i,
								U = F * l + a,
								K = Math.sin(U),
								Z = Math.cos(U);
							M.x = V * K, M.y = -C * n + d, M.z = V * Z, h.push(M.x, M.y, M.z), x.set(K, w, Z).normalize(), f.push(x.x, x.y, x.z), m.push(F, 1 - C), T.push(g++)
						}
						y.push(T)
					}
					for (let L = 0; L < i; L++)
						for (let T = 0; T < s; T++) {
							let C = y[T][L],
								V = y[T + 1][L],
								k = y[T + 1][L + 1],
								F = y[T][L + 1];
							u.push(C, V, F), u.push(V, k, F), I += 6
						}
					c.addGroup(p, I, 0), p += I
				}

				function v(x) {
					let M = g,
						I = new Ce,
						w = new re,
						L = 0,
						T = x === !0 ? e : t,
						C = x === !0 ? 1 : -1;
					for (let k = 1; k <= i; k++) h.push(0, d * C, 0), f.push(0, C, 0), m.push(.5, .5), g++;
					let V = g;
					for (let k = 0; k <= i; k++) {
						let U = k / i * l + a,
							K = Math.cos(U),
							Z = Math.sin(U);
						w.x = T * Z, w.y = d * C, w.z = T * K, h.push(w.x, w.y, w.z), f.push(0, C, 0), I.x = K * .5 + .5, I.y = Z * .5 * C + .5, m.push(I.x, I.y), g++
					}
					for (let k = 0; k < i; k++) {
						let F = M + k,
							U = V + k;
						x === !0 ? u.push(U, U + 1, F) : u.push(U + 1, U, F), L += 3
					}
					c.addGroup(p, L, x === !0 ? 1 : 2), p += L
				}
			}
			copy(e) {
				return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
			}
			static fromJSON(e) {
				return new r(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
			}
		},
		Cu = class r extends Dl {
			constructor(e = 1, t = 1, n = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
				super(0, e, t, n, i, s, o, a), this.type = "ConeGeometry", this.parameters = {
					radius: e,
					height: t,
					radialSegments: n,
					heightSegments: i,
					openEnded: s,
					thetaStart: o,
					thetaLength: a
				}
			}
			static fromJSON(e) {
				return new r(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
			}
		};
	var cu = new re,
		uu = new re,
		cf = new re,
		hu = new ks,
		Ru = class extends St {
			constructor(e = null, t = 1) {
				if (super(), this.type = "EdgesGeometry", this.parameters = {
						geometry: e,
						thresholdAngle: t
					}, e !== null) {
					let i = Math.pow(10, 4),
						s = Math.cos($o * t),
						o = e.getIndex(),
						a = e.getAttribute("position"),
						l = o ? o.count : a.count,
						c = [0, 0, 0],
						u = ["a", "b", "c"],
						h = new Array(3),
						f = {},
						m = [];
					for (let g = 0; g < l; g += 3) {
						o ? (c[0] = o.getX(g), c[1] = o.getX(g + 1), c[2] = o.getX(g + 2)) : (c[0] = g, c[1] = g + 1, c[2] = g + 2);
						let {
							a: y,
							b: d,
							c: p
						} = hu;
						if (y.fromBufferAttribute(a, c[0]), d.fromBufferAttribute(a, c[1]), p.fromBufferAttribute(a, c[2]), hu.getNormal(cf), h[0] = `${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`, h[1] = `${Math.round(d.x*i)},${Math.round(d.y*i)},${Math.round(d.z*i)}`, h[2] = `${Math.round(p.x*i)},${Math.round(p.y*i)},${Math.round(p.z*i)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
							for (let _ = 0; _ < 3; _++) {
								let v = (_ + 1) % 3,
									x = h[_],
									M = h[v],
									I = hu[u[_]],
									w = hu[u[v]],
									L = `${x}_${M}`,
									T = `${M}_${x}`;
								T in f && f[T] ? (cf.dot(f[T].normal) <= s && (m.push(I.x, I.y, I.z), m.push(w.x, w.y, w.z)), f[T] = null) : L in f || (f[L] = {
									index0: c[_],
									index1: c[v],
									normal: cf.clone()
								})
							}
					}
					for (let g in f)
						if (f[g]) {
							let {
								index0: y,
								index1: d
							} = f[g];
							cu.fromBufferAttribute(a, y), uu.fromBufferAttribute(a, d), m.push(cu.x, cu.y, cu.z), m.push(uu.x, uu.y, uu.z)
						} this.setAttribute("position", new ze(m, 3))
				}
			}
			copy(e) {
				return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
			}
		},
		ss = class extends Br {
			constructor(e) {
				super(e), this.uuid = Gr(), this.type = "Shape", this.holes = []
			}
			getPointsHoles(e) {
				let t = [];
				for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
				return t
			}
			extractPoints(e) {
				return {
					shape: this.getPoints(e),
					holes: this.getPointsHoles(e)
				}
			}
			copy(e) {
				super.copy(e), this.holes = [];
				for (let t = 0, n = e.holes.length; t < n; t++) {
					let i = e.holes[t];
					this.holes.push(i.clone())
				}
				return this
			}
			toJSON() {
				let e = super.toJSON();
				e.uuid = this.uuid, e.holes = [];
				for (let t = 0, n = this.holes.length; t < n; t++) {
					let i = this.holes[t];
					e.holes.push(i.toJSON())
				}
				return e
			}
			fromJSON(e) {
				super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
				for (let t = 0, n = e.holes.length; t < n; t++) {
					let i = e.holes[t];
					this.holes.push(new Br().fromJSON(i))
				}
				return this
			}
		},
		dM = {
			triangulate: function(r, e, t = 2) {
				let n = e && e.length,
					i = n ? e[0] * t : r.length,
					s = kg(r, 0, i, t, !0),
					o = [];
				if (!s || s.next === s.prev) return o;
				let a, l, c, u, h, f, m;
				if (n && (s = vM(r, e, s, t)), r.length > 80 * t) {
					a = c = r[0], l = u = r[1];
					for (let g = t; g < i; g += t) h = r[g], f = r[g + 1], h < a && (a = h), f < l && (l = f), h > c && (c = h), f > u && (u = f);
					m = Math.max(c - a, u - l), m = m !== 0 ? 32767 / m : 0
				}
				return Fl(s, o, t, a, l, m, 0), o
			}
		};

	function kg(r, e, t, n, i) {
		let s, o;
		if (i === RM(r, e, t, n) > 0)
			for (s = e; s < t; s += n) o = ag(s, r[s], r[s + 1], o);
		else
			for (s = t - n; s >= e; s -= n) o = ag(s, r[s], r[s + 1], o);
		return o && zu(o, o.next) && (kl(o), o = o.next), o
	}

	function Ys(r, e) {
		if (!r) return r;
		e || (e = r);
		let t = r,
			n;
		do
			if (n = !1, !t.steiner && (zu(t, t.next) || sn(t.prev, t, t.next) === 0)) {
				if (kl(t), t = e = t.prev, t === t.next) break;
				n = !0
			} else t = t.next; while (n || t !== e);
		return e
	}

	function Fl(r, e, t, n, i, s, o) {
		if (!r) return;
		!o && s && MM(r, n, i, s);
		let a = r,
			l, c;
		for (; r.prev !== r.next;) {
			if (l = r.prev, c = r.next, s ? mM(r, n, i, s) : pM(r)) {
				e.push(l.i / t | 0), e.push(r.i / t | 0), e.push(c.i / t | 0), kl(r), r = c.next, a = c.next;
				continue
			}
			if (r = c, r === a) {
				o ? o === 1 ? (r = gM(Ys(r), e, t), Fl(r, e, t, n, i, s, 2)) : o === 2 && yM(r, e, t, n, i, s) : Fl(Ys(r), e, t, n, i, s, 1);
				break
			}
		}
	}

	function pM(r) {
		let e = r.prev,
			t = r,
			n = r.next;
		if (sn(e, t, n) >= 0) return !1;
		let i = e.x,
			s = t.x,
			o = n.x,
			a = e.y,
			l = t.y,
			c = n.y,
			u = i < s ? i < o ? i : o : s < o ? s : o,
			h = a < l ? a < c ? a : c : l < c ? l : c,
			f = i > s ? i > o ? i : o : s > o ? s : o,
			m = a > l ? a > c ? a : c : l > c ? l : c,
			g = n.next;
		for (; g !== e;) {
			if (g.x >= u && g.x <= f && g.y >= h && g.y <= m && Zo(i, a, s, l, o, c, g.x, g.y) && sn(g.prev, g, g.next) >= 0) return !1;
			g = g.next
		}
		return !0
	}

	function mM(r, e, t, n) {
		let i = r.prev,
			s = r,
			o = r.next;
		if (sn(i, s, o) >= 0) return !1;
		let a = i.x,
			l = s.x,
			c = o.x,
			u = i.y,
			h = s.y,
			f = o.y,
			m = a < l ? a < c ? a : c : l < c ? l : c,
			g = u < h ? u < f ? u : f : h < f ? h : f,
			y = a > l ? a > c ? a : c : l > c ? l : c,
			d = u > h ? u > f ? u : f : h > f ? h : f,
			p = kf(m, g, e, t, n),
			_ = kf(y, d, e, t, n),
			v = r.prevZ,
			x = r.nextZ;
		for (; v && v.z >= p && x && x.z <= _;) {
			if (v.x >= m && v.x <= y && v.y >= g && v.y <= d && v !== i && v !== o && Zo(a, u, l, h, c, f, v.x, v.y) && sn(v.prev, v, v.next) >= 0 || (v = v.prevZ, x.x >= m && x.x <= y && x.y >= g && x.y <= d && x !== i && x !== o && Zo(a, u, l, h, c, f, x.x, x.y) && sn(x.prev, x, x.next) >= 0)) return !1;
			x = x.nextZ
		}
		for (; v && v.z >= p;) {
			if (v.x >= m && v.x <= y && v.y >= g && v.y <= d && v !== i && v !== o && Zo(a, u, l, h, c, f, v.x, v.y) && sn(v.prev, v, v.next) >= 0) return !1;
			v = v.prevZ
		}
		for (; x && x.z <= _;) {
			if (x.x >= m && x.x <= y && x.y >= g && x.y <= d && x !== i && x !== o && Zo(a, u, l, h, c, f, x.x, x.y) && sn(x.prev, x, x.next) >= 0) return !1;
			x = x.nextZ
		}
		return !0
	}

	function gM(r, e, t) {
		let n = r;
		do {
			let i = n.prev,
				s = n.next.next;
			!zu(i, s) && Bg(i, n, n.next, s) && Ul(i, s) && Ul(s, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(s.i / t | 0), kl(n), kl(n.next), n = r = s), n = n.next
		} while (n !== r);
		return Ys(n)
	}

	function yM(r, e, t, n, i, s) {
		let o = r;
		do {
			let a = o.next.next;
			for (; a !== o.prev;) {
				if (o.i !== a.i && AM(o, a)) {
					let l = Gg(o, a);
					o = Ys(o, o.next), l = Ys(l, l.next), Fl(o, e, t, n, i, s, 0), Fl(l, e, t, n, i, s, 0);
					return
				}
				a = a.next
			}
			o = o.next
		} while (o !== r)
	}

	function vM(r, e, t, n) {
		let i = [],
			s, o, a, l, c;
		for (s = 0, o = e.length; s < o; s++) a = e[s] * n, l = s < o - 1 ? e[s + 1] * n : r.length, c = kg(r, a, l, n, !1), c === c.next && (c.steiner = !0), i.push(SM(c));
		for (i.sort(xM), s = 0; s < i.length; s++) t = _M(i[s], t);
		return t
	}

	function xM(r, e) {
		return r.x - e.x
	}

	function _M(r, e) {
		let t = TM(r, e);
		if (!t) return e;
		let n = Gg(t, r);
		return Ys(n, n.next), Ys(t, t.next)
	}

	function TM(r, e) {
		let t = e,
			n = -1 / 0,
			i, s = r.x,
			o = r.y;
		do {
			if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
				let f = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
				if (f <= s && f > n && (n = f, i = t.x < t.next.x ? t : t.next, f === s)) return i
			}
			t = t.next
		} while (t !== e);
		if (!i) return null;
		let a = i,
			l = i.x,
			c = i.y,
			u = 1 / 0,
			h;
		t = i;
		do s >= t.x && t.x >= l && s !== t.x && Zo(o < c ? s : n, o, l, c, o < c ? n : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), Ul(t, r) && (h < u || h === u && (t.x > i.x || t.x === i.x && EM(i, t))) && (i = t, u = h)), t = t.next; while (t !== a);
		return i
	}

	function EM(r, e) {
		return sn(r.prev, r, e.prev) < 0 && sn(e.next, r, r.next) < 0
	}

	function MM(r, e, t, n) {
		let i = r;
		do i.z === 0 && (i.z = kf(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== r);
		i.prevZ.nextZ = null, i.prevZ = null, bM(i)
	}

	function bM(r) {
		let e, t, n, i, s, o, a, l, c = 1;
		do {
			for (t = r, r = null, s = null, o = 0; t;) {
				for (o++, n = t, a = 0, e = 0; e < c && (a++, n = n.nextZ, !!n); e++);
				for (l = c; a > 0 || l > 0 && n;) a !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : r = i, i.prevZ = s, s = i;
				t = n
			}
			s.nextZ = null, c *= 2
		} while (o > 1);
		return r
	}

	function kf(r, e, t, n, i) {
		return r = (r - t) * i | 0, e = (e - n) * i | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1
	}

	function SM(r) {
		let e = r,
			t = r;
		do(e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== r);
		return t
	}

	function Zo(r, e, t, n, i, s, o, a) {
		return (i - o) * (e - a) >= (r - o) * (s - a) && (r - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (i - o) * (n - a)
	}

	function AM(r, e) {
		return r.next.i !== e.i && r.prev.i !== e.i && !wM(r, e) && (Ul(r, e) && Ul(e, r) && CM(r, e) && (sn(r.prev, r, e.prev) || sn(r, e.prev, e)) || zu(r, e) && sn(r.prev, r, r.next) > 0 && sn(e.prev, e, e.next) > 0)
	}

	function sn(r, e, t) {
		return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
	}

	function zu(r, e) {
		return r.x === e.x && r.y === e.y
	}

	function Bg(r, e, t, n) {
		let i = du(sn(r, e, t)),
			s = du(sn(r, e, n)),
			o = du(sn(t, n, r)),
			a = du(sn(t, n, e));
		return !!(i !== s && o !== a || i === 0 && fu(r, t, e) || s === 0 && fu(r, n, e) || o === 0 && fu(t, r, n) || a === 0 && fu(t, e, n))
	}

	function fu(r, e, t) {
		return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y)
	}

	function du(r) {
		return r > 0 ? 1 : r < 0 ? -1 : 0
	}

	function wM(r, e) {
		let t = r;
		do {
			if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && Bg(t, t.next, r, e)) return !0;
			t = t.next
		} while (t !== r);
		return !1
	}

	function Ul(r, e) {
		return sn(r.prev, r, r.next) < 0 ? sn(r, e, r.next) >= 0 && sn(r, r.prev, e) >= 0 : sn(r, e, r.prev) < 0 || sn(r, r.next, e) < 0
	}

	function CM(r, e) {
		let t = r,
			n = !1,
			i = (r.x + e.x) / 2,
			s = (r.y + e.y) / 2;
		do t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next; while (t !== r);
		return n
	}

	function Gg(r, e) {
		let t = new Bf(r.i, r.x, r.y),
			n = new Bf(e.i, e.x, e.y),
			i = r.next,
			s = e.prev;
		return r.next = e, e.prev = r, t.next = i, i.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n
	}

	function ag(r, e, t, n) {
		let i = new Bf(r, e, t);
		return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i
	}

	function kl(r) {
		r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ)
	}

	function Bf(r, e, t) {
		this.i = r, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
	}

	function RM(r, e, t, n) {
		let i = 0;
		for (let s = e, o = t - n; s < t; s += n) i += (r[o] - r[s]) * (r[s + 1] + r[o + 1]), o = s;
		return i
	}
	var lr = class r {
		static area(e) {
			let t = e.length,
				n = 0;
			for (let i = t - 1, s = 0; s < t; i = s++) n += e[i].x * e[s].y - e[s].x * e[i].y;
			return n * .5
		}
		static isClockWise(e) {
			return r.area(e) < 0
		}
		static triangulateShape(e, t) {
			let n = [],
				i = [],
				s = [];
			lg(e), cg(n, e);
			let o = e.length;
			t.forEach(lg);
			for (let l = 0; l < t.length; l++) i.push(o), o += t[l].length, cg(n, t[l]);
			let a = dM.triangulate(n, i);
			for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
			return s
		}
	};

	function lg(r) {
		let e = r.length;
		e > 2 && r[e - 1].equals(r[0]) && r.pop()
	}

	function cg(r, e) {
		for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y)
	}
	var Iu = class r extends St {
			constructor(e = new ss([new Ce(.5, .5), new Ce(-.5, .5), new Ce(-.5, -.5), new Ce(.5, -.5)]), t = {}) {
				super(), this.type = "ExtrudeGeometry", this.parameters = {
					shapes: e,
					options: t
				}, e = Array.isArray(e) ? e : [e];
				let n = this,
					i = [],
					s = [];
				for (let a = 0, l = e.length; a < l; a++) {
					let c = e[a];
					o(c)
				}
				this.setAttribute("position", new ze(i, 3)), this.setAttribute("uv", new ze(s, 2)), this.computeVertexNormals();

				function o(a) {
					let l = [],
						c = t.curveSegments !== void 0 ? t.curveSegments : 12,
						u = t.steps !== void 0 ? t.steps : 1,
						h = t.depth !== void 0 ? t.depth : 1,
						f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
						m = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
						g = t.bevelSize !== void 0 ? t.bevelSize : m - .1,
						y = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
						d = t.bevelSegments !== void 0 ? t.bevelSegments : 3,
						p = t.extrudePath,
						_ = t.UVGenerator !== void 0 ? t.UVGenerator : IM,
						v, x = !1,
						M, I, w, L;
					p && (v = p.getSpacedPoints(u), x = !0, f = !1, M = p.computeFrenetFrames(u, !1), I = new re, w = new re, L = new re), f || (d = 0, m = 0, g = 0, y = 0);
					let T = a.extractPoints(c),
						C = T.shape,
						V = T.holes;
					if (!lr.isClockWise(C)) {
						C = C.reverse();
						for (let N = 0, pe = V.length; N < pe; N++) {
							let Q = V[N];
							lr.isClockWise(Q) && (V[N] = Q.reverse())
						}
					}
					let F = lr.triangulateShape(C, V),
						U = C;
					for (let N = 0, pe = V.length; N < pe; N++) {
						let Q = V[N];
						C = C.concat(Q)
					}

					function K(N, pe, Q) {
						return pe || console.error("THREE.ExtrudeGeometry: vec does not exist"), N.clone().addScaledVector(pe, Q)
					}
					let Z = C.length,
						Y = F.length;

					function H(N, pe, Q) {
						let he, ye, Ee, ie = N.x - pe.x,
							q = N.y - pe.y,
							Me = Q.x - N.x,
							Pe = Q.y - N.y,
							Ke = ie * ie + q * q,
							R = ie * Pe - q * Me;
						if (Math.abs(R) > Number.EPSILON) {
							let E = Math.sqrt(Ke),
								B = Math.sqrt(Me * Me + Pe * Pe),
								ne = pe.x - q / E,
								X = pe.y + ie / E,
								ae = Q.x - Pe / B,
								ge = Q.y + Me / B,
								ue = ((ae - ne) * Pe - (ge - X) * Me) / (ie * Pe - q * Me);
							he = ne + ie * ue - N.x, ye = X + q * ue - N.y;
							let se = he * he + ye * ye;
							if (se <= 2) return new Ce(he, ye);
							Ee = Math.sqrt(se / 2)
						} else {
							let E = !1;
							ie > Number.EPSILON ? Me > Number.EPSILON && (E = !0) : ie < -Number.EPSILON ? Me < -Number.EPSILON && (E = !0) : Math.sign(q) === Math.sign(Pe) && (E = !0), E ? (he = -q, ye = ie, Ee = Math.sqrt(Ke)) : (he = ie, ye = q, Ee = Math.sqrt(Ke / 2))
						}
						return new Ce(he / Ee, ye / Ee)
					}
					let oe = [];
					for (let N = 0, pe = U.length, Q = pe - 1, he = N + 1; N < pe; N++, Q++, he++) Q === pe && (Q = 0), he === pe && (he = 0), oe[N] = H(U[N], U[Q], U[he]);
					let de = [],
						te, fe = oe.concat();
					for (let N = 0, pe = V.length; N < pe; N++) {
						let Q = V[N];
						te = [];
						for (let he = 0, ye = Q.length, Ee = ye - 1, ie = he + 1; he < ye; he++, Ee++, ie++) Ee === ye && (Ee = 0), ie === ye && (ie = 0), te[he] = H(Q[he], Q[Ee], Q[ie]);
						de.push(te), fe = fe.concat(te)
					}
					for (let N = 0; N < d; N++) {
						let pe = N / d,
							Q = m * Math.cos(pe * Math.PI / 2),
							he = g * Math.sin(pe * Math.PI / 2) + y;
						for (let ye = 0, Ee = U.length; ye < Ee; ye++) {
							let ie = K(U[ye], oe[ye], he);
							A(ie.x, ie.y, -Q)
						}
						for (let ye = 0, Ee = V.length; ye < Ee; ye++) {
							let ie = V[ye];
							te = de[ye];
							for (let q = 0, Me = ie.length; q < Me; q++) {
								let Pe = K(ie[q], te[q], he);
								A(Pe.x, Pe.y, -Q)
							}
						}
					}
					let me = g + y;
					for (let N = 0; N < Z; N++) {
						let pe = f ? K(C[N], fe[N], me) : C[N];
						x ? (w.copy(M.normals[0]).multiplyScalar(pe.x), I.copy(M.binormals[0]).multiplyScalar(pe.y), L.copy(v[0]).add(w).add(I), A(L.x, L.y, L.z)) : A(pe.x, pe.y, 0)
					}
					for (let N = 1; N <= u; N++)
						for (let pe = 0; pe < Z; pe++) {
							let Q = f ? K(C[pe], fe[pe], me) : C[pe];
							x ? (w.copy(M.normals[N]).multiplyScalar(Q.x), I.copy(M.binormals[N]).multiplyScalar(Q.y), L.copy(v[N]).add(w).add(I), A(L.x, L.y, L.z)) : A(Q.x, Q.y, h / u * N)
						}
					for (let N = d - 1; N >= 0; N--) {
						let pe = N / d,
							Q = m * Math.cos(pe * Math.PI / 2),
							he = g * Math.sin(pe * Math.PI / 2) + y;
						for (let ye = 0, Ee = U.length; ye < Ee; ye++) {
							let ie = K(U[ye], oe[ye], he);
							A(ie.x, ie.y, h + Q)
						}
						for (let ye = 0, Ee = V.length; ye < Ee; ye++) {
							let ie = V[ye];
							te = de[ye];
							for (let q = 0, Me = ie.length; q < Me; q++) {
								let Pe = K(ie[q], te[q], he);
								x ? A(Pe.x, Pe.y + v[u - 1].y, v[u - 1].x + Q) : A(Pe.x, Pe.y, h + Q)
							}
						}
					}
					P(), b();

					function P() {
						let N = i.length / 3;
						if (f) {
							let pe = 0,
								Q = Z * pe;
							for (let he = 0; he < Y; he++) {
								let ye = F[he];
								G(ye[2] + Q, ye[1] + Q, ye[0] + Q)
							}
							pe = u + d * 2, Q = Z * pe;
							for (let he = 0; he < Y; he++) {
								let ye = F[he];
								G(ye[0] + Q, ye[1] + Q, ye[2] + Q)
							}
						} else {
							for (let pe = 0; pe < Y; pe++) {
								let Q = F[pe];
								G(Q[2], Q[1], Q[0])
							}
							for (let pe = 0; pe < Y; pe++) {
								let Q = F[pe];
								G(Q[0] + Z * u, Q[1] + Z * u, Q[2] + Z * u)
							}
						}
						n.addGroup(N, i.length / 3 - N, 0)
					}

					function b() {
						let N = i.length / 3,
							pe = 0;
						S(U, pe), pe += U.length;
						for (let Q = 0, he = V.length; Q < he; Q++) {
							let ye = V[Q];
							S(ye, pe), pe += ye.length
						}
						n.addGroup(N, i.length / 3 - N, 1)
					}

					function S(N, pe) {
						let Q = N.length;
						for (; --Q >= 0;) {
							let he = Q,
								ye = Q - 1;
							ye < 0 && (ye = N.length - 1);
							for (let Ee = 0, ie = u + d * 2; Ee < ie; Ee++) {
								let q = Z * Ee,
									Me = Z * (Ee + 1),
									Pe = pe + he + q,
									Ke = pe + ye + q,
									R = pe + ye + Me,
									E = pe + he + Me;
								J(Pe, Ke, R, E)
							}
						}
					}

					function A(N, pe, Q) {
						l.push(N), l.push(pe), l.push(Q)
					}

					function G(N, pe, Q) {
						$(N), $(pe), $(Q);
						let he = i.length / 3,
							ye = _.generateTopUV(n, i, he - 3, he - 2, he - 1);
						le(ye[0]), le(ye[1]), le(ye[2])
					}

					function J(N, pe, Q, he) {
						$(N), $(pe), $(he), $(pe), $(Q), $(he);
						let ye = i.length / 3,
							Ee = _.generateSideWallUV(n, i, ye - 6, ye - 3, ye - 2, ye - 1);
						le(Ee[0]), le(Ee[1]), le(Ee[3]), le(Ee[1]), le(Ee[2]), le(Ee[3])
					}

					function $(N) {
						i.push(l[N * 3 + 0]), i.push(l[N * 3 + 1]), i.push(l[N * 3 + 2])
					}

					function le(N) {
						s.push(N.x), s.push(N.y)
					}
				}
			}
			copy(e) {
				return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
			}
			toJSON() {
				let e = super.toJSON(),
					t = this.parameters.shapes,
					n = this.parameters.options;
				return PM(t, n, e)
			}
			static fromJSON(e, t) {
				let n = [];
				for (let s = 0, o = e.shapes.length; s < o; s++) {
					let a = t[e.shapes[s]];
					n.push(a)
				}
				let i = e.options.extrudePath;
				return i !== void 0 && (e.options.extrudePath = new Ug[i.type]().fromJSON(i)), new r(n, e.options)
			}
		},
		IM = {
			generateTopUV: function(r, e, t, n, i) {
				let s = e[t * 3],
					o = e[t * 3 + 1],
					a = e[n * 3],
					l = e[n * 3 + 1],
					c = e[i * 3],
					u = e[i * 3 + 1];
				return [new Ce(s, o), new Ce(a, l), new Ce(c, u)]
			},
			generateSideWallUV: function(r, e, t, n, i, s) {
				let o = e[t * 3],
					a = e[t * 3 + 1],
					l = e[t * 3 + 2],
					c = e[n * 3],
					u = e[n * 3 + 1],
					h = e[n * 3 + 2],
					f = e[i * 3],
					m = e[i * 3 + 1],
					g = e[i * 3 + 2],
					y = e[s * 3],
					d = e[s * 3 + 1],
					p = e[s * 3 + 2];
				return Math.abs(a - u) < Math.abs(o - c) ? [new Ce(o, 1 - l), new Ce(c, 1 - h), new Ce(f, 1 - g), new Ce(y, 1 - p)] : [new Ce(a, 1 - l), new Ce(u, 1 - h), new Ce(m, 1 - g), new Ce(d, 1 - p)]
			}
		};

	function PM(r, e, t) {
		if (t.shapes = [], Array.isArray(r))
			for (let n = 0, i = r.length; n < i; n++) {
				let s = r[n];
				t.shapes.push(s.uuid)
			} else t.shapes.push(r.uuid);
		return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t
	}
	var ha = class r extends St {
		constructor(e = 1, t = 32, n = 16, i = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
			super(), this.type = "SphereGeometry", this.parameters = {
				radius: e,
				widthSegments: t,
				heightSegments: n,
				phiStart: i,
				phiLength: s,
				thetaStart: o,
				thetaLength: a
			}, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
			let l = Math.min(o + a, Math.PI),
				c = 0,
				u = [],
				h = new re,
				f = new re,
				m = [],
				g = [],
				y = [],
				d = [];
			for (let p = 0; p <= n; p++) {
				let _ = [],
					v = p / n,
					x = 0;
				p === 0 && o === 0 ? x = .5 / t : p === n && l === Math.PI && (x = -.5 / t);
				for (let M = 0; M <= t; M++) {
					let I = M / t;
					h.x = -e * Math.cos(i + I * s) * Math.sin(o + v * a), h.y = e * Math.cos(o + v * a), h.z = e * Math.sin(i + I * s) * Math.sin(o + v * a), g.push(h.x, h.y, h.z), f.copy(h).normalize(), y.push(f.x, f.y, f.z), d.push(I + x, 1 - v), _.push(c++)
				}
				u.push(_)
			}
			for (let p = 0; p < n; p++)
				for (let _ = 0; _ < t; _++) {
					let v = u[p][_ + 1],
						x = u[p][_],
						M = u[p + 1][_],
						I = u[p + 1][_ + 1];
					(p !== 0 || o > 0) && m.push(v, x, I), (p !== n - 1 || l < Math.PI) && m.push(x, M, I)
				}
			this.setIndex(m), this.setAttribute("position", new ze(g, 3)), this.setAttribute("normal", new ze(y, 3)), this.setAttribute("uv", new ze(d, 2))
		}
		copy(e) {
			return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
		}
		static fromJSON(e) {
			return new r(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
		}
	};
	var cs = class extends Vi {
		constructor(e) {
			super(), this.isMeshStandardMaterial = !0, this.defines = {
				STANDARD: ""
			}, this.type = "MeshStandardMaterial", this.color = new qe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gu, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
		}
		copy(e) {
			return super.copy(e), this.defines = {
				STANDARD: ""
			}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
		}
	};
	var Xt = class extends Vi {
		constructor(e) {
			super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new qe(16777215), this.specular = new qe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gu, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ku, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
		}
	};
	var fa = class extends Vi {
		constructor(e) {
			super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gu, this.normalScale = new Ce(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ku, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
		}
	};

	function ts(r, e, t) {
		return Vg(r) ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length)) : r.slice(e, t)
	}

	function pu(r, e, t) {
		return !r || !t && r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
	}

	function Vg(r) {
		return ArrayBuffer.isView(r) && !(r instanceof DataView)
	}

	function LM(r) {
		function e(i, s) {
			return r[i] - r[s]
		}
		let t = r.length,
			n = new Array(t);
		for (let i = 0; i !== t; ++i) n[i] = i;
		return n.sort(e), n
	}

	function ug(r, e, t) {
		let n = r.length,
			i = new r.constructor(n);
		for (let s = 0, o = 0; o !== n; ++s) {
			let a = t[s] * e;
			for (let l = 0; l !== e; ++l) i[o++] = r[a + l]
		}
		return i
	}

	function zg(r, e, t, n) {
		let i = 1,
			s = r[0];
		for (; s !== void 0 && s[n] === void 0;) s = r[i++];
		if (s === void 0) return;
		let o = s[n];
		if (o !== void 0)
			if (Array.isArray(o))
				do o = s[n], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = r[i++]; while (s !== void 0);
			else if (o.toArray !== void 0)
			do o = s[n], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = r[i++]; while (s !== void 0);
		else
			do o = s[n], o !== void 0 && (e.push(s.time), t.push(o)), s = r[i++]; while (s !== void 0)
	}
	var da = class {
			constructor(e, t, n, i) {
				this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
			}
			evaluate(e) {
				let t = this.parameterPositions,
					n = this._cachedIndex,
					i = t[n],
					s = t[n - 1];
				e: {
					t: {
						let o;n: {
							i: if (!(e < i)) {
								for (let a = n + 2;;) {
									if (i === void 0) {
										if (e < s) break i;
										return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
									}
									if (n === a) break;
									if (s = i, i = t[++n], e < i) break t
								}
								o = t.length;
								break n
							}if (!(e >= s)) {
								let a = t[1];
								e < a && (n = 2, s = a);
								for (let l = n - 2;;) {
									if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
									if (n === l) break;
									if (i = s, s = t[--n - 1], e >= s) break t
								}
								o = n, n = 0;
								break n
							}
							break e
						}
						for (; n < o;) {
							let a = n + o >>> 1;
							e < t[a] ? o = a : n = a + 1
						}
						if (i = t[n], s = t[n - 1], s === void 0) return this._cachedIndex = 0,
						this.copySampleValue_(0);
						if (i === void 0) return n = t.length,
						this._cachedIndex = n,
						this.copySampleValue_(n - 1)
					}
					this._cachedIndex = n,
					this.intervalChanged_(n, s, i)
				}
				return this.interpolate_(n, s, e, i)
			}
			getSettings_() {
				return this.settings || this.DefaultSettings_
			}
			copySampleValue_(e) {
				let t = this.resultBuffer,
					n = this.sampleValues,
					i = this.valueSize,
					s = e * i;
				for (let o = 0; o !== i; ++o) t[o] = n[s + o];
				return t
			}
			interpolate_() {
				throw new Error("call to abstract method")
			}
			intervalChanged_() {}
		},
		Gf = class extends da {
			constructor(e, t, n, i) {
				super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
					endingStart: sm,
					endingEnd: sm
				}
			}
			intervalChanged_(e, t, n) {
				let i = this.parameterPositions,
					s = e - 2,
					o = e + 1,
					a = i[s],
					l = i[o];
				if (a === void 0) switch (this.getSettings_().endingStart) {
					case om:
						s = e, a = 2 * t - n;
						break;
					case am:
						s = i.length - 2, a = t + i[s] - i[s + 1];
						break;
					default:
						s = e, a = n
				}
				if (l === void 0) switch (this.getSettings_().endingEnd) {
					case om:
						o = e, l = 2 * n - t;
						break;
					case am:
						o = 1, l = n + i[1] - i[0];
						break;
					default:
						o = e - 1, l = t
				}
				let c = (n - t) * .5,
					u = this.valueSize;
				this._weightPrev = c / (t - a), this._weightNext = c / (l - n), this._offsetPrev = s * u, this._offsetNext = o * u
			}
			interpolate_(e, t, n, i) {
				let s = this.resultBuffer,
					o = this.sampleValues,
					a = this.valueSize,
					l = e * a,
					c = l - a,
					u = this._offsetPrev,
					h = this._offsetNext,
					f = this._weightPrev,
					m = this._weightNext,
					g = (n - t) / (i - t),
					y = g * g,
					d = y * g,
					p = -f * d + 2 * f * y - f * g,
					_ = (1 + f) * d + (-1.5 - 2 * f) * y + (-.5 + f) * g + 1,
					v = (-1 - m) * d + (1.5 + m) * y + .5 * g,
					x = m * d - m * y;
				for (let M = 0; M !== a; ++M) s[M] = p * o[u + M] + _ * o[c + M] + v * o[l + M] + x * o[h + M];
				return s
			}
		},
		Vf = class extends da {
			constructor(e, t, n, i) {
				super(e, t, n, i)
			}
			interpolate_(e, t, n, i) {
				let s = this.resultBuffer,
					o = this.sampleValues,
					a = this.valueSize,
					l = e * a,
					c = l - a,
					u = (n - t) / (i - t),
					h = 1 - u;
				for (let f = 0; f !== a; ++f) s[f] = o[c + f] * h + o[l + f] * u;
				return s
			}
		},
		zf = class extends da {
			constructor(e, t, n, i) {
				super(e, t, n, i)
			}
			interpolate_(e) {
				return this.copySampleValue_(e - 1)
			}
		},
		Mi = class {
			constructor(e, t, n, i) {
				if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
				if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
				this.name = e, this.times = pu(t, this.TimeBufferType), this.values = pu(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
			}
			static toJSON(e) {
				let t = e.constructor,
					n;
				if (t.toJSON !== this.toJSON) n = t.toJSON(e);
				else {
					n = {
						name: e.name,
						times: pu(e.times, Array),
						values: pu(e.values, Array)
					};
					let i = e.getInterpolation();
					i !== e.DefaultInterpolation && (n.interpolation = i)
				}
				return n.type = e.ValueTypeName, n
			}
			InterpolantFactoryMethodDiscrete(e) {
				return new zf(this.times, this.values, this.getValueSize(), e)
			}
			InterpolantFactoryMethodLinear(e) {
				return new Vf(this.times, this.values, this.getValueSize(), e)
			}
			InterpolantFactoryMethodSmooth(e) {
				return new Gf(this.times, this.values, this.getValueSize(), e)
			}
			setInterpolation(e) {
				let t;
				switch (e) {
					case mu:
						t = this.InterpolantFactoryMethodDiscrete;
						break;
					case gu:
						t = this.InterpolantFactoryMethodLinear;
						break;
					case Oh:
						t = this.InterpolantFactoryMethodSmooth;
						break
				}
				if (t === void 0) {
					let n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
					if (this.createInterpolant === void 0)
						if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
						else throw new Error(n);
					return console.warn("THREE.KeyframeTrack:", n), this
				}
				return this.createInterpolant = t, this
			}
			getInterpolation() {
				switch (this.createInterpolant) {
					case this.InterpolantFactoryMethodDiscrete:
						return mu;
					case this.InterpolantFactoryMethodLinear:
						return gu;
					case this.InterpolantFactoryMethodSmooth:
						return Oh
				}
			}
			getValueSize() {
				return this.values.length / this.times.length
			}
			shift(e) {
				if (e !== 0) {
					let t = this.times;
					for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
				}
				return this
			}
			scale(e) {
				if (e !== 1) {
					let t = this.times;
					for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
				}
				return this
			}
			trim(e, t) {
				let n = this.times,
					i = n.length,
					s = 0,
					o = i - 1;
				for (; s !== i && n[s] < e;) ++s;
				for (; o !== -1 && n[o] > t;) --o;
				if (++o, s !== 0 || o !== i) {
					s >= o && (o = Math.max(o, 1), s = o - 1);
					let a = this.getValueSize();
					this.times = ts(n, s, o), this.values = ts(this.values, s * a, o * a)
				}
				return this
			}
			validate() {
				let e = !0,
					t = this.getValueSize();
				t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
				let n = this.times,
					i = this.values,
					s = n.length;
				s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
				let o = null;
				for (let a = 0; a !== s; a++) {
					let l = n[a];
					if (typeof l == "number" && isNaN(l)) {
						console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
						break
					}
					if (o !== null && o > l) {
						console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
						break
					}
					o = l
				}
				if (i !== void 0 && Vg(i))
					for (let a = 0, l = i.length; a !== l; ++a) {
						let c = i[a];
						if (isNaN(c)) {
							console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
							break
						}
					}
				return e
			}
			optimize() {
				let e = ts(this.times),
					t = ts(this.values),
					n = this.getValueSize(),
					i = this.getInterpolation() === Oh,
					s = e.length - 1,
					o = 1;
				for (let a = 1; a < s; ++a) {
					let l = !1,
						c = e[a],
						u = e[a + 1];
					if (c !== u && (a !== 1 || c !== e[0]))
						if (i) l = !0;
						else {
							let h = a * n,
								f = h - n,
								m = h + n;
							for (let g = 0; g !== n; ++g) {
								let y = t[h + g];
								if (y !== t[f + g] || y !== t[m + g]) {
									l = !0;
									break
								}
							}
						} if (l) {
						if (a !== o) {
							e[o] = e[a];
							let h = a * n,
								f = o * n;
							for (let m = 0; m !== n; ++m) t[f + m] = t[h + m]
						}++o
					}
				}
				if (s > 0) {
					e[o] = e[s];
					for (let a = s * n, l = o * n, c = 0; c !== n; ++c) t[l + c] = t[a + c];
					++o
				}
				return o !== e.length ? (this.times = ts(e, 0, o), this.values = ts(t, 0, o * n)) : (this.times = e, this.values = t), this
			}
			clone() {
				let e = ts(this.times, 0),
					t = ts(this.values, 0),
					n = this.constructor,
					i = new n(this.name, e, t);
				return i.createInterpolant = this.createInterpolant, i
			}
		};
	Mi.prototype.TimeBufferType = Float32Array;
	Mi.prototype.ValueBufferType = Float32Array;
	Mi.prototype.DefaultInterpolation = gu;
	var us = class extends Mi {};
	us.prototype.ValueTypeName = "bool";
	us.prototype.ValueBufferType = Array;
	us.prototype.DefaultInterpolation = mu;
	us.prototype.InterpolantFactoryMethodLinear = void 0;
	us.prototype.InterpolantFactoryMethodSmooth = void 0;
	var Pu = class extends Mi {};
	Pu.prototype.ValueTypeName = "color";
	var hs = class extends Mi {};
	hs.prototype.ValueTypeName = "number";
	var Hf = class extends da {
			constructor(e, t, n, i) {
				super(e, t, n, i)
			}
			interpolate_(e, t, n, i) {
				let s = this.resultBuffer,
					o = this.sampleValues,
					a = this.valueSize,
					l = (n - t) / (i - t),
					c = e * a;
				for (let u = c + a; c !== u; c += 4) yn.slerpFlat(s, 0, o, c - a, o, c, l);
				return s
			}
		},
		zi = class extends Mi {
			InterpolantFactoryMethodLinear(e) {
				return new Hf(this.times, this.values, this.getValueSize(), e)
			}
		};
	zi.prototype.ValueTypeName = "quaternion";
	zi.prototype.DefaultInterpolation = gu;
	zi.prototype.InterpolantFactoryMethodSmooth = void 0;
	var fs = class extends Mi {};
	fs.prototype.ValueTypeName = "string";
	fs.prototype.ValueBufferType = Array;
	fs.prototype.DefaultInterpolation = mu;
	fs.prototype.InterpolantFactoryMethodLinear = void 0;
	fs.prototype.InterpolantFactoryMethodSmooth = void 0;
	var Hi = class extends Mi {};
	Hi.prototype.ValueTypeName = "vector";
	var Ks = class {
		constructor(e, t = -1, n, i = Gy) {
			this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Gr(), this.duration < 0 && this.resetDuration()
		}
		static parse(e) {
			let t = [],
				n = e.tracks,
				i = 1 / (e.fps || 1);
			for (let o = 0, a = n.length; o !== a; ++o) t.push(OM(n[o]).scale(i));
			let s = new this(e.name, e.duration, t, e.blendMode);
			return s.uuid = e.uuid, s
		}
		static toJSON(e) {
			let t = [],
				n = e.tracks,
				i = {
					name: e.name,
					duration: e.duration,
					tracks: t,
					uuid: e.uuid,
					blendMode: e.blendMode
				};
			for (let s = 0, o = n.length; s !== o; ++s) t.push(Mi.toJSON(n[s]));
			return i
		}
		static CreateFromMorphTargetSequence(e, t, n, i) {
			let s = t.length,
				o = [];
			for (let a = 0; a < s; a++) {
				let l = [],
					c = [];
				l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
				let u = LM(l);
				l = ug(l, 1, u), c = ug(c, 1, u), !i && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(new hs(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / n))
			}
			return new this(e, -1, o)
		}
		static findByName(e, t) {
			let n = e;
			if (!Array.isArray(e)) {
				let i = e;
				n = i.geometry && i.geometry.animations || i.animations
			}
			for (let i = 0; i < n.length; i++)
				if (n[i].name === t) return n[i];
			return null
		}
		static CreateClipsFromMorphTargetSequences(e, t, n) {
			let i = {},
				s = /^([\w-]*?)([\d]+)$/;
			for (let a = 0, l = e.length; a < l; a++) {
				let c = e[a],
					u = c.name.match(s);
				if (u && u.length > 1) {
					let h = u[1],
						f = i[h];
					f || (i[h] = f = []), f.push(c)
				}
			}
			let o = [];
			for (let a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
			return o
		}
		static parseAnimation(e, t) {
			if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
			let n = function(h, f, m, g, y) {
					if (m.length !== 0) {
						let d = [],
							p = [];
						zg(m, d, p, g), d.length !== 0 && y.push(new h(f, d, p))
					}
				},
				i = [],
				s = e.name || "default",
				o = e.fps || 30,
				a = e.blendMode,
				l = e.length || -1,
				c = e.hierarchy || [];
			for (let h = 0; h < c.length; h++) {
				let f = c[h].keys;
				if (!(!f || f.length === 0))
					if (f[0].morphTargets) {
						let m = {},
							g;
						for (g = 0; g < f.length; g++)
							if (f[g].morphTargets)
								for (let y = 0; y < f[g].morphTargets.length; y++) m[f[g].morphTargets[y]] = -1;
						for (let y in m) {
							let d = [],
								p = [];
							for (let _ = 0; _ !== f[g].morphTargets.length; ++_) {
								let v = f[g];
								d.push(v.time), p.push(v.morphTarget === y ? 1 : 0)
							}
							i.push(new hs(".morphTargetInfluence[" + y + "]", d, p))
						}
						l = m.length * o
					} else {
						let m = ".bones[" + t[h].name + "]";
						n(Hi, m + ".position", f, "pos", i), n(zi, m + ".quaternion", f, "rot", i), n(Hi, m + ".scale", f, "scl", i)
					}
			}
			return i.length === 0 ? null : new this(s, l, i, a)
		}
		resetDuration() {
			let e = this.tracks,
				t = 0;
			for (let n = 0, i = e.length; n !== i; ++n) {
				let s = this.tracks[n];
				t = Math.max(t, s.times[s.times.length - 1])
			}
			return this.duration = t, this
		}
		trim() {
			for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
			return this
		}
		validate() {
			let e = !0;
			for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
			return e
		}
		optimize() {
			for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
			return this
		}
		clone() {
			let e = [];
			for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
			return new this.constructor(this.name, this.duration, e, this.blendMode)
		}
		toJSON() {
			return this.constructor.toJSON(this)
		}
	};

	function NM(r) {
		switch (r.toLowerCase()) {
			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":
				return hs;
			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":
				return Hi;
			case "color":
				return Pu;
			case "quaternion":
				return zi;
			case "bool":
			case "boolean":
				return us;
			case "string":
				return fs
		}
		throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
	}

	function OM(r) {
		if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
		let e = NM(r.type);
		if (r.times === void 0) {
			let t = [],
				n = [];
			zg(r.keys, t, n, "value"), r.times = t, r.values = n
		}
		return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation)
	}
	var Lu = {
			enabled: !1,
			files: {},
			add: function(r, e) {
				this.enabled !== !1 && (this.files[r] = e)
			},
			get: function(r) {
				if (this.enabled !== !1) return this.files[r]
			},
			remove: function(r) {
				delete this.files[r]
			},
			clear: function() {
				this.files = {}
			}
		},
		Bl = class {
			constructor(e, t, n) {
				let i = this,
					s = !1,
					o = 0,
					a = 0,
					l, c = [];
				this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(u) {
					a++, s === !1 && i.onStart !== void 0 && i.onStart(u, o, a), s = !0
				}, this.itemEnd = function(u) {
					o++, i.onProgress !== void 0 && i.onProgress(u, o, a), o === a && (s = !1, i.onLoad !== void 0 && i.onLoad())
				}, this.itemError = function(u) {
					i.onError !== void 0 && i.onError(u)
				}, this.resolveURL = function(u) {
					return l ? l(u) : u
				}, this.setURLModifier = function(u) {
					return l = u, this
				}, this.addHandler = function(u, h) {
					return c.push(u, h), this
				}, this.removeHandler = function(u) {
					let h = c.indexOf(u);
					return h !== -1 && c.splice(h, 2), this
				}, this.getHandler = function(u) {
					for (let h = 0, f = c.length; h < f; h += 2) {
						let m = c[h],
							g = c[h + 1];
						if (m.global && (m.lastIndex = 0), m.test(u)) return g
					}
					return null
				}
			}
		},
		DM = new Bl,
		Ot = class {
			constructor(e) {
				this.manager = e !== void 0 ? e : DM, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
			}
			load() {}
			loadAsync(e, t) {
				let n = this;
				return new Promise(function(i, s) {
					n.load(e, i, t, s)
				})
			}
			parse() {}
			setCrossOrigin(e) {
				return this.crossOrigin = e, this
			}
			setWithCredentials(e) {
				return this.withCredentials = e, this
			}
			setPath(e) {
				return this.path = e, this
			}
			setResourcePath(e) {
				return this.resourcePath = e, this
			}
			setRequestHeader(e) {
				return this.requestHeader = e, this
			}
		};
	Ot.DEFAULT_MATERIAL_NAME = "__DEFAULT";
	var Pr = {},
		Wf = class extends Error {
			constructor(e, t) {
				super(e), this.response = t
			}
		},
		jn = class extends Ot {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
				let s = Lu.get(e);
				if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
					t && t(s), this.manager.itemEnd(e)
				}, 0), s;
				if (Pr[e] !== void 0) {
					Pr[e].push({
						onLoad: t,
						onProgress: n,
						onError: i
					});
					return
				}
				Pr[e] = [], Pr[e].push({
					onLoad: t,
					onProgress: n,
					onError: i
				});
				let o = new Request(e, {
						headers: new Headers(this.requestHeader),
						credentials: this.withCredentials ? "include" : "same-origin"
					}),
					a = this.mimeType,
					l = this.responseType;
				fetch(o).then(c => {
					if (c.status === 200 || c.status === 0) {
						if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
						let u = Pr[e],
							h = c.body.getReader(),
							f = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
							m = f ? parseInt(f) : 0,
							g = m !== 0,
							y = 0,
							d = new ReadableStream({
								start(p) {
									_();

									function _() {
										h.read().then(({
											done: v,
											value: x
										}) => {
											if (v) p.close();
											else {
												y += x.byteLength;
												let M = new ProgressEvent("progress", {
													lengthComputable: g,
													loaded: y,
													total: m
												});
												for (let I = 0, w = u.length; I < w; I++) {
													let L = u[I];
													L.onProgress && L.onProgress(M)
												}
												p.enqueue(x), _()
											}
										})
									}
								}
							});
						return new Response(d)
					} else throw new Wf(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
				}).then(c => {
					switch (l) {
						case "arraybuffer":
							return c.arrayBuffer();
						case "blob":
							return c.blob();
						case "document":
							return c.text().then(u => new DOMParser().parseFromString(u, a));
						case "json":
							return c.json();
						default:
							if (a === void 0) return c.text();
							{
								let h = /charset="?([^;"\s]*)"?/i.exec(a),
									f = h && h[1] ? h[1].toLowerCase() : void 0,
									m = new TextDecoder(f);
								return c.arrayBuffer().then(g => m.decode(g))
							}
					}
				}).then(c => {
					Lu.add(e, c);
					let u = Pr[e];
					delete Pr[e];
					for (let h = 0, f = u.length; h < f; h++) {
						let m = u[h];
						m.onLoad && m.onLoad(c)
					}
				}).catch(c => {
					let u = Pr[e];
					if (u === void 0) throw this.manager.itemError(e), c;
					delete Pr[e];
					for (let h = 0, f = u.length; h < f; h++) {
						let m = u[h];
						m.onError && m.onError(c)
					}
					this.manager.itemError(e)
				}).finally(() => {
					this.manager.itemEnd(e)
				}), this.manager.itemStart(e)
			}
			setResponseType(e) {
				return this.responseType = e, this
			}
			setMimeType(e) {
				return this.mimeType = e, this
			}
		};
	var Nu = class extends Ot {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
				let s = this,
					o = Lu.get(e);
				if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
					t && t(o), s.manager.itemEnd(e)
				}, 0), o;
				let a = wl("img");

				function l() {
					u(), Lu.add(e, this), t && t(this), s.manager.itemEnd(e)
				}

				function c(h) {
					u(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e)
				}

				function u() {
					a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1)
				}
				return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
			}
		},
		Ou = class extends Ot {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = new Rl;
				s.colorSpace = ot;
				let o = new Nu(this.manager);
				o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
				let a = 0;

				function l(c) {
					o.load(e[c], function(u) {
						s.images[c] = u, a++, a === 6 && (s.needsUpdate = !0, t && t(s))
					}, void 0, i)
				}
				for (let c = 0; c < e.length; ++c) l(c);
				return s
			}
		},
		Du = class extends Ot {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = this,
					o = new ca,
					a = new jn(this.manager);
				return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
					let c = s.parse(l);
					c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : Wt, o.wrapT = c.wrapT !== void 0 ? c.wrapT : Wt, o.magFilter = c.magFilter !== void 0 ? c.magFilter : mn, o.minFilter = c.minFilter !== void 0 ? c.minFilter : mn, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 ? o.colorSpace = c.colorSpace : c.encoding !== void 0 && (o.encoding = c.encoding), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = ki), c.mipmapCount === 1 && (o.minFilter = mn), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c))
				}, n, i), o
			}
		},
		bi = class extends Ot {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = new Gn,
					o = new Nu(this.manager);
				return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
					s.image = a, s.needsUpdate = !0, t !== void 0 && t(s)
				}, n, i), s
			}
		},
		pa = class extends Rt {
			constructor(e, t = 1) {
				super(), this.isLight = !0, this.type = "Light", this.color = new qe(e), this.intensity = t
			}
			dispose() {}
			copy(e, t) {
				return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
			}
			toJSON(e) {
				let t = super.toJSON(e);
				return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t
			}
		};
	var uf = new Je,
		hg = new re,
		fg = new re,
		Gl = class {
			constructor(e) {
				this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ce(512, 512), this.map = null, this.mapPass = null, this.matrix = new Je, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Il, this._frameExtents = new Ce(1, 1), this._viewportCount = 1, this._viewports = [new Ct(0, 0, 1, 1)]
			}
			getViewportCount() {
				return this._viewportCount
			}
			getFrustum() {
				return this._frustum
			}
			updateMatrices(e) {
				let t = this.camera,
					n = this.matrix;
				hg.setFromMatrixPosition(e.matrixWorld), t.position.copy(hg), fg.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(fg), t.updateMatrixWorld(), uf.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(uf), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(uf)
			}
			getViewport(e) {
				return this._viewports[e]
			}
			getFrameExtents() {
				return this._frameExtents
			}
			dispose() {
				this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
			}
			copy(e) {
				return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
			}
			clone() {
				return new this.constructor().copy(this)
			}
			toJSON() {
				let e = {};
				return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
			}
		},
		Xf = class extends Gl {
			constructor() {
				super(new Yt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
			}
			updateMatrices(e) {
				let t = this.camera,
					n = sa * 2 * e.angle * this.focus,
					i = this.mapSize.width / this.mapSize.height,
					s = e.distance || t.far;
				(n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
			}
			copy(e) {
				return super.copy(e), this.focus = e.focus, this
			}
		},
		ma = class extends pa {
			constructor(e, t, n = 0, i = Math.PI / 3, s = 0, o = 2) {
				super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Rt.DEFAULT_UP), this.updateMatrix(), this.target = new Rt, this.distance = n, this.angle = i, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new Xf
			}
			get power() {
				return this.intensity * Math.PI
			}
			set power(e) {
				this.intensity = e / Math.PI
			}
			dispose() {
				this.shadow.dispose()
			}
			copy(e, t) {
				return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
			}
		},
		dg = new Je,
		yl = new re,
		hf = new re,
		qf = class extends Gl {
			constructor() {
				super(new Yt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ce(4, 2), this._viewportCount = 6, this._viewports = [new Ct(2, 1, 1, 1), new Ct(0, 1, 1, 1), new Ct(3, 1, 1, 1), new Ct(1, 1, 1, 1), new Ct(3, 0, 1, 1), new Ct(1, 0, 1, 1)], this._cubeDirections = [new re(1, 0, 0), new re(-1, 0, 0), new re(0, 0, 1), new re(0, 0, -1), new re(0, 1, 0), new re(0, -1, 0)], this._cubeUps = [new re(0, 1, 0), new re(0, 1, 0), new re(0, 1, 0), new re(0, 1, 0), new re(0, 0, 1), new re(0, 0, -1)]
			}
			updateMatrices(e, t = 0) {
				let n = this.camera,
					i = this.matrix,
					s = e.distance || n.far;
				s !== n.far && (n.far = s, n.updateProjectionMatrix()), yl.setFromMatrixPosition(e.matrixWorld), n.position.copy(yl), hf.copy(n.position), hf.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(hf), n.updateMatrixWorld(), i.makeTranslation(-yl.x, -yl.y, -yl.z), dg.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(dg)
			}
		},
		Zs = class extends pa {
			constructor(e, t, n = 0, i = 2) {
				super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new qf
			}
			get power() {
				return this.intensity * 4 * Math.PI
			}
			set power(e) {
				this.intensity = e / (4 * Math.PI)
			}
			dispose() {
				this.shadow.dispose()
			}
			copy(e, t) {
				return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
			}
		},
		jf = class extends Gl {
			constructor() {
				super(new cr(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
			}
		},
		hr = class extends pa {
			constructor(e, t) {
				super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Rt.DEFAULT_UP), this.updateMatrix(), this.target = new Rt, this.shadow = new jf
			}
			dispose() {
				this.shadow.dispose()
			}
			copy(e) {
				return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
			}
		},
		fr = class extends pa {
			constructor(e, t) {
				super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
			}
		};
	var ds = class {
		static decodeText(e) {
			if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
			let t = "";
			for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
			try {
				return decodeURIComponent(escape(t))
			} catch {
				return t
			}
		}
		static extractUrlBase(e) {
			let t = e.lastIndexOf("/");
			return t === -1 ? "./" : e.slice(0, t + 1)
		}
		static resolveURL(e, t) {
			return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
		}
	};
	var td = "\\[\\]\\.:\\/",
		FM = new RegExp("[" + td + "]", "g"),
		nd = "[^" + td + "]",
		UM = "[^" + td.replace("\\.", "") + "]",
		kM = /((?:WC+[\/:])*)/.source.replace("WC", nd),
		BM = /(WCOD+)?/.source.replace("WCOD", UM),
		GM = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", nd),
		VM = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", nd),
		zM = new RegExp("^" + kM + BM + GM + VM + "$"),
		HM = ["material", "materials", "bones", "map"],
		Yf = class {
			constructor(e, t, n) {
				let i = n || Gt.parseTrackName(t);
				this._targetGroup = e, this._bindings = e.subscribe_(t, i)
			}
			getValue(e, t) {
				this.bind();
				let n = this._targetGroup.nCachedObjects_,
					i = this._bindings[n];
				i !== void 0 && i.getValue(e, t)
			}
			setValue(e, t) {
				let n = this._bindings;
				for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(e, t)
			}
			bind() {
				let e = this._bindings;
				for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
			}
			unbind() {
				let e = this._bindings;
				for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
			}
		},
		Gt = class r {
			constructor(e, t, n) {
				this.path = t, this.parsedPath = n || r.parseTrackName(t), this.node = r.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
			}
			static create(e, t, n) {
				return e && e.isAnimationObjectGroup ? new r.Composite(e, t, n) : new r(e, t, n)
			}
			static sanitizeNodeName(e) {
				return e.replace(/\s/g, "_").replace(FM, "")
			}
			static parseTrackName(e) {
				let t = zM.exec(e);
				if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
				let n = {
						nodeName: t[2],
						objectName: t[3],
						objectIndex: t[4],
						propertyName: t[5],
						propertyIndex: t[6]
					},
					i = n.nodeName && n.nodeName.lastIndexOf(".");
				if (i !== void 0 && i !== -1) {
					let s = n.nodeName.substring(i + 1);
					HM.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s)
				}
				if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
				return n
			}
			static findNode(e, t) {
				if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
				if (e.skeleton) {
					let n = e.skeleton.getBoneByName(t);
					if (n !== void 0) return n
				}
				if (e.children) {
					let n = function(s) {
							for (let o = 0; o < s.length; o++) {
								let a = s[o];
								if (a.name === t || a.uuid === t) return a;
								let l = n(a.children);
								if (l) return l
							}
							return null
						},
						i = n(e.children);
					if (i) return i
				}
				return null
			}
			_getValue_unavailable() {}
			_setValue_unavailable() {}
			_getValue_direct(e, t) {
				e[t] = this.targetObject[this.propertyName]
			}
			_getValue_array(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i]
			}
			_getValue_arrayElement(e, t) {
				e[t] = this.resolvedProperty[this.propertyIndex]
			}
			_getValue_toArray(e, t) {
				this.resolvedProperty.toArray(e, t)
			}
			_setValue_direct(e, t) {
				this.targetObject[this.propertyName] = e[t]
			}
			_setValue_direct_setNeedsUpdate(e, t) {
				this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
			}
			_setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
				this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_array(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++]
			}
			_setValue_array_setNeedsUpdate(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
				this.targetObject.needsUpdate = !0
			}
			_setValue_array_setMatrixWorldNeedsUpdate(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
				this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_arrayElement(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t]
			}
			_setValue_arrayElement_setNeedsUpdate(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
			}
			_setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_fromArray(e, t) {
				this.resolvedProperty.fromArray(e, t)
			}
			_setValue_fromArray_setNeedsUpdate(e, t) {
				this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
			}
			_setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
				this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_getValue_unbound(e, t) {
				this.bind(), this.getValue(e, t)
			}
			_setValue_unbound(e, t) {
				this.bind(), this.setValue(e, t)
			}
			bind() {
				let e = this.node,
					t = this.parsedPath,
					n = t.objectName,
					i = t.propertyName,
					s = t.propertyIndex;
				if (e || (e = r.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
					console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
					return
				}
				if (n) {
					let c = t.objectIndex;
					switch (n) {
						case "materials":
							if (!e.material) {
								console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								return
							}
							if (!e.material.materials) {
								console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
								return
							}
							e = e.material.materials;
							break;
						case "bones":
							if (!e.skeleton) {
								console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
								return
							}
							e = e.skeleton.bones;
							for (let u = 0; u < e.length; u++)
								if (e[u].name === c) {
									c = u;
									break
								} break;
						case "map":
							if ("map" in e) {
								e = e.map;
								break
							}
							if (!e.material) {
								console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								return
							}
							if (!e.material.map) {
								console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
								return
							}
							e = e.material.map;
							break;
						default:
							if (e[n] === void 0) {
								console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
								return
							}
							e = e[n]
					}
					if (c !== void 0) {
						if (e[c] === void 0) {
							console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
							return
						}
						e = e[c]
					}
				}
				let o = e[i];
				if (o === void 0) {
					let c = t.nodeName;
					console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
					return
				}
				let a = this.Versioning.None;
				this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
				let l = this.BindingType.Direct;
				if (s !== void 0) {
					if (i === "morphTargetInfluences") {
						if (!e.geometry) {
							console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
							return
						}
						if (!e.geometry.morphAttributes) {
							console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
							return
						}
						e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
					}
					l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
				} else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
				this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
			}
			unbind() {
				this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
			}
		};
	Gt.Composite = Yf;
	Gt.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	Gt.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	Gt.prototype.GetterByBindingType = [Gt.prototype._getValue_direct, Gt.prototype._getValue_array, Gt.prototype._getValue_arrayElement, Gt.prototype._getValue_toArray];
	Gt.prototype.SetterByBindingTypeAndVersioning = [
		[Gt.prototype._setValue_direct, Gt.prototype._setValue_direct_setNeedsUpdate, Gt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
		[Gt.prototype._setValue_array, Gt.prototype._setValue_array_setNeedsUpdate, Gt.prototype._setValue_array_setMatrixWorldNeedsUpdate],
		[Gt.prototype._setValue_arrayElement, Gt.prototype._setValue_arrayElement_setNeedsUpdate, Gt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
		[Gt.prototype._setValue_fromArray, Gt.prototype._setValue_fromArray_setNeedsUpdate, Gt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
	];
	var bw = new Float32Array(1);
	var Fu = class {
		constructor(e, t, n = 0, i = 1 / 0) {
			this.ray = new Ws(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Cl, this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			}
		}
		set(e, t) {
			this.ray.set(e, t)
		}
		setFromCamera(e, t) {
			t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
		}
		intersectObject(e, t = !0, n = []) {
			return Kf(e, this, n, t), n.sort(pg), n
		}
		intersectObjects(e, t = !0, n = []) {
			for (let i = 0, s = e.length; i < s; i++) Kf(e[i], this, n, t);
			return n.sort(pg), n
		}
	};

	function pg(r, e) {
		return r.distance - e.distance
	}

	function Kf(r, e, t, n) {
		if (r.layers.test(e.layers) && r.raycast(e, t), n === !0) {
			let i = r.children;
			for (let s = 0, o = i.length; s < o; s++) Kf(i[s], e, t, !0)
		}
	}
	var mg = new Ce,
		Uu = class {
			constructor(e = new Ce(1 / 0, 1 / 0), t = new Ce(-1 / 0, -1 / 0)) {
				this.isBox2 = !0, this.min = e, this.max = t
			}
			set(e, t) {
				return this.min.copy(e), this.max.copy(t), this
			}
			setFromPoints(e) {
				this.makeEmpty();
				for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
				return this
			}
			setFromCenterAndSize(e, t) {
				let n = mg.copy(t).multiplyScalar(.5);
				return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
			}
			clone() {
				return new this.constructor().copy(this)
			}
			copy(e) {
				return this.min.copy(e.min), this.max.copy(e.max), this
			}
			makeEmpty() {
				return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
			}
			isEmpty() {
				return this.max.x < this.min.x || this.max.y < this.min.y
			}
			getCenter(e) {
				return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
			}
			getSize(e) {
				return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
			}
			expandByPoint(e) {
				return this.min.min(e), this.max.max(e), this
			}
			expandByVector(e) {
				return this.min.sub(e), this.max.add(e), this
			}
			expandByScalar(e) {
				return this.min.addScalar(-e), this.max.addScalar(e), this
			}
			containsPoint(e) {
				return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
			}
			containsBox(e) {
				return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
			}
			getParameter(e, t) {
				return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
			}
			intersectsBox(e) {
				return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
			}
			clampPoint(e, t) {
				return t.copy(e).clamp(this.min, this.max)
			}
			distanceToPoint(e) {
				return this.clampPoint(e, mg).distanceTo(e)
			}
			intersect(e) {
				return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
			}
			union(e) {
				return this.min.min(e.min), this.max.max(e.max), this
			}
			translate(e) {
				return this.min.add(e), this.max.add(e), this
			}
			equals(e) {
				return e.min.equals(this.min) && e.max.equals(this.max)
			}
		};
	var dr = class {
		constructor() {
			this.type = "ShapePath", this.color = new qe, this.subPaths = [], this.currentPath = null
		}
		moveTo(e, t) {
			return this.currentPath = new Br, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
		}
		lineTo(e, t) {
			return this.currentPath.lineTo(e, t), this
		}
		quadraticCurveTo(e, t, n, i) {
			return this.currentPath.quadraticCurveTo(e, t, n, i), this
		}
		bezierCurveTo(e, t, n, i, s, o) {
			return this.currentPath.bezierCurveTo(e, t, n, i, s, o), this
		}
		splineThru(e) {
			return this.currentPath.splineThru(e), this
		}
		toShapes(e) {
			function t(p) {
				let _ = [];
				for (let v = 0, x = p.length; v < x; v++) {
					let M = p[v],
						I = new ss;
					I.curves = M.curves, _.push(I)
				}
				return _
			}

			function n(p, _) {
				let v = _.length,
					x = !1;
				for (let M = v - 1, I = 0; I < v; M = I++) {
					let w = _[M],
						L = _[I],
						T = L.x - w.x,
						C = L.y - w.y;
					if (Math.abs(C) > Number.EPSILON) {
						if (C < 0 && (w = _[I], T = -T, L = _[M], C = -C), p.y < w.y || p.y > L.y) continue;
						if (p.y === w.y) {
							if (p.x === w.x) return !0
						} else {
							let V = C * (p.x - w.x) - T * (p.y - w.y);
							if (V === 0) return !0;
							if (V < 0) continue;
							x = !x
						}
					} else {
						if (p.y !== w.y) continue;
						if (L.x <= p.x && p.x <= w.x || w.x <= p.x && p.x <= L.x) return !0
					}
				}
				return x
			}
			let i = lr.isClockWise,
				s = this.subPaths;
			if (s.length === 0) return [];
			let o, a, l, c = [];
			if (s.length === 1) return a = s[0], l = new ss, l.curves = a.curves, c.push(l), c;
			let u = !i(s[0].getPoints());
			u = e ? !u : u;
			let h = [],
				f = [],
				m = [],
				g = 0,
				y;
			f[g] = void 0, m[g] = [];
			for (let p = 0, _ = s.length; p < _; p++) a = s[p], y = a.getPoints(), o = i(y), o = e ? !o : o, o ? (!u && f[g] && g++, f[g] = {
				s: new ss,
				p: y
			}, f[g].s.curves = a.curves, u && g++, m[g] = []) : m[g].push({
				h: a,
				p: y[0]
			});
			if (!f[0]) return t(s);
			if (f.length > 1) {
				let p = !1,
					_ = 0;
				for (let v = 0, x = f.length; v < x; v++) h[v] = [];
				for (let v = 0, x = f.length; v < x; v++) {
					let M = m[v];
					for (let I = 0; I < M.length; I++) {
						let w = M[I],
							L = !0;
						for (let T = 0; T < f.length; T++) n(w.p, f[T].p) && (v !== T && _++, L ? (L = !1, h[T].push(w)) : p = !0);
						L && h[v].push(w)
					}
				}
				_ > 0 && p === !1 && (m = h)
			}
			let d;
			for (let p = 0, _ = f.length; p < _; p++) {
				l = f[p].s, c.push(l), d = m[p];
				for (let v = 0, x = d.length; v < x; v++) l.holes.push(d[v].h)
			}
			return c
		}
	};
	typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
		detail: {
			revision: Zf
		}
	}));
	typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Zf);

	function Hu() {
		let r = document.createElement("canvas");
		document.body.appendChild(r);
		let e = {
				canvas: r,
				antialias: !0
			},
			t = new qs(e);
		t.outputColorSpace = Bn, t.setClearColor("#ffffff", 1), t.setSize(10, 10);
		let n = new ur,
			i = new fr(8947848);
		n.add(i);
		let s = new hr(8947848);
		s.position.set(0, 0, 1), n.add(s);
		let o = new Yt(45, 1, .1, 1e3);
		o.position.set(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(new re(0, 0, 0)), n.add(o);
		let a = new Pl(1, 1),
			l = new Nt(a, new Xt({
				color: 13369344
			}));
		n.add(l), t.render(n, o);
		let c = t.getContext(),
			u = new Uint8Array(4);
		c.readPixels(5, 5, 1, 1, c.RGBA, c.UNSIGNED_BYTE, u), document.body.removeChild(r);
		let h = 50;
		return u[0] < h && u[1] < h && u[2] < h
	}
	var Vn = {
		Phong: 1,
		Physical: 2
	};

	function Wu(r) {
		let e = 0,
			t = 0;
		for (let n = 0; n < r.MaterialCount(); n++) {
			let i = r.GetMaterial(n);
			i.type === In.Phong ? e += 1 : i.type === In.Physical && (t += 1)
		}
		return e >= t ? Vn.Phong : Vn.Physical
	}
	var ya = class {
			Convert(e) {
				return null
			}
		},
		Js = class extends ya {
			Convert(e) {
				return new qe().copyLinearToSRGB(e)
			}
		},
		va = class extends ya {
			Convert(e) {
				return new qe().copySRGBToLinear(e)
			}
		};

	function Vl(r) {
		return ai(r.r, r.g, r.b)
	}

	function On(r) {
		return new qe(r.r / 255, r.g / 255, r.b / 255)
	}

	function Wi(r, e, t) {
		let n = new $t,
			i = r.attributes.position.array,
			s = r.attributes.position.itemSize || 3;
		for (let u = 0; u < i.length; u += s) {
			let h = i[u],
				f = i[u + 1],
				m = i[u + 2];
			n.AddVertex(new He(h, f, m))
		}
		let o = r.attributes.color !== void 0;
		if (o) {
			let u = r.attributes.color.array,
				h = r.attributes.color.itemSize || 3;
			for (let f = 0; f < u.length; f += h) {
				let m = new qe(u[f], u[f + 1], u[f + 2]);
				t !== null && (m = t.Convert(m)), n.AddVertexColor(Vl(m))
			}
		}
		let a = r.attributes.normal !== void 0;
		if (a) {
			let u = r.attributes.normal.array,
				h = r.attributes.normal.itemSize || 3;
			for (let f = 0; f < u.length; f += h) {
				let m = u[f],
					g = u[f + 1],
					y = u[f + 2];
				n.AddNormal(new He(m, g, y))
			}
		}
		let l = r.attributes.uv !== void 0;
		if (l) {
			let u = r.attributes.uv.array,
				h = r.attributes.uv.itemSize || 2;
			for (let f = 0; f < u.length; f += h) {
				let m = u[f],
					g = u[f + 1];
				n.AddTextureUV(new wt(m, g))
			}
		}
		let c = null;
		if (r.index !== null) c = r.index.array;
		else {
			c = [];
			for (let u = 0; u < i.length / 3; u++) c.push(u)
		}
		for (let u = 0; u < c.length; u += 3) {
			let h = c[u],
				f = c[u + 1],
				m = c[u + 2],
				g = new Ht(h, f, m);
			o && g.SetVertexColors(h, f, m), a && g.SetNormals(h, f, m), l && g.SetTextureUVs(h, f, m), e !== null && g.SetMaterial(e), n.AddTriangle(g)
		}
		return n
	}

	function Xu(r) {
		r !== null && r.traverse(e => {
			if (e.isMesh || e.isLineSegments) {
				if (Array.isArray(e.material))
					for (let t of e.material) t.dispose();
				else e.material.dispose();
				e.userData = null, e.geometry.dispose()
			}
		})
	}
	var id = class {
		constructor(e) {
			this.params = {
				getDefaultMaterialColor: () => new Et(0, 0, 0)
			}, oo(e, this.params), this.defaultMaterialIndex = null
		}
		Finalize(e) {
			this.Reset(), this.FinalizeMeshes(e), this.FinalizeMaterials(e), this.FinalizeNodes(e)
		}
		FinalizeMaterials(e) {
			if (e.VertexColorCount() === 0) return;
			let t = new Map;
			for (let n = 0; n < e.MeshCount(); n++) {
				let i = e.GetMesh(n);
				for (let s = 0; s < i.TriangleCount(); s++) {
					let o = i.GetTriangle(s),
						a = o.HasVertexColors();
					t.has(o.mat) ? a || t.set(o.mat, !1) : t.set(o.mat, a)
				}
			}
			for (let [n, i] of t) {
				let s = e.GetMaterial(n);
				s.vertexColors = i
			}
		}
		FinalizeMeshes(e) {
			for (let t = 0; t < e.MeshCount(); t++) {
				let n = e.GetMesh(t);
				if (Kr(n) === ir.Empty) {
					e.RemoveMesh(t), t = t - 1;
					continue
				}
				this.FinalizeMesh(e, n)
			}
		}
		FinalizeMesh(e, t) {
			function n(s) {
				function o(c, u, h, f, m) {
					function g(_, v) {
						for (let x = 0; x < _.length; x++) {
							let M = _[x];
							if (li(M, v)) return !0
						}
						return !1
					}
					let y = [],
						d = m.get(h);
					for (let _ = 0; _ < d.length; _++) {
						let v = d[_],
							x = c.GetTriangle(v);
						if (u.curve === x.curve) {
							let M = f[v];
							g(y, M) || y.push(M)
						}
					}
					let p = new He(0, 0, 0);
					for (let _ = 0; _ < y.length; _++) p = wc(p, y[_]);
					return p.MultiplyScalar(1 / y.length), p.Normalize(), c.AddNormal(p)
				}
				let a = [],
					l = new Map;
				for (let c = 0; c < s.VertexCount(); c++) l.set(c, []);
				for (let c = 0; c < s.TriangleCount(); c++) {
					let u = s.GetTriangle(c),
						h = s.GetVertex(u.v0),
						f = s.GetVertex(u.v1),
						m = s.GetVertex(u.v2),
						g = Cs(h, f, m);
					a.push(g), l.get(u.v0).push(c), l.get(u.v1).push(c), l.get(u.v2).push(c)
				}
				for (let c = 0; c < s.TriangleCount(); c++) {
					let u = s.GetTriangle(c);
					if (!u.HasNormals()) {
						let h = o(s, u, u.v0, a, l),
							f = o(s, u, u.v1, a, l),
							m = o(s, u, u.v2, a, l);
						u.SetNormals(h, f, m)
					}
				}
			}
			let i = {
				calculateCurveNormals: !1
			};
			for (let s = 0; s < t.TriangleCount(); s++) {
				let o = t.GetTriangle(s);
				this.FinalizeTriangle(t, o, i), o.mat === null && (o.mat = this.GetDefaultMaterialIndex(e))
			}
			i.calculateCurveNormals && n(t)
		}
		FinalizeTriangle(e, t, n) {
			if (!t.HasNormals())
				if (t.curve === null || t.curve === 0) {
					let i = e.GetVertex(t.v0),
						s = e.GetVertex(t.v1),
						o = e.GetVertex(t.v2),
						a = Cs(i, s, o),
						l = e.AddNormal(a);
					t.SetNormals(l, l, l)
				} else n.calculateCurveNormals = !0;
			t.curve === null && (t.curve = 0)
		}
		FinalizeNodes(e) {
			let t = e.GetRootNode(),
				n = [];
			t.EnumerateChildren(i => {
				i.IsEmpty() && n.push(i)
			});
			for (let i = 0; i < n.length; i++) {
				let s = n[i],
					o = s.GetParent();
				o !== null && (o.RemoveChildNode(s), o.IsEmpty() && n.push(o))
			}
		}
		GetDefaultMaterialIndex(e) {
			if (this.defaultMaterialIndex === null) {
				let t = this.params.getDefaultMaterialColor(),
					n = new hn;
				n.color = t, n.isDefault = !0, this.defaultMaterialIndex = e.AddMaterial(n)
			}
			return this.defaultMaterialIndex
		}
		Reset() {
			this.defaultMaterialIndex = null
		}
	};

	function qu(r, e) {
		new id(e).Finalize(r)
	}

	function Hg(r) {
		function e(s) {
			return s != null
		}

		function t(s) {
			return !(!e(s) || isNaN(s))
		}

		function n(s, o) {
			return !(!t(s) || s < 0 || s >= o)
		}

		function i(s, o) {
			function a(l, c, u) {
				return !(!n(u.v0, c.VertexCount()) || !n(u.v1, c.VertexCount()) || !n(u.v2, c.VertexCount()) || u.HasVertexColors() && (!n(u.c0, c.VertexColorCount()) || !n(u.c1, c.VertexColorCount()) || !n(u.c2, c.VertexColorCount())) || !n(u.n0, c.NormalCount()) || !n(u.n1, c.NormalCount()) || !n(u.n2, c.NormalCount()) || u.HasTextureUVs() && (!n(u.u0, c.TextureUVCount()) || !n(u.u1, c.TextureUVCount()) || !n(u.u2, c.TextureUVCount())) || !n(u.mat, l.MaterialCount()) || !t(u.curve))
			}
			for (let l = 0; l < o.VertexCount(); l++) {
				let c = o.GetVertex(l);
				if (!t(c.x) || !t(c.y) || !t(c.z)) return !1
			}
			for (let l = 0; l < o.VertexColorCount(); l++) {
				let c = o.GetVertexColor(l);
				if (!t(c.r) || !t(c.g) || !t(c.b)) return !1
			}
			for (let l = 0; l < o.NormalCount(); l++) {
				let c = o.GetNormal(l);
				if (!t(c.x) || !t(c.y) || !t(c.z)) return !1
			}
			for (let l = 0; l < o.TextureUVCount(); l++) {
				let c = o.GetTextureUV(l);
				if (!t(c.x) || !t(c.y)) return !1
			}
			for (let l = 0; l < o.TriangleCount(); l++) {
				let c = o.GetTriangle(l);
				if (!a(s, o, c)) return !1
			}
			return !0
		}
		for (let s = 0; s < r.MeshCount(); s++) {
			let o = r.GetMesh(s);
			if (!i(r, o)) return !1
		}
		return !0
	}
	var Vt = class {
		constructor() {
			this.name = null, this.extension = null, this.callbacks = null, this.model = null, this.error = null, this.message = null
		}
		Import(e, t, n, i) {
			this.Clear(), this.name = e, this.extension = t, this.callbacks = i, this.model = new or, this.error = !1, this.message = null, this.ResetContent(), this.ImportContent(n, () => {
				this.CreateResult(i)
			})
		}
		Clear() {
			this.name = null, this.extension = null, this.callbacks = null, this.model = null, this.error = null, this.message = null, this.ClearContent()
		}
		CreateResult(e) {
			if (this.error) {
				e.onError(), e.onComplete();
				return
			}
			if (Io(this.model)) {
				this.SetError("The model doesn't contain any meshes."), e.onError(), e.onComplete();
				return
			}
			qu(this.model, {
				getDefaultMaterialColor: this.callbacks.getDefaultMaterialColor
			}), e.onSuccess(), e.onComplete()
		}
		CanImportExtension(e) {
			return !1
		}
		GetUpDirection() {
			return ht.Z
		}
		ClearContent() {}
		ResetContent() {}
		ImportContent(e, t) {}
		GetModel() {
			return this.model
		}
		SetError(e) {
			this.error = !0, e != null && (this.message = e)
		}
		WasError() {
			return this.error
		}
		GetErrorMessage() {
			return this.message
		}
	};

	function Vr(r, e, t) {
		let n = r.substring(e),
			i = n.indexOf(t);
		return i !== -1 && (n = n.substring(0, i)), n.trim()
	}

	function Xi(r, e) {
		if (e !== null) {
			let t = r.indexOf(e);
			t !== -1 && (r = r.substring(0, t).trim())
		}
		return r.split(/\s+/u)
	}

	function Si(r, e) {
		function t(s, o) {
			let a = s.trim();
			a.length > 0 && o(a)
		}
		let n = 0,
			i = r.indexOf(`
`, n);
		for (; i !== -1;) t(r.substring(n, i), e), n = i + 1, i = r.indexOf(`
`, n);
		t(r.substring(n), e)
	}

	function rd(r) {
		return (r & r - 1) === 0
	}

	function Wg(r) {
		if (rd(r)) return r;
		let e = Math.pow(2, Math.ceil(Math.log(r) / Math.log(2)));
		return parseInt(e, 10)
	}

	function ni(r) {
		r.transparent = !1, lo(r.opacity, 1) && (r.transparent = !0)
	}
	var ti = class {
		constructor(e) {
			this.model = e, this.colorToMaterialIndex = new Map
		}
		GetMaterialIndex(e, t, n, i) {
			let s = xn(e) + xn(t) + xn(n),
				o = i != null;
			if (o && (s += xn(i)), this.colorToMaterialIndex.has(s)) return this.colorToMaterialIndex.get(s);
			{
				let a = new hn;
				a.name = s.toUpperCase(), a.color = new Et(e, t, n), o && i < 255 && (a.opacity = i / 255, ni(a));
				let l = this.model.AddMaterial(a);
				return this.colorToMaterialIndex.set(s, l), l
			}
		}
	};
	var xa = class extends Vt {
		constructor() {
			super(), this.rhino = null
		}
		CanImportExtension(e) {
			return e === "3dm"
		}
		GetUpDirection() {
			return ht.Z
		}
		ClearContent() {
			this.instanceIdToObject = null, this.instanceIdToDefinition = null
		}
		ResetContent() {
			this.instanceIdToObject = new Map, this.instanceIdToDefinition = new Map
		}
		ImportContent(e, t) {
			this.rhino === null ? Qi("loaders/rhino3dm.min.js").then(() => {
				rhino3dm().then(n => {
					this.rhino = n, this.ImportRhinoContent(e), t()
				})
			}).catch(() => {
				this.SetError("Failed to load rhino3dm."), t()
			}) : (this.ImportRhinoContent(e), t())
		}
		ImportRhinoContent(e) {
			let t = this.rhino.File3dm.fromByteArray(e);
			if (t === null) {
				this.SetError("Failed to read Rhino file.");
				return
			}
			this.ImportRhinoDocument(t), Io(this.model) && this.SetError("The model doesn't contain any 3D meshes. Try to save the model while you are in shaded view in Rhino.")
		}
		ImportRhinoDocument(e) {
			this.InitRhinoInstances(e), this.ImportRhinoUserStrings(e), this.ImportRhinoGeometry(e)
		}
		InitRhinoInstances(e) {
			let t = e.objects();
			for (let i = 0; i < t.count; i++) {
				let s = t.get(i),
					o = s.attributes();
				o.isInstanceDefinitionObject && this.instanceIdToObject.set(o.id, s)
			}
			let n = e.instanceDefinitions();
			for (let i = 0; i < n.count(); i++) {
				let s = n.get(i);
				this.instanceIdToDefinition.set(s.id, s)
			}
		}
		ImportRhinoUserStrings(e) {
			let t = e.strings();
			if (t.count() > 0) {
				let n = new Fn("Document user texts");
				for (let i = 0; i < t.count(); i++) {
					let s = t.get(i);
					n.AddProperty(new Jt(Bt.Text, s[0], s[1]))
				}
				this.model.AddPropertyGroup(n)
			}
		}
		ImportRhinoGeometry(e) {
			let t = e.objects();
			for (let n = 0; n < t.count; n++) {
				let i = t.get(n);
				this.ImportRhinoGeometryObject(e, i, [])
			}
		}
		ImportRhinoGeometryObject(e, t, n) {
			let i = t.geometry(),
				s = t.attributes(),
				o = i.objectType;
			if (s.isInstanceDefinitionObject && n.length === 0) return;
			let a = null,
				l = !1;
			if (o === this.rhino.ObjectType.Mesh) a = i, l = !1;
			else if (o === this.rhino.ObjectType.Extrusion) a = i.getMesh(this.rhino.MeshType.Any), l = !0;
			else if (o === this.rhino.ObjectType.Brep) {
				a = new this.rhino.Mesh;
				let c = i.faces();
				for (let u = 0; u < c.count; u++) {
					let h = c.get(u),
						f = h.getMesh(this.rhino.MeshType.Any);
					f && (a.append(f), f.delete()), h.delete()
				}
				c.delete(), a.compact(), l = !0
			} else if (o === this.rhino.ObjectType.SubD) i.subdivide(3), a = this.rhino.Mesh.createFromSubDControlNet(i), l = !0;
			else if (o === this.rhino.ObjectType.InstanceReference) {
				let c = i.parentIdefId;
				if (this.instanceIdToDefinition.has(c)) {
					let h = this.instanceIdToDefinition.get(c).getObjectIds();
					for (let f = 0; f < h.length; f++) {
						let m = h[f];
						if (this.instanceIdToObject.has(m)) {
							let g = this.instanceIdToObject.get(m);
							n.push(t), this.ImportRhinoGeometryObject(e, g, n), n.pop()
						}
					}
				}
			}
			a !== null && (this.ImportRhinoMesh(e, a, t, n), l && a.delete())
		}
		ImportRhinoMesh(e, t, n, i) {
			let s = n.attributes(),
				o = this.GetMaterialIndex(e, n, i),
				a = t.toThreejsJSON(),
				l = Wi(a.data, o, null);
			l.SetName(s.name);
			let c = s.getUserStrings();
			if (c.length > 0) {
				let u = new Fn("User texts");
				for (let h = 0; h < c.length; h++) {
					let f = c[h];
					u.AddProperty(new Jt(Bt.Text, f[0], f[1]))
				}
				l.AddPropertyGroup(u)
			}
			if (i.length !== 0) {
				let u = new ln().CreateIdentity();
				for (let f = i.length - 1; f >= 0; f--) {
					let y = i[f].geometry().xform.toFloatArray(!1),
						d = new ln(y);
					u = u.MultiplyMatrix(d)
				}
				let h = new rn(u);
				rr(l, h)
			}
			this.model.AddMeshToRootNode(l)
		}
		GetMaterialIndex(e, t, n) {
			function i(l, c, u) {
				let h = c.attributes();
				if (h.materialSource === l.ObjectMaterialSource.MaterialFromObject) {
					let f = h.materialIndex;
					if (f > -1) return e.materials().get(f)
				} else if (h.materialSource === l.ObjectMaterialSource.MaterialFromLayer) {
					let f = h.layerIndex;
					if (f > -1) {
						let g = e.layers().get(f).renderMaterialIndex;
						if (g > -1) return e.materials().get(g)
					}
				} else if (h.materialSource === l.ObjectMaterialSource.MaterialFromParent && u.length !== 0) return i(l, u[0], []);
				return null
			}

			function s(l, c) {
				function u(d, p) {
					d.Set(p.r, p.g, p.b)
				}

				function h(d) {
					return d.r === 0 && d.g === 0 && d.b === 0
				}

				function f(d) {
					return d.r === 255 && d.g === 255 && d.b === 255
				}
				let m = null,
					g = l.physicallyBased();
				g.supported ? (m = new qr, m.metalness = g.metallic ? 1 : 0, m.roughness = g.roughness) : (m = new hn, u(m.ambient, l.ambientColor), u(m.specular, l.specularColor)), m.name = l.name, u(m.color, l.diffuseColor), m.opacity = 1 - l.transparency, ni(m), h(m.color) && !f(l.reflectionColor) && u(m.color, l.reflectionColor), h(m.color) && !f(l.transparentColor) && u(m.color, l.transparentColor);
				let y = l.getBitmapTexture();
				if (y) {
					let d = new Jn,
						p = vn(y.fileName),
						_ = c.getFileBuffer(p);
					d.name = p, d.buffer = _, m.diffuseMap = d
				}
				return m
			}

			function o(l, c, u) {
				let h = s(c, u);
				for (let f = 0; f < l.MaterialCount(); f++)
					if (l.GetMaterial(f).IsEqual(h)) return f;
				return l.AddMaterial(h)
			}
			let a = i(this.rhino, t, n);
			return a === null ? null : o(this.model, a, this.callbacks)
		}
	};
	var Yn = class {
		constructor(e, t) {
			this.arrayBuffer = e, this.dataView = new DataView(e), this.isLittleEndian = t, this.position = 0
		}
		GetPosition() {
			return this.position
		}
		SetPosition(e) {
			this.position = e
		}
		GetByteLength() {
			return this.arrayBuffer.byteLength
		}
		Skip(e) {
			this.position = this.position + e
		}
		End() {
			return this.position >= this.arrayBuffer.byteLength
		}
		ReadArrayBuffer(e) {
			let t = new Uint8Array(this.arrayBuffer),
				n = new ArrayBuffer(e),
				i = new Uint8Array(n),
				s = t.subarray(this.position, this.position + e);
			return i.set(s, 0), this.position += e, n
		}
		ReadBoolean8() {
			let e = this.dataView.getInt8(this.position);
			return this.position = this.position + 1, !!e
		}
		ReadCharacter8() {
			let e = this.dataView.getInt8(this.position);
			return this.position = this.position + 1, e
		}
		ReadUnsignedCharacter8() {
			let e = this.dataView.getUint8(this.position);
			return this.position = this.position + 1, e
		}
		ReadInteger16() {
			let e = this.dataView.getInt16(this.position, this.isLittleEndian);
			return this.position = this.position + 2, e
		}
		ReadUnsignedInteger16() {
			let e = this.dataView.getUint16(this.position, this.isLittleEndian);
			return this.position = this.position + 2, e
		}
		ReadInteger32() {
			let e = this.dataView.getInt32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadUnsignedInteger32() {
			let e = this.dataView.getUint32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadFloat32() {
			let e = this.dataView.getFloat32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadDouble64() {
			let e = this.dataView.getFloat64(this.position, this.isLittleEndian);
			return this.position = this.position + 8, e
		}
	};
	var yt = {
			MAIN3DS: 19789,
			EDIT3DS: 15677,
			EDIT_MATERIAL: 45055,
			MAT_NAME: 40960,
			MAT_AMBIENT: 40976,
			MAT_DIFFUSE: 40992,
			MAT_SPECULAR: 41008,
			MAT_SHININESS: 41024,
			MAT_SHININESS_STRENGTH: 41025,
			MAT_TRANSPARENCY: 41040,
			MAT_COLOR_F: 16,
			MAT_COLOR: 17,
			MAT_LIN_COLOR: 18,
			MAT_LIN_COLOR_F: 19,
			MAT_TEXMAP: 41472,
			MAT_TEXMAP_NAME: 41728,
			MAT_TEXMAP_UOFFSET: 41816,
			MAT_TEXMAP_VOFFSET: 41818,
			MAT_TEXMAP_USCALE: 41812,
			MAT_TEXMAP_VSCALE: 41814,
			MAT_TEXMAP_ROTATION: 41820,
			PERCENTAGE: 48,
			PERCENTAGE_F: 49,
			EDIT_OBJECT: 16384,
			OBJ_TRIMESH: 16640,
			OBJ_LIGHT: 17920,
			OBJ_CAMERA: 18176,
			TRI_VERTEX: 16656,
			TRI_TEXVERTEX: 16704,
			TRI_FACE: 16672,
			TRI_TRANSFORMATION: 16736,
			TRI_MATERIAL: 16688,
			TRI_SMOOTH: 16720,
			KF3DS: 45056,
			OBJECT_NODE: 45058,
			OBJECT_HIERARCHY: 45072,
			OBJECT_INSTANCE_NAME: 45073,
			OBJECT_PIVOT: 45075,
			OBJECT_POSITION: 45088,
			OBJECT_ROTATION: 45089,
			OBJECT_SCALE: 45090,
			OBJECT_ID: 45104
		},
		sd = class {
			constructor() {
				this.id = -1, this.name = "", this.flags = -1, this.parentId = -1, this.instanceName = "", this.pivot = [0, 0, 0], this.positions = [], this.rotations = [], this.scales = []
			}
		},
		od = class {
			constructor() {
				this.nodes = [], this.nodeIdToNode = new Map
			}
			IsEmpty() {
				return this.nodes.length === 0
			}
			AddNode(e) {
				this.nodes.push(e), this.nodeIdToNode.set(e.nodeId, e)
			}
			GetNodes() {
				return this.nodes
			}
		},
		_a = class extends Vt {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "3ds"
			}
			GetUpDirection() {
				return ht.Z
			}
			ClearContent() {
				this.materialNameToIndex = null, this.meshNameToIndex = null, this.nodeList = null
			}
			ResetContent() {
				this.materialNameToIndex = new Map, this.meshNameToIndex = new Map, this.nodeList = new od
			}
			ImportContent(e, t) {
				this.ProcessBinary(e), t()
			}
			ProcessBinary(e) {
				let t = new Yn(e, !0),
					n = t.GetByteLength();
				this.ReadChunks(t, n, (i, s) => {
					i === yt.MAIN3DS ? this.ReadMainChunk(t, s) : this.SkipChunk(t, s)
				})
			}
			ReadMainChunk(e, t) {
				let n = this.GetChunkEnd(e, t);
				this.ReadChunks(e, n, (i, s) => {
					i === yt.EDIT3DS ? this.ReadEditorChunk(e, s) : i === yt.KF3DS ? this.ReadKeyFrameChunk(e, s) : this.SkipChunk(e, s)
				}), this.BuildNodeHierarchy()
			}
			ReadEditorChunk(e, t) {
				let n = this.GetChunkEnd(e, t);
				this.ReadChunks(e, n, (i, s) => {
					i === yt.EDIT_MATERIAL ? this.ReadMaterialChunk(e, s) : i === yt.EDIT_OBJECT ? this.ReadObjectChunk(e, s) : this.SkipChunk(e, s)
				})
			}
			ReadMaterialChunk(e, t) {
				let n = new hn,
					i = this.GetChunkEnd(e, t),
					s = null,
					o = null;
				this.ReadChunks(e, i, (l, c) => {
					l === yt.MAT_NAME ? n.name = this.ReadName(e) : l === yt.MAT_AMBIENT ? n.ambient = this.ReadColorChunk(e, c) : l === yt.MAT_DIFFUSE ? n.color = this.ReadColorChunk(e, c) : l === yt.MAT_SPECULAR ? n.specular = this.ReadColorChunk(e, c) : l === yt.MAT_SHININESS ? s = this.ReadPercentageChunk(e, c) : l === yt.MAT_SHININESS_STRENGTH ? o = this.ReadPercentageChunk(e, c) : l === yt.MAT_TRANSPARENCY ? (n.opacity = 1 - this.ReadPercentageChunk(e, c), ni(n)) : l === yt.MAT_TEXMAP ? (n.diffuseMap = this.ReadTextureMapChunk(e, c), ni(n)) : this.SkipChunk(e, c)
				}), s !== null && o !== null && (n.shininess = s * o / 10);
				let a = this.model.AddMaterial(n);
				this.materialNameToIndex.set(n.name, a)
			}
			ReadTextureMapChunk(e, t) {
				let n = new Jn,
					i = this.GetChunkEnd(e, t);
				return this.ReadChunks(e, i, (s, o) => {
					if (s === yt.MAT_TEXMAP_NAME) {
						let a = this.ReadName(e),
							l = this.callbacks.getFileBuffer(a);
						n.name = a, n.buffer = l
					} else s === yt.MAT_TEXMAP_UOFFSET ? n.offset.x = e.ReadFloat32() : s === yt.MAT_TEXMAP_VOFFSET ? n.offset.y = e.ReadFloat32() : s === yt.MAT_TEXMAP_USCALE ? n.scale.x = e.ReadFloat32() : s === yt.MAT_TEXMAP_VSCALE ? n.scale.y = e.ReadFloat32() : s === yt.MAT_TEXMAP_ROTATION ? n.rotation = e.ReadFloat32() * tr : this.SkipChunk(e, o)
				}), n
			}
			ReadColorChunk(e, t) {
				let n = new Et(0, 0, 0),
					i = this.GetChunkEnd(e, t),
					s = !1;
				return this.ReadChunks(e, i, (o, a) => {
					o === yt.MAT_COLOR ? s || (n.r = e.ReadUnsignedCharacter8(), n.g = e.ReadUnsignedCharacter8(), n.b = e.ReadUnsignedCharacter8()) : o === yt.MAT_LIN_COLOR ? (n.r = e.ReadUnsignedCharacter8(), n.g = e.ReadUnsignedCharacter8(), n.b = e.ReadUnsignedCharacter8(), s = !0) : o === yt.MAT_COLOR_F ? s || (n.r = En(e.ReadFloat32()), n.g = En(e.ReadFloat32()), n.b = En(e.ReadFloat32())) : o === yt.MAT_LIN_COLOR_F ? (n.r = En(e.ReadFloat32()), n.g = En(e.ReadFloat32()), n.b = En(e.ReadFloat32()), s = !0) : this.SkipChunk(e, a)
				}), n
			}
			ReadPercentageChunk(e, t) {
				let n = 0,
					i = this.GetChunkEnd(e, t);
				return this.ReadChunks(e, i, (s, o) => {
					s === yt.PERCENTAGE ? n = e.ReadUnsignedInteger16() / 100 : s === yt.PERCENTAGE_F ? n = e.ReadFloat32() : this.SkipChunk(e, o)
				}), n
			}
			ReadObjectChunk(e, t) {
				let n = this.GetChunkEnd(e, t),
					i = this.ReadName(e);
				this.ReadChunks(e, n, (s, o) => {
					s === yt.OBJ_TRIMESH ? this.ReadMeshChunk(e, o, i) : this.SkipChunk(e, o)
				})
			}
			ReadMeshChunk(e, t, n) {
				function i(u, h) {
					if (!h.IsValid()) return;
					let f = h.Determinant(),
						m = Tr(f);
					m && (h = new ln().CreateScale(-1, 1, 1).MultiplyMatrix(h));
					let g = h.Invert();
					if (g === null) return;
					let y = new rn(g);
					rr(u, y), m && Oc(u)
				}
				let s = new $t;
				s.SetName(n);
				let o = this.GetChunkEnd(e, t),
					a = null;
				if (this.ReadChunks(e, o, (u, h) => {
						u === yt.TRI_VERTEX ? this.ReadVerticesChunk(s, e) : u === yt.TRI_TEXVERTEX ? this.ReadTextureVerticesChunk(s, e) : u === yt.TRI_FACE ? this.ReadFacesChunk(s, e, h) : u === yt.TRI_TRANSFORMATION ? a = this.ReadTransformationChunk(e) : this.SkipChunk(e, h)
					}), s.VertexCount() === s.TextureUVCount())
					for (let u = 0; u < s.TriangleCount(); u++) {
						let h = s.GetTriangle(u);
						h.SetTextureUVs(h.v0, h.v1, h.v2)
					}
				let l = new ln(a);
				i(s, l);
				let c = this.model.AddMesh(s);
				this.meshNameToIndex.set(s.GetName(), c)
			}
			ReadVerticesChunk(e, t) {
				let n = t.ReadUnsignedInteger16();
				for (let i = 0; i < n; i++) {
					let s = t.ReadFloat32(),
						o = t.ReadFloat32(),
						a = t.ReadFloat32();
					e.AddVertex(new He(s, o, a))
				}
			}
			ReadTextureVerticesChunk(e, t) {
				let n = t.ReadUnsignedInteger16();
				for (let i = 0; i < n; i++) {
					let s = t.ReadFloat32(),
						o = t.ReadFloat32();
					e.AddTextureUV(new wt(s, o))
				}
			}
			ReadFacesChunk(e, t, n) {
				let i = this.GetChunkEnd(t, n),
					s = t.ReadUnsignedInteger16();
				for (let o = 0; o < s; o++) {
					let a = t.ReadUnsignedInteger16(),
						l = t.ReadUnsignedInteger16(),
						c = t.ReadUnsignedInteger16();
					t.ReadUnsignedInteger16(), e.AddTriangle(new Ht(a, l, c))
				}
				this.ReadChunks(t, i, (o, a) => {
					o === yt.TRI_MATERIAL ? this.ReadFaceMaterialsChunk(e, t) : o === yt.TRI_SMOOTH ? this.ReadFaceSmoothingGroupsChunk(e, s, t) : this.SkipChunk(t, a)
				})
			}
			ReadFaceMaterialsChunk(e, t) {
				let n = this.ReadName(t),
					i = this.materialNameToIndex.get(n),
					s = t.ReadUnsignedInteger16();
				for (let o = 0; o < s; o++) {
					let a = t.ReadUnsignedInteger16(),
						l = e.GetTriangle(a);
					i !== void 0 && (l.mat = i)
				}
			}
			ReadFaceSmoothingGroupsChunk(e, t, n) {
				for (let i = 0; i < t; i++) {
					let s = n.ReadUnsignedInteger32(),
						o = e.GetTriangle(i);
					o.curve = s
				}
			}
			ReadTransformationChunk(e) {
				let t = [];
				for (let n = 0; n < 4; n++) {
					for (let i = 0; i < 3; i++) t.push(e.ReadFloat32());
					n < 3 ? t.push(0) : t.push(1)
				}
				return t
			}
			ReadKeyFrameChunk(e, t) {
				let n = this.GetChunkEnd(e, t);
				this.ReadChunks(e, n, (i, s) => {
					i === yt.OBJECT_NODE ? this.ReadObjectNodeChunk(e, s) : this.SkipChunk(e, s)
				})
			}
			BuildNodeHierarchy() {
				function e(n, i) {
					function s(c) {
						return c.positions.length === 0 ? [0, 0, 0] : c.positions[0]
					}

					function o(c) {
						function u(f) {
							let m = [0, 0, 0, 1],
								g = Math.sqrt(f[0] * f[0] + f[1] * f[1] + f[2] * f[2]);
							if (g > 0) {
								let y = f[3] * -.5,
									d = Math.sin(y) / g;
								m = [d * f[0], d * f[1], d * f[2], Math.cos(y)]
							}
							return m
						}
						if (c.rotations.length === 0) return [0, 0, 0, 1];
						let h = c.rotations[0];
						return u(h)
					}

					function a(c) {
						return c.scales.length === 0 ? [1, 1, 1] : c.scales[0]
					}
					let l = new ln;
					if (l.ComposeTRS(jr(s(n)), vo(o(n)), jr(a(n))), i) {
						let c = n.pivot;
						l = new ln().CreateTranslation(-c[0], -c[1], -c[2]).MultiplyMatrix(l)
					}
					return new rn(l)
				}
				let t = this.model.GetRootNode();
				if (this.nodeList.IsEmpty())
					for (let n = 0; n < this.model.MeshCount(); n++) t.AddMeshIndex(n);
				else {
					let n = new Map;
					for (let i of this.nodeList.GetNodes()) {
						let s = new Sn;
						i.name.length > 0 && i.name !== "$$$DUMMY" && (s.SetName(i.name), i.instanceName.length > 0 && s.SetName(s.GetName() + " " + i.instanceName)), i.parentId === 65535 || !n.has(i.parentId) ? t.AddChildNode(s) : n.get(i.parentId).AddChildNode(s), n.set(i.id, s);
						let o = this.meshNameToIndex.has(i.name);
						s.SetTransformation(e(i, o)), o && s.AddMeshIndex(this.meshNameToIndex.get(i.name))
					}
				}
			}
			ReadObjectNodeChunk(e, t) {
				function n(o, a, l) {
					let c = [];
					a.Skip(10);
					let u = a.ReadInteger32();
					for (let h = 0; h < u; h++) {
						a.ReadInteger32(), a.ReadUnsignedInteger16() !== 0 && a.ReadFloat32();
						let m = null;
						if (l === yt.OBJECT_ROTATION) {
							let g = a.ReadFloat32();
							m = o.ReadVector(a), m[3] = g
						} else m = o.ReadVector(a);
						c.push(m)
					}
					return c
				}
				let i = new sd,
					s = this.GetChunkEnd(e, t);
				this.ReadChunks(e, s, (o, a) => {
					o === yt.OBJECT_HIERARCHY ? (i.name = this.ReadName(e), i.flags = e.ReadUnsignedInteger32(), i.parentId = e.ReadUnsignedInteger16()) : o === yt.OBJECT_INSTANCE_NAME ? i.instanceName = this.ReadName(e) : o === yt.OBJECT_PIVOT ? i.pivot = this.ReadVector(e) : o === yt.OBJECT_POSITION ? i.positions = n(this, e, yt.OBJECT_POSITION) : o === yt.OBJECT_ROTATION ? i.rotations = n(this, e, yt.OBJECT_ROTATION) : o === yt.OBJECT_SCALE ? i.scales = n(this, e, yt.OBJECT_SCALE) : o === yt.OBJECT_ID ? i.id = e.ReadUnsignedInteger16() : this.SkipChunk(e, a)
				}), this.nodeList.AddNode(i)
			}
			ReadName(e) {
				let t = "",
					n = 0,
					i = 0;
				for (; i < 64 && (n = e.ReadCharacter8(), n !== 0);) t = t + String.fromCharCode(n), i = i + 1;
				return t
			}
			ReadVector(e) {
				return [e.ReadFloat32(), e.ReadFloat32(), e.ReadFloat32()]
			}
			ReadChunks(e, t, n) {
				for (; e.GetPosition() <= t - 6;) {
					let i = e.ReadUnsignedInteger16(),
						s = e.ReadUnsignedInteger32();
					n(i, s)
				}
			}
			GetChunkEnd(e, t) {
				return e.GetPosition() + t - 6
			}
			SkipChunk(e, t) {
				e.Skip(t - 6)
			}
		};
	var ii = {
			BYTE: 5120,
			UNSIGNED_BYTE: 5121,
			SHORT: 5122,
			UNSIGNED_SHORT: 5123,
			UNSIGNED_INT: 5125,
			FLOAT: 5126
		},
		qi = {
			SCALAR: 0,
			VEC2: 1,
			VEC3: 2,
			VEC4: 3,
			MAT2: 4,
			MAT3: 5,
			MAT4: 6
		},
		$s = {
			POINTS: 0,
			LINES: 1,
			LINE_LOOP: 2,
			LINE_STRIP: 3,
			TRIANGLES: 4,
			TRIANGLE_STRIP: 5,
			TRIANGLE_FAN: 6
		},
		ad = {
			GLTF_STRING: 1179937895,
			JSON_CHUNK_TYPE: 1313821514,
			BINARY_CHUNK_TYPE: 5130562
		};

	function zl(r) {
		return ai(Ss(r[0]), Ss(r[1]), Ss(r[2]))
	}

	function WM(r, e) {
		function t(n, i) {
			let s = n;
			return i === ii.UNSIGNED_BYTE ? s /= 255 : i === ii.UNSIGNED_SHORT && (s /= 65535), En(Ss(s))
		}
		return new Et(t(r[0], e), t(r[1], e), t(r[2], e))
	}
	var ld = class {
			constructor(e) {
				this.reader = new Yn(e, !0), this.componentType = null, this.dataType = null, this.byteStride = null, this.dataCount = null, this.sparseReader = null
			}
			SetComponentType(e) {
				this.componentType = e
			}
			SetDataType(e) {
				e === "SCALAR" ? this.dataType = qi.SCALAR : e === "VEC2" ? this.dataType = qi.VEC2 : e === "VEC3" ? this.dataType = qi.VEC3 : e === "VEC4" ? this.dataType = qi.VEC4 : e === "MAT2" ? this.dataType = qi.MAT2 : e === "MAT3" ? this.dataType = qi.MAT3 : e === "MAT4" && (this.dataType = qi.MAT4)
			}
			SetByteStride(e) {
				this.byteStride = e
			}
			SetDataCount(e) {
				this.dataCount = e
			}
			SetSparseReader(e, t) {
				this.sparseReader = {
					indexReader: e,
					valueReader: t
				}
			}
			ReadArrayBuffer(e) {
				return this.reader.ReadArrayBuffer(e)
			}
			GetDataCount() {
				return this.dataCount
			}
			ReadData() {
				if (this.dataType === null) return null;
				if (this.dataType === qi.SCALAR) {
					let e = this.ReadComponent();
					return this.SkipBytesByStride(1), e
				} else if (this.dataType === qi.VEC2) {
					let e = this.ReadComponent(),
						t = this.ReadComponent();
					return this.SkipBytesByStride(2), new wt(e, t)
				} else if (this.dataType === qi.VEC3) {
					let e = this.ReadComponent(),
						t = this.ReadComponent(),
						n = this.ReadComponent();
					return this.SkipBytesByStride(3), new He(e, t, n)
				} else if (this.dataType === qi.VEC4) {
					let e = this.ReadComponent(),
						t = this.ReadComponent(),
						n = this.ReadComponent(),
						i = this.ReadComponent();
					return this.SkipBytesByStride(4), new Oi(e, t, n, i)
				}
				return null
			}
			EnumerateData(e) {
				if (this.sparseReader === null)
					for (let t = 0; t < this.dataCount; t++) e(this.ReadData());
				else {
					let t = [];
					for (let i = 0; i < this.sparseReader.indexReader.GetDataCount(); i++) {
						let s = this.sparseReader.indexReader.ReadData(),
							o = this.sparseReader.valueReader.ReadData();
						t.push({
							index: s,
							value: o
						})
					}
					let n = 0;
					for (let i = 0; i < this.dataCount; i++) {
						let s = this.ReadData();
						n < t.length && t[n].index === i ? (e(t[n].value), n += 1) : e(s)
					}
				}
			}
			SkipBytes(e) {
				this.reader.Skip(e)
			}
			ReadComponent() {
				return this.componentType === null ? null : this.componentType === ii.BYTE ? this.reader.ReadCharacter8() : this.componentType === ii.UNSIGNED_BYTE ? this.reader.ReadUnsignedCharacter8() : this.componentType === ii.SHORT ? this.reader.ReadInteger16() : this.componentType === ii.UNSIGNED_SHORT ? this.reader.ReadUnsignedInteger16() : this.componentType === ii.UNSIGNED_INT ? this.reader.ReadInteger32() : this.componentType === ii.FLOAT ? this.reader.ReadFloat32() : null
			}
			SkipBytesByStride(e) {
				if (this.byteStride === null) return;
				let t = e * this.GetComponentSize();
				this.reader.Skip(this.byteStride - t)
			}
			GetComponentSize() {
				return this.componentType === ii.BYTE || this.componentType === ii.UNSIGNED_BYTE ? 1 : this.componentType === ii.SHORT || this.componentType === ii.UNSIGNED_SHORT ? 2 : this.componentType === ii.UNSIGNED_INT || this.componentType === ii.FLOAT ? 4 : 0
			}
		},
		cd = class {
			constructor() {
				this.supportedExtensions = ["KHR_draco_mesh_compression", "KHR_materials_pbrSpecularGlossiness", "KHR_texture_transform"], this.draco = null
			}
			LoadLibraries(e, t) {
				if (e === void 0) {
					t.onSuccess();
					return
				}
				this.draco === null && e.indexOf("KHR_draco_mesh_compression") !== -1 ? Qi("loaders/draco_decoder.js").then(() => {
					DracoDecoderModule().then(n => {
						this.draco = n, t.onSuccess()
					})
				}).catch(() => {
					t.onError("Failed to load draco decoder.")
				}) : t.onSuccess()
			}
			GetUnsupportedExtensions(e) {
				let t = [];
				if (e === void 0) return t;
				for (let n = 0; n < e.length; n++) {
					let i = e[n];
					this.supportedExtensions.indexOf(i) === -1 && t.push(i)
				}
				return t
			}
			ProcessMaterial(e, t, n) {
				if (e.extensions === void 0) return null;
				let i = e.extensions.KHR_materials_pbrSpecularGlossiness;
				if (i === void 0) return null;
				let s = new hn,
					o = i.diffuseFactor;
				o !== void 0 && (s.color = zl(o), s.opacity = o[3]);
				let a = i.diffuseTexture;
				a !== void 0 && (s.diffuseMap = n(a));
				let l = i.specularFactor;
				l !== void 0 && (s.specular = zl(l));
				let c = i.specularGlossinessTexture;
				c !== void 0 && (s.specularMap = n(c));
				let u = i.glossinessFactor;
				return u !== void 0 && (s.shininess = u), s
			}
			ProcessTexture(e, t) {
				if (e.extensions === void 0) return;
				let n = e.extensions.KHR_texture_transform;
				n !== void 0 && (n.offset !== void 0 && (t.offset.x = n.offset[0], t.offset.y = -n.offset[1]), n.scale !== void 0 && (t.scale.x = n.scale[0], t.scale.y = n.scale[1]), n.rotation !== void 0 && (t.rotation = -n.rotation))
			}
			ProcessPrimitive(e, t, n, i) {
				function s(k, F, U, K, Z) {
					let Y = F.GetAttributeByUniqueId(U, K),
						H = Y.num_components(),
						de = U.num_points() * H,
						te = de * 4,
						fe = k._malloc(te);
					F.GetAttributeDataArrayForAllPoints(U, Y, k.DT_FLOAT32, te, fe);
					let me = new Float32Array(k.HEAPF32.buffer, fe, de).slice();
					if (H === 2)
						for (let P = 0; P < me.length; P += 2) Z(new wt(me[P + 0], me[P + 1]));
					else if (H === 3)
						for (let P = 0; P < me.length; P += 3) Z(new He(me[P + 0], me[P + 1], me[P + 2]));
					else if (H === 4)
						for (let P = 0; P < me.length; P += 4) Z(new Oi(me[P + 0], me[P + 1], me[P + 2], me[P + 3]));
					k._free(fe)
				}
				if (this.draco === null || n.extensions === void 0 || n.extensions.KHR_draco_mesh_compression === void 0) return !1;
				let o = new this.draco.Decoder,
					a = new this.draco.DecoderBuffer,
					l = n.extensions.KHR_draco_mesh_compression,
					c = t.bufferViews[l.bufferView],
					h = e.GetReaderFromBufferView(c).ReadArrayBuffer(c.byteLength);
				if (a.Init(new Int8Array(h), h.byteLength), o.GetEncodedGeometryType(a) !== this.draco.TRIANGULAR_MESH) return !0;
				let m = new this.draco.Mesh;
				if (!o.DecodeBufferToMesh(a, m).ok()) return !0;
				let y = l.attributes.POSITION !== void 0,
					d = !1,
					p = l.attributes.NORMAL !== void 0,
					_ = l.attributes.TEXCOORD_0 !== void 0;
				if (!y) return !0;
				let v = i.VertexCount(),
					x = i.VertexColorCount(),
					M = i.NormalCount(),
					I = i.TextureUVCount();
				s(this.draco, o, m, l.attributes.POSITION, k => {
					i.AddVertex(k)
				}), p && s(this.draco, o, m, l.attributes.NORMAL, k => {
					i.AddNormal(k)
				}), _ && s(this.draco, o, m, l.attributes.TEXCOORD_0, k => {
					k.y = -k.y, i.AddTextureUV(k)
				});
				let L = m.num_faces() * 3,
					T = L * 4,
					C = this.draco._malloc(T);
				o.GetTrianglesUInt32Array(m, T, C);
				let V = new Uint32Array(this.draco.HEAPU32.buffer, C, L).slice();
				for (let k = 0; k < V.length; k += 3) {
					let F = V[k],
						U = V[k + 1],
						K = V[k + 2];
					e.AddTriangle(n, i, F, U, K, d, p, _, v, x, M, I)
				}
				return this.draco._free(C), !0
			}
		},
		Ta = class extends Vt {
			constructor() {
				super(), this.gltfExtensions = new cd
			}
			CanImportExtension(e) {
				return e === "gltf" || e === "glb"
			}
			GetUpDirection() {
				return ht.Y
			}
			ClearContent() {
				this.bufferContents = null, this.imageIndexToTextureParams = null
			}
			ResetContent() {
				this.bufferContents = [], this.imageIndexToTextureParams = new Map
			}
			ImportContent(e, t) {
				this.extension === "gltf" ? this.ProcessGltf(e, t) : this.extension === "glb" && this.ProcessBinaryGltf(e, t)
			}
			ProcessGltf(e, t) {
				let n = fn(e),
					i = JSON.parse(n);
				if (i.asset.version !== "2.0") {
					this.SetError("Invalid glTF version."), t();
					return
				}
				for (let s = 0; s < i.buffers.length; s++) {
					let o = null,
						a = i.buffers[s],
						l = As(a.uri);
					if (l !== null) o = l.buffer;
					else {
						let c = this.callbacks.getFileBuffer(a.uri);
						c !== null && (o = c)
					}
					if (o === null) {
						this.SetError("One of the requested buffers is missing."), t();
						return
					}
					this.bufferContents.push(o)
				}
				this.ProcessMainFile(i, t)
			}
			ProcessBinaryGltf(e, t) {
				function n(c) {
					let u = c.ReadUnsignedInteger32(),
						h = c.ReadUnsignedInteger32(),
						f = c.ReadArrayBuffer(u);
					return {
						type: h,
						buffer: f
					}
				}
				let i = new Yn(e, !0);
				if (i.ReadUnsignedInteger32() !== ad.GLTF_STRING) {
					this.SetError("Invalid glTF file."), t();
					return
				}
				if (i.ReadUnsignedInteger32() !== 2) {
					this.SetError("Invalid glTF version."), t();
					return
				}
				if (i.ReadUnsignedInteger32() !== i.GetByteLength()) {
					this.SetError("Invalid glTF file."), t();
					return
				}
				let l = null;
				for (; !i.End();) {
					let c = n(i);
					c.type === ad.JSON_CHUNK_TYPE ? l = fn(c.buffer) : c.type === ad.BINARY_CHUNK_TYPE && this.bufferContents.push(c.buffer)
				}
				if (l !== null) {
					let c = JSON.parse(l);
					this.ProcessMainFile(c, t)
				}
			}
			ProcessMainFile(e, t) {
				let n = this.gltfExtensions.GetUnsupportedExtensions(e.extensionsRequired);
				if (n.length > 0) {
					this.SetError("Unsupported extension: " + n.join(", ") + "."), t();
					return
				}
				this.gltfExtensions.LoadLibraries(e.extensionsRequired, {
					onSuccess: () => {
						this.ImportModel(e), t()
					},
					onError: i => {
						this.SetError(i), t()
					}
				})
			}
			ImportModel(e) {
				let t = e.materials;
				if (t !== void 0)
					for (let i of t) this.ImportMaterial(e, i);
				let n = e.meshes;
				if (n !== void 0)
					for (let i of n) this.ImportMesh(e, i);
				this.ImportProperties(this.model, e.asset, "Asset properties"), this.ImportScene(e)
			}
			ImportProperties(e, t, n) {
				if (t == null) return;
				let i = new Fn(n);
				for (let s in t)
					if (Object.prototype.hasOwnProperty.call(t, s)) {
						let o = null,
							a = t[s];
						typeof a == "string" ? o = new Jt(Bt.Text, s, a) : typeof a == "number" && (Number.isInteger(a) ? o = new Jt(Bt.Integer, s, a) : o = new Jt(Bt.Number, s, a)), o !== null && i.AddProperty(o)
					} i.PropertyCount() !== 0 && e.AddPropertyGroup(i)
			}
			GetDefaultScene(e) {
				let t = e.scene || 0;
				return t >= e.scenes.length ? null : e.scenes[t]
			}
			ImportMaterial(e, t) {
				let n = new qr;
				if (t.name !== void 0 && (n.name = t.name), n.color = zl([1, 1, 1]), t.pbrMetallicRoughness !== void 0) {
					let s = t.pbrMetallicRoughness.baseColorFactor;
					s !== void 0 && (n.color = zl(s), n.opacity = s[3]);
					let o = t.pbrMetallicRoughness.metallicFactor;
					o !== void 0 && (n.metalness = o);
					let a = t.pbrMetallicRoughness.roughnessFactor;
					a !== void 0 && (n.roughness = a);
					let l = t.emissiveFactor;
					l !== void 0 && (n.emissive = zl(l)), n.diffuseMap = this.ImportTexture(e, t.pbrMetallicRoughness.baseColorTexture), n.metalnessMap = this.ImportTexture(e, t.pbrMetallicRoughness.metallicRoughnessTexture), n.normalMap = this.ImportTexture(e, t.normalTexture), n.emissiveMap = this.ImportTexture(e, t.emissiveTexture), n.diffuseMap !== null && (n.multiplyDiffuseMap = !0);
					let c = t.alphaMode;
					c !== void 0 && (c === "BLEND" ? n.transparent = !0 : c === "MASK" && (n.transparent = !0, n.alphaTest = t.alphaCutoff || .5))
				}
				let i = this.gltfExtensions.ProcessMaterial(t, n, s => this.ImportTexture(e, s));
				i !== null && (n = i), this.model.AddMaterial(n)
			}
			ImportTexture(e, t) {
				if (t == null) return null;
				let n = new Jn,
					s = e.textures[t.index].source,
					o = e.images[s],
					a = null;
				if (this.imageIndexToTextureParams.has(s)) a = this.imageIndexToTextureParams.get(s);
				else {
					a = {
						name: null,
						mimeType: null,
						buffer: null
					};
					let l = s.toString();
					if (o.uri !== void 0) {
						let c = As(o.uri);
						if (c !== null) a.name = "Embedded_" + l + "." + Yr(c.mimeType), a.mimeType = c.mimeType, a.buffer = c.buffer;
						else {
							let u = this.callbacks.getFileBuffer(o.uri);
							a.name = o.uri, a.buffer = u
						}
					} else if (o.bufferView !== void 0) {
						let c = e.bufferViews[o.bufferView],
							u = this.GetReaderFromBufferView(c);
						if (u !== null) {
							let h = u.ReadArrayBuffer(c.byteLength);
							a.name = "Binary_" + l + "." + Yr(o.mimeType), a.mimeType = o.mimeType, a.buffer = h
						}
					}
					this.imageIndexToTextureParams.set(s, a)
				}
				return n.name = a.name, n.mimeType = a.mimeType, n.buffer = a.buffer, this.gltfExtensions.ProcessTexture(t, n), n
			}
			ImportMesh(e, t) {
				let n = new $t;
				this.model.AddMesh(n), t.name !== void 0 && n.SetName(t.name);
				for (let i = 0; i < t.primitives.length; i++) {
					let s = t.primitives[i];
					this.ImportPrimitive(e, s, n)
				}
				this.ImportProperties(n, t.extras, "Mesh properties")
			}
			ImportPrimitive(e, t, n) {
				function i(p, _, v) {
					let x = _.attributes[v];
					if (x === void 0) return !1;
					let M = p.accessors[x];
					return !(M === void 0 || M.count === 0)
				}
				if (this.gltfExtensions.ProcessPrimitive(this, e, t, n) || t.attributes === void 0) return;
				let s = i(e, t, "POSITION"),
					o = i(e, t, "COLOR_0"),
					a = i(e, t, "NORMAL"),
					l = i(e, t, "TEXCOORD_0"),
					c = t.indices !== void 0,
					u = $s.TRIANGLES;
				if (t.mode !== void 0 && (u = t.mode), u !== $s.TRIANGLES && u !== $s.TRIANGLE_STRIP && u !== $s.TRIANGLE_FAN) return;
				let h = n.VertexCount(),
					f = n.VertexColorCount(),
					m = n.NormalCount(),
					g = n.TextureUVCount();
				if (s) {
					let p = e.accessors[t.attributes.POSITION],
						_ = this.GetReaderFromAccessor(e, p);
					if (_ === null) return;
					_.EnumerateData(v => {
						n.AddVertex(v)
					})
				} else return;
				let y = n.VertexCount() - h;
				if (o) {
					let p = e.accessors[t.attributes.COLOR_0],
						_ = this.GetReaderFromAccessor(e, p);
					if (_ === null) return;
					_.EnumerateData(v => {
						let x = WM([v.x, v.y, v.z], _.componentType);
						n.AddVertexColor(x)
					}), n.VertexColorCount() - f !== y && (o = !1)
				}
				if (a) {
					let p = e.accessors[t.attributes.NORMAL],
						_ = this.GetReaderFromAccessor(e, p);
					if (_ === null) return;
					_.EnumerateData(v => {
						n.AddNormal(v)
					}), n.NormalCount() - m !== y && (a = !1)
				}
				if (l) {
					let p = e.accessors[t.attributes.TEXCOORD_0],
						_ = this.GetReaderFromAccessor(e, p);
					if (_ === null) return;
					_.EnumerateData(v => {
						v.y = -v.y, n.AddTextureUV(v)
					}), n.TextureUVCount() - g !== y && (l = !1)
				}
				let d = [];
				if (c) {
					let p = e.accessors[t.indices],
						_ = this.GetReaderFromAccessor(e, p);
					if (_ === null) return;
					_.EnumerateData(v => {
						d.push(v)
					})
				} else {
					let p = n.VertexCount() - h;
					for (let _ = 0; _ < p; _++) d.push(_)
				}
				if (u === $s.TRIANGLES)
					for (let p = 0; p < d.length; p += 3) {
						let _ = d[p],
							v = d[p + 1],
							x = d[p + 2];
						this.AddTriangle(t, n, _, v, x, o, a, l, h, f, m, g)
					} else if (u === $s.TRIANGLE_STRIP)
						for (let p = 0; p < d.length - 2; p++) {
							let _ = d[p],
								v = d[p + 1],
								x = d[p + 2];
							if (p % 2 === 1) {
								let M = v;
								v = x, x = M
							}
							this.AddTriangle(t, n, _, v, x, o, a, l, h, f, m, g)
						} else if (u === $s.TRIANGLE_FAN)
							for (let p = 1; p < d.length - 1; p++) {
								let _ = d[0],
									v = d[p],
									x = d[p + 1];
								this.AddTriangle(t, n, _, v, x, o, a, l, h, f, m, g)
							}
			}
			AddTriangle(e, t, n, i, s, o, a, l, c, u, h, f) {
				let m = new Ht(c + n, c + i, c + s);
				o && m.SetVertexColors(u + n, u + i, u + s), a && m.SetNormals(h + n, h + i, h + s), l && m.SetTextureUVs(f + n, f + i, f + s), e.material !== void 0 && (m.mat = e.material), t.AddTriangle(m)
			}
			ImportScene(e) {
				let t = this.GetDefaultScene(e);
				if (t === null) return;
				let n = this.model.GetRootNode();
				for (let i of t.nodes) {
					let s = e.nodes[i];
					this.ImportNode(e, s, n)
				}
				this.ImportProperties(this.model, t.extras, "Scene properties")
			}
			ImportNode(e, t, n) {
				function i(o) {
					let a = new ln().CreateIdentity();
					if (o.matrix !== void 0) a.Set(o.matrix);
					else {
						let l = [0, 0, 0],
							c = [0, 0, 0, 1],
							u = [1, 1, 1];
						o.translation !== void 0 && (l = o.translation), o.rotation !== void 0 && (c = o.rotation), o.scale !== void 0 && (u = o.scale), a.ComposeTRS(jr(l), vo(c), jr(u))
					}
					return new rn(a)
				}
				if (t.children === void 0 && t.mesh === void 0) return;
				let s = new Sn;
				if (t.name !== void 0 && s.SetName(t.name), s.SetTransformation(i(t)), n.AddChildNode(s), t.children !== void 0)
					for (let o of t.children) {
						let a = e.nodes[o];
						this.ImportNode(e, a, s)
					}
				if (t.mesh !== void 0) {
					let o = this.model.GetMesh(t.mesh);
					this.ImportProperties(o, t.extras, "Node properties"), s.AddMeshIndex(t.mesh)
				}
			}
			GetReaderFromBufferView(e) {
				let t = e.buffer || 0,
					n = this.bufferContents[t];
				if (n == null) return null;
				let i = new ld(n);
				i.SkipBytes(e.byteOffset || 0);
				let s = e.byteStride;
				return s !== void 0 && s !== 0 && i.SetByteStride(s), i
			}
			GetReaderFromAccessor(e, t) {
				let n = t.bufferView || 0,
					i = e.bufferViews[n],
					s = this.GetReaderFromBufferView(i);
				if (s === null) return null;
				if (s.SetComponentType(t.componentType), s.SetDataType(t.type), s.SetDataCount(t.count), s.SkipBytes(t.byteOffset || 0), t.sparse !== void 0) {
					let o = this.GetReaderFromSparseAccessor(e, t.sparse.indices, t.sparse.indices.componentType, "SCALAR", t.sparse.count),
						a = this.GetReaderFromSparseAccessor(e, t.sparse.values, t.componentType, t.type, t.sparse.count);
					o !== null && a !== null && s.SetSparseReader(o, a)
				}
				return s
			}
			GetReaderFromSparseAccessor(e, t, n, i, s) {
				if (t.bufferView === void 0) return null;
				let o = e.bufferViews[t.bufferView],
					a = this.GetReaderFromBufferView(o);
				return a === null ? null : (a.SetComponentType(n), a.SetDataType(i), a.SetDataCount(s), a.SkipBytes(t.byteOffset || 0), a)
			}
		};
	var Ea = class extends Vt {
		constructor() {
			super(), this.ifc = null
		}
		CanImportExtension(e) {
			return e === "ifc"
		}
		GetUpDirection() {
			return ht.Y
		}
		ClearContent() {
			this.expressIDToMesh = null, this.colorToMaterial = null
		}
		ResetContent() {
			this.expressIDToMesh = new Map, this.colorToMaterial = new ti(this.model)
		}
		ImportContent(e, t) {
			this.ifc === null ? Qi("loaders/web-ifc-api-browser.js").then(() => {
				this.ifc = new WebIFC.IfcAPI, this.ifc.Init().then(() => {
					this.ImportIfcContent(e), t()
				})
			}).catch(() => {
				this.SetError("Failed to load web-ifc."), t()
			}) : (this.ImportIfcContent(e), t())
		}
		ImportIfcContent(e) {
			let t = new Uint8Array(e),
				n = this.ifc.OpenModel(t, {
					COORDINATE_TO_ORIGIN: !0
				}),
				i = this.ifc.LoadAllGeometry(n);
			for (let s = 0; s < i.size(); s++) {
				let o = i.get(s);
				o.geometries.size() > 0 && this.ImportIfcMesh(n, o)
			}
			this.ImportProperties(n), this.ifc.CloseModel(n)
		}
		ImportIfcMesh(e, t) {
			let n = new $t;
			n.SetName("Mesh " + t.expressID.toString());
			let i = 0,
				s = t.geometries;
			for (let o = 0; o < s.size(); o++) {
				let a = s.get(o),
					l = this.ifc.GetGeometry(e, a.geometryExpressID),
					c = this.ifc.GetVertexArray(l.GetVertexData(), l.GetVertexDataSize()),
					u = this.ifc.GetIndexArray(l.GetIndexData(), l.GetIndexDataSize()),
					h = this.GetMaterialIndexByColor(a.color),
					f = new ln(a.flatTransformation),
					m = new rn(f);
				for (let g = 0; g < c.length; g += 6) {
					let y = c[g],
						d = c[g + 1],
						p = c[g + 2],
						_ = new He(y, d, p),
						v = m.TransformCoord3D(_);
					n.AddVertex(v)
				}
				for (let g = 0; g < u.length; g += 3) {
					let y = u[g],
						d = u[g + 1],
						p = u[g + 2],
						_ = new Ht(i + y, i + d, i + p);
					_.SetMaterial(h), n.AddTriangle(_)
				}
				i += c.length / 6
			}
			this.expressIDToMesh.set(t.expressID, n), this.model.AddMeshToRootNode(n)
		}
		ImportProperties(e) {
			let t = this.ifc.GetLineIDsWithType(e, WebIFC.IFCRELDEFINESBYPROPERTIES);
			for (let n = 0; n < t.size(); n++) {
				let i = t.get(n),
					s = this.ifc.GetLine(e, i);
				Array.isArray(s.RelatingPropertyDefinition) || s.RelatedObjects.forEach(o => {
					let a = null;
					if (this.expressIDToMesh.has(o.value) ? a = this.expressIDToMesh.get(o.value) : this.ifc.GetLine(e, o.value, !0).type === WebIFC.IFCBUILDING && (a = this.model), a === null) return;
					let l = s.RelatingPropertyDefinition,
						c = this.ifc.GetLine(e, l.value, !0);
					if (!c || !c.HasProperties) return;
					let u = new Fn(c.Name.value);
					c.HasProperties.forEach(h => {
						if (!h || !h.Name || !h.NominalValue || !h.NominalValue.constructor || h.type !== WebIFC.IFCPROPERTYSINGLEVALUE) return;
						let f = this.GetIFCString(h.Name.value),
							m = null,
							g = null;
						switch (h.NominalValue.constructor.name) {
							case "IfcText":
							case "IfcLabel":
							case "IfcIdentifier":
							case WebIFC.IFCLABEL:
								m = new Jt(Bt.Text, f, this.GetIFCString(h.NominalValue.value));
								break;
							case "IfcBoolean":
							case "IfcLogical":
								g = "Unknown", h.NominalValue.value === "T" ? g = "True" : h.NominalValue.value === "F" && (g = "False"), m = new Jt(Bt.Text, f, g);
								break;
							case "IfcInteger":
							case "IfcCountMeasure":
								m = new Jt(Bt.Integer, f, h.NominalValue.value);
								break;
							case "IfcReal":
							case "IfcLengthMeasure":
							case "IfcPositiveLengthMeasure":
							case "IfcAreaMeasure":
							case "IfcVolumeMeasure":
							case "IfcRatioMeasure":
							case "IfcPositiveRATIOMeasure":
							case "IfcMassMeasure":
							case "IfcMassPerLengthMeasure":
							case "IfcPlaneAngleMeasure":
							case "IfcThermalTransmittanceMeasure":
								m = new Jt(Bt.Number, f, h.NominalValue.value);
								break;
							default:
								console.log(h);
								break
						}
						m !== null && u.AddProperty(m)
					}), u.PropertyCount() > 0 && a.AddPropertyGroup(u)
				})
			}
		}
		GetMaterialIndexByColor(e) {
			let t = ai(e.x, e.y, e.z),
				n = parseInt(e.w * 255, 10);
			return this.colorToMaterial.GetMaterialIndex(t.r, t.g, t.b, n)
		}
		GetIFCString(e) {
			let t = this.DecodeIFCString(e);
			return t.length === 0 && (t = "-"), t
		}
		DecodeIFCString(e) {
			let t = /\\X2\\(.*?)\\X0\\/uig,
				n = e,
				i = t.exec(e);
			for (; i;) {
				let s = String.fromCharCode(parseInt(i[1], 16));
				n = n.replace(i[0], s), i = t.exec(e)
			}
			return n
		}
	};
	var ud = class {
		constructor(e) {
			this.mesh = e, this.globalToMeshVertices = new Map, this.globalToMeshVertexColors = new Map, this.globalToMeshNormals = new Map, this.globalToMeshUvs = new Map
		}
		AddVertex(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshVertices, n => this.mesh.AddVertex(new He(n.x, n.y, n.z)))
		}
		AddVertexColor(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshVertexColors, n => this.mesh.AddVertexColor(new Et(n.r, n.g, n.b)))
		}
		AddNormal(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshNormals, n => this.mesh.AddNormal(new He(n.x, n.y, n.z)))
		}
		AddUV(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshUvs, n => this.mesh.AddTextureUV(new wt(n.x, n.y)))
		}
		AddTriangle(e) {
			this.mesh.AddTriangle(e)
		}
		GetLocalIndex(e, t, n, i) {
			if (isNaN(e) || e < 0 || e >= t.length) return null;
			if (n.has(e)) return n.get(e);
			{
				let s = t[e],
					o = i(s);
				return n.set(e, o), o
			}
		}
	};

	function ju(r, e, t) {
		return ai(parseFloat(r), parseFloat(e), parseFloat(t))
	}
	var Ma = class extends Vt {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "obj"
		}
		GetUpDirection() {
			return ht.Y
		}
		ClearContent() {
			this.globalVertices = null, this.globalVertexColors = null, this.globalNormals = null, this.globalUvs = null, this.currentMeshConverter = null, this.currentMaterial = null, this.currentMaterialIndex = null, this.meshNameToConverter = null, this.materialNameToIndex = null
		}
		ResetContent() {
			this.globalVertices = [], this.globalVertexColors = [], this.globalNormals = [], this.globalUvs = [], this.currentMeshConverter = null, this.currentMaterial = null, this.currentMaterialIndex = null, this.meshNameToConverter = new Map, this.materialNameToIndex = new Map
		}
		ImportContent(e, t) {
			let n = fn(e);
			Si(n, i => {
				this.WasError() || this.ProcessLine(i)
			}), t()
		}
		ProcessLine(e) {
			if (e[0] === "#") return;
			let t = Xi(e, "#");
			if (t.length === 0) return;
			let n = t[0].toLowerCase();
			t.shift(), !this.ProcessMeshParameter(n, t, e) && this.ProcessMaterialParameter(n, t, e)
		}
		AddNewMesh(e) {
			if (this.meshNameToConverter.has(e)) this.currentMeshConverter = this.meshNameToConverter.get(e);
			else {
				let t = new $t;
				t.SetName(e), this.model.AddMeshToRootNode(t), this.currentMeshConverter = new ud(t), this.meshNameToConverter.set(e, this.currentMeshConverter)
			}
		}
		ProcessMeshParameter(e, t, n) {
			if (e === "g" || e === "o") {
				if (t.length === 0) return !0;
				let i = Vr(n, e.length, "#");
				return this.AddNewMesh(i), !0
			} else {
				if (e === "v") return t.length < 3 || (this.globalVertices.push(new He(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]))), t.length >= 6 && this.globalVertexColors.push(ju(t[3], t[4], t[5]))), !0;
				if (e === "vn") return t.length < 3 || this.globalNormals.push(new He(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]))), !0;
				if (e === "vt") return t.length < 2 || this.globalUvs.push(new wt(parseFloat(t[0]), parseFloat(t[1]))), !0;
				if (e === "f") return t.length < 3 || this.ProcessFace(t), !0
			}
			return !1
		}
		ProcessMaterialParameter(e, t, n) {
			function i(o) {
				let a = new Map,
					l = null;
				for (let c = 0; c < o.length - 1; c++) {
					let u = o[c];
					if (u.startsWith("-")) {
						l = u, a.set(l, []);
						continue
					}
					l !== null && a.get(l).push(u)
				}
				return a
			}

			function s(o, a) {
				let l = new Jn,
					c = o[o.length - 1],
					u = a.getFileBuffer(c);
				l.name = c, l.buffer = u;
				let h = i(o);
				if (h.has("-o")) {
					let f = h.get("-o");
					f.length > 0 && (l.offset.x = parseFloat(f[0])), f.length > 1 && (l.offset.y = parseFloat(f[1]))
				}
				if (h.has("-s")) {
					let f = h.get("-s");
					f.length > 0 && (l.scale.x = parseFloat(f[0])), f.length > 1 && (l.scale.y = parseFloat(f[1]))
				}
				return l
			}
			if (e === "newmtl") {
				if (t.length === 0) return !0;
				let o = new hn,
					a = Vr(n, e.length, "#"),
					l = this.model.AddMaterial(o);
				return o.name = a, this.currentMaterial = o, this.materialNameToIndex.set(a, l), !0
			} else if (e === "usemtl") {
				if (t.length === 0) return !0;
				let o = Vr(n, e.length, "#");
				return this.materialNameToIndex.has(o) && (this.currentMaterialIndex = this.materialNameToIndex.get(o)), !0
			} else if (e === "mtllib") {
				if (t.length === 0) return !0;
				let o = Vr(n, e.length, "#"),
					a = this.callbacks.getFileBuffer(o);
				if (a !== null) {
					let l = fn(a);
					Si(l, c => {
						this.WasError() || this.ProcessLine(c)
					})
				}
				return !0
			} else {
				if (e === "map_kd") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.diffuseMap = s(t, this.callbacks), ni(this.currentMaterial)), !0;
				if (e === "map_ks") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.specularMap = s(t, this.callbacks)), !0;
				if (e === "map_bump" || e === "bump") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.bumpMap = s(t, this.callbacks)), !0;
				if (e === "ka") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.ambient = ju(t[0], t[1], t[2])), !0;
				if (e === "kd") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.color = ju(t[0], t[1], t[2])), !0;
				if (e === "ks") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.specular = ju(t[0], t[1], t[2])), !0;
				if (e === "ns") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.shininess = parseFloat(t[0]) / 1e3), !0;
				if (e === "tr") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = 1 - parseFloat(t[0]), ni(this.currentMaterial)), !0;
				if (e === "d") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = parseFloat(t[0]), ni(this.currentMaterial)), !0
			}
			return !1
		}
		ProcessFace(e) {
			function t(a, l) {
				return a > 0 ? a - 1 : l + a
			}
			let n = [],
				i = [],
				s = [],
				o = [];
			for (let a = 0; a < e.length; a++) {
				let l = e[a].split("/");
				n.push(t(parseInt(l[0], 10), this.globalVertices.length)), this.globalVertices.length === this.globalVertexColors.length && i.push(t(parseInt(l[0], 10), this.globalVertices.length)), l.length > 1 && l[1].length > 0 && o.push(t(parseInt(l[1], 10), this.globalUvs.length)), l.length > 2 && l[2].length > 0 && s.push(t(parseInt(l[2], 10), this.globalNormals.length))
			}
			this.currentMeshConverter === null && this.AddNewMesh("");
			for (let a = 0; a < n.length - 2; a++) {
				let l = this.currentMeshConverter.AddVertex(n[0], this.globalVertices),
					c = this.currentMeshConverter.AddVertex(n[a + 1], this.globalVertices),
					u = this.currentMeshConverter.AddVertex(n[a + 2], this.globalVertices);
				if (l === null || c === null || u === null) {
					this.SetError("Invalid vertex index.");
					break
				}
				let h = new Ht(l, c, u);
				if (i.length === n.length) {
					let f = this.currentMeshConverter.AddVertexColor(i[0], this.globalVertexColors),
						m = this.currentMeshConverter.AddVertexColor(i[a + 1], this.globalVertexColors),
						g = this.currentMeshConverter.AddVertexColor(i[a + 2], this.globalVertexColors);
					if (f === null || m === null || g === null) {
						this.SetError("Invalid vertex color index.");
						break
					}
					h.SetVertexColors(f, m, g)
				}
				if (s.length === n.length) {
					let f = this.currentMeshConverter.AddNormal(s[0], this.globalNormals),
						m = this.currentMeshConverter.AddNormal(s[a + 1], this.globalNormals),
						g = this.currentMeshConverter.AddNormal(s[a + 2], this.globalNormals);
					if (f === null || m === null || g === null) {
						this.SetError("Invalid normal index.");
						break
					}
					h.SetNormals(f, m, g)
				}
				if (o.length === n.length) {
					let f = this.currentMeshConverter.AddUV(o[0], this.globalUvs),
						m = this.currentMeshConverter.AddUV(o[a + 1], this.globalUvs),
						g = this.currentMeshConverter.AddUV(o[a + 2], this.globalUvs);
					if (f === null || m === null || g === null) {
						this.SetError("Invalid uv index.");
						break
					}
					h.SetTextureUVs(f, m, g)
				}
				this.currentMaterialIndex !== null && (h.mat = this.currentMaterialIndex), this.currentMeshConverter.AddTriangle(h)
			}
		}
	};
	var ba = class extends Vt {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "off"
		}
		GetUpDirection() {
			return ht.Y
		}
		ClearContent() {
			this.mesh = null, this.status = null, this.colorToMaterial = null
		}
		ResetContent() {
			this.mesh = new $t, this.model.AddMeshToRootNode(this.mesh), this.status = {
				vertexCount: 0,
				faceCount: 0,
				foundVertex: 0,
				foundFace: 0
			}, this.colorToMaterial = new ti(this.model)
		}
		ImportContent(e, t) {
			let n = fn(e);
			Si(n, i => {
				this.WasError() || this.ProcessLine(i)
			}), t()
		}
		ProcessLine(e) {
			function t(s) {
				return s.indexOf(".") !== -1 ? En(parseFloat(s)) : parseInt(s, 10)
			}
			if (e[0] === "#") return;
			let n = Xi(e, "#");
			if (n.length === 0 || n[0] === "OFF") return;
			if (this.status.vertexCount === 0 && this.status.faceCount === 0) {
				n.length > 1 && (this.status.vertexCount = parseInt(n[0], 10), this.status.faceCount = parseInt(n[1], 10));
				return
			}
			if (this.status.foundVertex < this.status.vertexCount) {
				n.length >= 3 && (this.mesh.AddVertex(new He(parseFloat(n[0]), parseFloat(n[1]), parseFloat(n[2]))), this.status.foundVertex += 1), n.length >= 6 && this.mesh.AddVertexColor(new Et(t(n[3]), t(n[4]), t(n[5])));
				return
			}
			let i = this.mesh.VertexCount() === this.mesh.VertexColorCount();
			if (this.status.foundFace < this.status.faceCount) {
				if (n.length >= 4) {
					let s = parseInt(n[0], 10);
					if (n.length < s + 1) return;
					let o = null;
					if (!i && n.length >= s + 4) {
						let a = new Et(t(n[s + 1]), t(n[s + 2]), t(n[s + 3]));
						o = this.colorToMaterial.GetMaterialIndex(a.r, a.g, a.b)
					}
					for (let a = 0; a < s - 2; a++) {
						let l = parseInt(n[1]),
							c = parseInt(n[a + 2]),
							u = parseInt(n[a + 3]),
							h = new Ht(l, c, u);
						i ? h.SetVertexColors(l, c, u) : h.SetMaterial(o), this.mesh.AddTriangle(h)
					}
					this.status.foundFace += 1
				}
				return
			}
		}
	};
	var ms = {
			Ok: 1,
			NoVertices: 2,
			NoFaces: 3,
			UnknownError: 4
		},
		hd = class {
			constructor() {
				this.format = null, this.elements = []
			}
			SetFormat(e) {
				this.format = e
			}
			AddElement(e, t) {
				this.elements.push({
					name: e,
					count: t,
					format: []
				})
			}
			GetElements() {
				return this.elements
			}
			AddSingleFormat(e, t) {
				this.elements[this.elements.length - 1].format.push({
					name: t,
					isSingle: !0,
					elemType: e
				})
			}
			AddListFormat(e, t, n) {
				this.elements[this.elements.length - 1].format.push({
					name: n,
					isSingle: !1,
					countType: e,
					elemType: t
				})
			}
			GetElement(e) {
				for (let t = 0; t < this.elements.length; t++) {
					let n = this.elements[t];
					if (n.name === e) return n
				}
				return null
			}
			Check() {
				let e = this.GetElement("vertex");
				if (e === null || e.length === 0 || e.format.length < 3) return ms.NoVertices;
				let t = this.GetElement("face");
				if (this.format === "ascii") {
					if (t === null || t.count === 0 || t.format.length < 0) return ms.NoFaces
				} else if (this.format === "binary_little_endian" || this.format === "binary_big_endian") {
					let n = this.GetElement("tristrips"),
						i = t !== null && t.count > 0 && t.format.length > 0,
						s = n !== null && n.count > 0 && n.format.length > 0;
					if (!i && !s) return ms.NoFaces
				} else return ms.UnknownError;
				return ms.Ok
			}
		},
		fd = class {
			constructor(e) {
				this.model = e, this.colorToMaterial = new Map
			}
			GetMaterialIndexByColor(e) {
				let t = "Color " + xn(e[0]) + xn(e[1]) + xn(e[2]) + xn(e[3]);
				if (this.colorToMaterial.has(t)) return this.colorToMaterial.get(t);
				{
					let n = new hn;
					n.name = t, n.color = new Et(e[0], e[1], e[2]), n.opacity = e[3] / 255, ni(n);
					let i = this.model.AddMaterial(n);
					return this.colorToMaterial.set(t, i), i
				}
			}
		},
		Sa = class extends Vt {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "ply"
			}
			GetUpDirection() {
				return ht.Y
			}
			ClearContent() {
				this.mesh = null
			}
			ResetContent() {
				this.mesh = new $t, this.model.AddMeshToRootNode(this.mesh)
			}
			ImportContent(e, t) {
				let n = this.GetHeaderContent(e),
					i = this.ReadHeader(n),
					s = i.Check();
				if (s === ms.Ok)
					if (i.format === "ascii") {
						let o = fn(e);
						o = o.substring(n.length), this.ReadAsciiContent(i, o)
					} else(i.format === "binary_little_endian" || i.format === "binary_big_endian") && this.ReadBinaryContent(i, e, n.length);
				else s === ms.NoVertices ? this.SetError("The model contains no vertices.") : s === ms.NoFaces ? this.SetError("The model contains no faces.") : this.SetError("Invalid header information.");
				t()
			}
			GetHeaderContent(e) {
				let t = "",
					n = new Uint8Array(e),
					i = 0;
				for (i = 0; i < e.byteLength && (t += String.fromCharCode(n[i]), !t.endsWith("end_header")); i++);
				for (i += 1; i < e.byteLength;) {
					let s = String.fromCharCode(n[i]);
					if (t += s, i += 1, s === `
`) break
				}
				return t
			}
			ReadHeader(e) {
				let t = new hd;
				return Si(e, n => {
					let i = Xi(n, null);
					i.length === 0 || i[0] === "comment" || i[0] !== "ply" && (i[0] === "format" && i.length >= 2 ? t.SetFormat(i[1]) : i[0] === "element" && i.length >= 3 ? t.AddElement(i[1], parseInt(i[2], 10)) : i[0] === "property" && i.length >= 3 && (i[1] === "list" && i.length >= 5 ? t.AddListFormat(i[2], i[3], i[4]) : t.AddSingleFormat(i[1], i[2])))
				}), t
			}
			ReadAsciiContent(e, t) {
				let n = e.GetElement("vertex"),
					i = e.GetElement("face"),
					s = 0,
					o = 0;
				Si(t, a => {
					if (this.WasError()) return;
					let l = Xi(a, null);
					if (!(l.length === 0 || l[0] === "comment")) {
						if (s < n.count) {
							l.length >= 3 && (this.mesh.AddVertex(new He(parseFloat(l[0]), parseFloat(l[1]), parseFloat(l[2]))), s += 1);
							return
						}
						if (i !== null && o < i.count) {
							if (l.length >= 4) {
								let c = parseInt(l[0], 10);
								if (l.length < c + 1) return;
								for (let u = 0; u < c - 2; u++) {
									let h = parseInt(l[1]),
										f = parseInt(l[u + 2]),
										m = parseInt(l[u + 3]),
										g = new Ht(h, f, m);
									this.mesh.AddTriangle(g)
								}
								o += 1
							}
							return
						}
					}
				})
			}
			ReadBinaryContent(e, t, n) {
				function i(u, h) {
					function f(m, g) {
						return g === "char" || g === "int8" ? m.ReadCharacter8() : g === "uchar" || g === "uint8" ? m.ReadUnsignedCharacter8() : g === "short" || g === "int16" ? m.ReadInteger16() : g === "ushort" || g === "uint16" ? m.ReadUnsignedInteger16() : g === "int" || g === "int32" ? m.ReadInteger32() : g === "uint" || g === "uint32" ? m.ReadUnsignedInteger32() : g === "float" || g === "float32" ? m.ReadFloat32() : g === "double" || g === "double64" ? m.ReadDouble64() : null
					}
					if (h.isSingle) return f(u, h.elemType);
					{
						let m = [],
							g = f(u, h.countType);
						for (let y = 0; y < g; y++) m.push(f(u, h.elemType));
						return m
					}
				}

				function s(u, h, f) {
					for (let m = f; m < h.length; m++) i(u, h[m])
				}

				function o(u, h, f) {
					let m = null,
						g = null,
						y = null,
						d = 255;
					for (let p = f; p < h.length; p++) {
						let _ = h[p],
							v = i(u, _);
						_.name === "red" ? m = v : _.name === "green" ? g = v : _.name === "blue" ? y = v : _.name === "alpha" && (d = v)
					}
					return m !== null && g !== null && y !== null ? [m, g, y, d] : null
				}
				let a = null;
				if (e.format === "binary_little_endian") a = new Yn(t, !0);
				else if (e.format === "binary_big_endian") a = new Yn(t, !1);
				else return;
				a.Skip(n);
				let l = new fd(this.model),
					c = e.GetElements();
				for (let u = 0; u < c.length; u++) {
					let h = c[u];
					if (h.name === "vertex")
						for (let f = 0; f < h.count; f++) {
							let m = i(a, h.format[0]),
								g = i(a, h.format[1]),
								y = i(a, h.format[2]),
								d = o(a, h.format, 3);
							d !== null && this.mesh.AddVertexColor(new Et(d[0], d[1], d[2])), this.mesh.AddVertex(new He(m, g, y))
						} else if (h.name === "face")
							for (let f = 0; f < h.count; f++) {
								let m = i(a, h.format[0]),
									g = o(a, h.format, 1);
								for (let y = 0; y < m.length - 2; y++) {
									let d = m[0],
										p = m[y + 1],
										_ = m[y + 2],
										v = new Ht(d, p, _);
									g !== null ? v.mat = l.GetMaterialIndexByColor(g) : this.mesh.VertexColorCount() > 0 && v.SetVertexColors(d, p, _), this.mesh.AddTriangle(v)
								}
							} else if (h.name === "tristrips")
								for (let f = 0; f < h.count; f++) {
									let m = i(a, h.format[0]);
									s(a, h.format, 1);
									let g = !0;
									for (let y = 0; y < m.length - 2; y++) {
										let d = m[y],
											p = m[y + 1],
											_ = m[y + 2];
										if (_ === -1) {
											y += 2, g = !0;
											continue
										}
										if (!g) {
											let x = p;
											p = _, _ = x
										}
										g = !g;
										let v = new Ht(d, p, _);
										this.mesh.AddTriangle(v)
									}
								} else s(a, h.format, 0)
				}
			}
		};
	var Aa = class extends Vt {
		constructor() {
			super(), this.worker = null
		}
		CanImportExtension(e) {
			return e === "stp" || e === "step" || e === "igs" || e === "iges" || e === "brp" || e === "brep"
		}
		GetUpDirection() {
			return ht.Y
		}
		ClearContent() {
			this.worker !== null && (this.worker.terminate(), this.worker = null)
		}
		ResetContent() {
			this.worker = null
		}
		ImportContent(e, t) {
			let n = Es("loaders/occt-import-js-worker.js");
			this.worker = new Worker(n), this.worker.addEventListener("message", a => {
				this.ImportResultJson(a.data, t)
			}), this.worker.addEventListener("error", a => {
				this.SetError("Failed to load occt-import-js."), t()
			});
			let i = null;
			if (this.extension === "stp" || this.extension === "step") i = "step";
			else if (this.extension === "igs" || this.extension === "iges") i = "iges";
			else if (this.extension === "brp" || this.extension === "brep") i = "brep";
			else {
				t();
				return
			}(i === "step" || i === "iges") && this.model.SetUnit(Zr.Millimeter);
			let s = {
					linearUnit: "millimeter",
					linearDeflectionType: "bounding_box_ratio",
					linearDeflection: .001,
					angularDeflection: .5
				},
				o = new Uint8Array(e);
			this.worker.postMessage({
				format: i,
				buffer: o,
				params: s
			})
		}
		ImportResultJson(e, t) {
			if (!e.success) {
				t();
				return
			}
			let n = new ti(this.model),
				i = this.model.GetRootNode();
			this.ImportNode(e, e.root, i, n), t()
		}
		ImportNode(e, t, n, i) {
			for (let s of t.meshes) {
				let o = e.meshes[s],
					a = this.ImportMesh(o, i),
					l = this.model.AddMesh(a);
				n.AddMeshIndex(l)
			}
			for (let s of t.children) {
				let o = new Sn;
				o.SetName(s.name), n.AddChildNode(o), this.ImportNode(e, s, o, i)
			}
		}
		ImportMesh(e, t) {
			let n = null;
			if (e.color) {
				let s = ai(e.color[0], e.color[1], e.color[2]);
				n = t.GetMaterialIndex(s.r, s.g, s.b, null)
			}
			let i = Wi(e, n, null);
			e.name && i.SetName(e.name);
			for (let s of e.brep_faces) {
				if (s.color === null) continue;
				let o = ai(s.color[0], s.color[1], s.color[2]),
					a = t.GetMaterialIndex(o.r, o.g, o.b, null);
				for (let l = s.first; l <= s.last; l++) i.GetTriangle(l).SetMaterial(a)
			}
			return i
		}
	};
	var wa = class extends Vt {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "stl"
		}
		GetUpDirection() {
			return ht.Z
		}
		ClearContent() {
			this.mesh = null, this.triangle = null
		}
		ResetContent() {
			this.mesh = new $t, this.model.AddMeshToRootNode(this.mesh), this.triangle = null
		}
		ImportContent(e, t) {
			if (this.IsBinaryStlFile(e)) this.ProcessBinary(e);
			else {
				let n = fn(e);
				Si(n, i => {
					this.WasError() || this.ProcessLine(i)
				})
			}
			t()
		}
		IsBinaryStlFile(e) {
			let t = e.byteLength;
			if (t < 84) return !1;
			let n = new Yn(e, !0);
			n.Skip(80);
			let i = n.ReadUnsignedInteger32();
			return t === i * 50 + 84
		}
		ProcessLine(e) {
			if (e[0] === "#") return;
			let t = Xi(e, "#");
			if (t.length === 0) return;
			let n = t[0];
			if (n === "solid") {
				if (t.length > 1) {
					let i = Vr(e, n.length, "#");
					this.mesh.SetName(i)
				}
				return
			}
			if (n === "facet") {
				if (this.triangle = new Ht(-1, -1, -1), t.length >= 5 && t[1] === "normal") {
					let i = new He(parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4]));
					if (gi(i.Length())) {
						let s = this.mesh.AddNormal(i);
						this.triangle.SetNormals(s, s, s)
					}
				}
				return
			}
			if (n === "vertex" && this.triangle !== null) {
				if (t.length >= 4) {
					let i = this.mesh.AddVertex(new He(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])));
					this.triangle.v0 === -1 ? this.triangle.v0 = i : this.triangle.v1 === -1 ? this.triangle.v1 = i : this.triangle.v2 === -1 && (this.triangle.v2 = i)
				}
				return
			}
			if (n === "endfacet" && this.triangle !== null) {
				this.triangle.v0 !== -1 && this.triangle.v1 !== -1 && this.triangle.v2 !== null && this.mesh.AddTriangle(this.triangle), this.triangle = null;
				return
			}
		}
		ProcessBinary(e) {
			function t(o) {
				let a = new He;
				return a.x = o.ReadFloat32(), a.y = o.ReadFloat32(), a.z = o.ReadFloat32(), a
			}

			function n(o, a) {
				let l = t(a);
				return o.AddVertex(l)
			}
			let i = new Yn(e, !0);
			i.Skip(80);
			let s = i.ReadUnsignedInteger32();
			for (let o = 0; o < s; o++) {
				let a = t(i),
					l = n(this.mesh, i),
					c = n(this.mesh, i),
					u = n(this.mesh, i);
				i.Skip(2);
				let h = new Ht(l, c, u);
				if (gi(a.Length())) {
					let f = this.mesh.AddNormal(a);
					h.SetNormals(f, f, f)
				}
				this.mesh.AddTriangle(h)
			}
		}
	};
	var Ca = class extends Vt {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "bim"
		}
		GetUpDirection() {
			return ht.Z
		}
		ClearContent() {
			this.meshIdToMesh = null, this.colorToMaterial = null
		}
		ResetContent() {
			this.meshIdToMesh = new Map, this.colorToMaterial = new ti(this.model)
		}
		ImportContent(e, t) {
			this.model.SetUnit(Zr.Meter);
			let n = fn(e),
				i = null;
			try {
				i = JSON.parse(n)
			} catch {
				this.SetError("Failed to parse bim file."), t();
				return
			}
			for (let s of i.meshes) this.meshIdToMesh.set(s.mesh_id, s);
			this.ImportProperties(i, this.model);
			for (let s of i.elements) {
				let o = this.ImportElement(s);
				o.SetName(s.type), this.ImportProperties(s, o)
			}
			t()
		}
		ImportElement(e) {
			let t = this.colorToMaterial.GetMaterialIndex(e.color.r, e.color.g, e.color.b, e.color.a),
				n = this.model.GetRootNode(),
				i = this.meshIdToMesh.get(e.mesh_id),
				s = this.ImportMesh(i, f => e.face_colors ? this.colorToMaterial.GetMaterialIndex(e.face_colors[f * 4 + 0], e.face_colors[f * 4 + 1], e.face_colors[f * 4 + 2], e.face_colors[f * 4 + 3]) : t),
				o = this.model.AddMesh(s),
				a = new Sn;
			a.AddMeshIndex(o);
			let l = new He(0, 0, 0);
			e.vector && (l = new He(e.vector.x, e.vector.y, e.vector.z));
			let c = new Xn(0, 0, 0, 1);
			e.rotation && (c = new Xn(e.rotation.qx, e.rotation.qy, e.rotation.qz, e.rotation.qw));
			let u = new He(1, 1, 1),
				h = new ln().ComposeTRS(l, c, u);
			return a.SetTransformation(new rn(h)), n.AddChildNode(a), s
		}
		ImportMesh(e, t) {
			let n = new $t;
			for (let i = 0; i < e.coordinates.length; i += 3) n.AddVertex(new He(e.coordinates[i + 0], e.coordinates[i + 1], e.coordinates[i + 2]));
			for (let i = 0; i < e.indices.length; i += 3) {
				let s = new Ht(e.indices[i + 0], e.indices[i + 1], e.indices[i + 2]);
				s.SetMaterial(t(i / 3)), n.AddTriangle(s)
			}
			return n
		}
		ImportProperties(e, t) {
			function n(o, a, l) {
				if (l == null) return;
				let c = new Jt(Bt.Text, a, l);
				o.AddProperty(c)
			}
			if (!e.info || mc(e.info)) return;
			let i = e.info,
				s = new Fn("Info");
			n(s, "Guid", e.guid), n(s, "Type", e.type);
			for (let o in i) Object.prototype.hasOwnProperty.call(i, o) && typeof i[o] == "string" && n(s, o, i[o]);
			t.AddPropertyGroup(s)
		}
	};
	var gs = class extends Du {
		constructor(e) {
			super(e)
		}
		parse(e) {
			function t(Z) {
				switch (Z.image_type) {
					case f:
					case y:
						(Z.colormap_length > 256 || Z.colormap_size !== 24 || Z.colormap_type !== 1) && console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");
						break;
					case m:
					case g:
					case d:
					case p:
						Z.colormap_type && console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");
						break;
					case h:
						console.error("THREE.TGALoader: No data.");
					default:
						console.error('THREE.TGALoader: Invalid type "%s".', Z.image_type)
				}(Z.width <= 0 || Z.height <= 0) && console.error("THREE.TGALoader: Invalid image size."), Z.pixel_size !== 8 && Z.pixel_size !== 16 && Z.pixel_size !== 24 && Z.pixel_size !== 32 && console.error('THREE.TGALoader: Invalid pixel size "%s".', Z.pixel_size)
			}

			function n(Z, Y, H, oe, de) {
				let te, fe, me = H.pixel_size >> 3,
					P = H.width * H.height * me;
				if (Y && (fe = de.subarray(oe, oe += H.colormap_length * (H.colormap_size >> 3))), Z) {
					te = new Uint8Array(P);
					let b, S, A, G = 0,
						J = new Uint8Array(me);
					for (; G < P;)
						if (b = de[oe++], S = (b & 127) + 1, b & 128) {
							for (A = 0; A < me; ++A) J[A] = de[oe++];
							for (A = 0; A < S; ++A) te.set(J, G + A * me);
							G += me * S
						} else {
							for (S *= me, A = 0; A < S; ++A) te[G + A] = de[oe++];
							G += S
						}
				} else te = de.subarray(oe, oe += Y ? H.width * H.height : P);
				return {
					pixel_data: te,
					palettes: fe
				}
			}

			function i(Z, Y, H, oe, de, te, fe, me, P) {
				let b = P,
					S, A = 0,
					G, J, $ = C.width;
				for (J = Y; J !== oe; J += H)
					for (G = de; G !== fe; G += te, A++) S = me[A], Z[(G + $ * J) * 4 + 3] = 255, Z[(G + $ * J) * 4 + 2] = b[S * 3 + 0], Z[(G + $ * J) * 4 + 1] = b[S * 3 + 1], Z[(G + $ * J) * 4 + 0] = b[S * 3 + 2];
				return Z
			}

			function s(Z, Y, H, oe, de, te, fe, me) {
				let P, b = 0,
					S, A, G = C.width;
				for (A = Y; A !== oe; A += H)
					for (S = de; S !== fe; S += te, b += 2) P = me[b + 0] + (me[b + 1] << 8), Z[(S + G * A) * 4 + 0] = (P & 31744) >> 7, Z[(S + G * A) * 4 + 1] = (P & 992) >> 2, Z[(S + G * A) * 4 + 2] = (P & 31) << 3, Z[(S + G * A) * 4 + 3] = P & 32768 ? 0 : 255;
				return Z
			}

			function o(Z, Y, H, oe, de, te, fe, me) {
				let P = 0,
					b, S, A = C.width;
				for (S = Y; S !== oe; S += H)
					for (b = de; b !== fe; b += te, P += 3) Z[(b + A * S) * 4 + 3] = 255, Z[(b + A * S) * 4 + 2] = me[P + 0], Z[(b + A * S) * 4 + 1] = me[P + 1], Z[(b + A * S) * 4 + 0] = me[P + 2];
				return Z
			}

			function a(Z, Y, H, oe, de, te, fe, me) {
				let P = 0,
					b, S, A = C.width;
				for (S = Y; S !== oe; S += H)
					for (b = de; b !== fe; b += te, P += 4) Z[(b + A * S) * 4 + 2] = me[P + 0], Z[(b + A * S) * 4 + 1] = me[P + 1], Z[(b + A * S) * 4 + 0] = me[P + 2], Z[(b + A * S) * 4 + 3] = me[P + 3];
				return Z
			}

			function l(Z, Y, H, oe, de, te, fe, me) {
				let P, b = 0,
					S, A, G = C.width;
				for (A = Y; A !== oe; A += H)
					for (S = de; S !== fe; S += te, b++) P = me[b], Z[(S + G * A) * 4 + 0] = P, Z[(S + G * A) * 4 + 1] = P, Z[(S + G * A) * 4 + 2] = P, Z[(S + G * A) * 4 + 3] = 255;
				return Z
			}

			function c(Z, Y, H, oe, de, te, fe, me) {
				let P = 0,
					b, S, A = C.width;
				for (S = Y; S !== oe; S += H)
					for (b = de; b !== fe; b += te, P += 2) Z[(b + A * S) * 4 + 0] = me[P + 0], Z[(b + A * S) * 4 + 1] = me[P + 0], Z[(b + A * S) * 4 + 2] = me[P + 0], Z[(b + A * S) * 4 + 3] = me[P + 1];
				return Z
			}

			function u(Z, Y, H, oe, de) {
				let te, fe, me, P, b, S;
				switch ((C.flags & _) >> v) {
					default:
					case I:
						te = 0, me = 1, b = Y, fe = 0, P = 1, S = H;
						break;
					case x:
						te = 0, me = 1, b = Y, fe = H - 1, P = -1, S = -1;
						break;
					case w:
						te = Y - 1, me = -1, b = -1, fe = 0, P = 1, S = H;
						break;
					case M:
						te = Y - 1, me = -1, b = -1, fe = H - 1, P = -1, S = -1;
						break
				}
				if (F) switch (C.pixel_size) {
					case 8:
						l(Z, fe, P, S, te, me, b, oe);
						break;
					case 16:
						c(Z, fe, P, S, te, me, b, oe);
						break;
					default:
						console.error("THREE.TGALoader: Format not supported.");
						break
				} else switch (C.pixel_size) {
					case 8:
						i(Z, fe, P, S, te, me, b, oe, de);
						break;
					case 16:
						s(Z, fe, P, S, te, me, b, oe);
						break;
					case 24:
						o(Z, fe, P, S, te, me, b, oe);
						break;
					case 32:
						a(Z, fe, P, S, te, me, b, oe);
						break;
					default:
						console.error("THREE.TGALoader: Format not supported.");
						break
				}
				return Z
			}
			let h = 0,
				f = 1,
				m = 2,
				g = 3,
				y = 9,
				d = 10,
				p = 11,
				_ = 48,
				v = 4,
				x = 0,
				M = 1,
				I = 2,
				w = 3;
			e.length < 19 && console.error("THREE.TGALoader: Not enough data to contain header.");
			let L = 0,
				T = new Uint8Array(e),
				C = {
					id_length: T[L++],
					colormap_type: T[L++],
					image_type: T[L++],
					colormap_index: T[L++] | T[L++] << 8,
					colormap_length: T[L++] | T[L++] << 8,
					colormap_size: T[L++],
					origin: [T[L++] | T[L++] << 8, T[L++] | T[L++] << 8],
					width: T[L++] | T[L++] << 8,
					height: T[L++] | T[L++] << 8,
					pixel_size: T[L++],
					flags: T[L++]
				};
			t(C), C.id_length + L > e.length && console.error("THREE.TGALoader: No data."), L += C.id_length;
			let V = !1,
				k = !1,
				F = !1;
			switch (C.image_type) {
				case y:
					V = !0, k = !0;
					break;
				case f:
					k = !0;
					break;
				case d:
					V = !0;
					break;
				case m:
					break;
				case p:
					V = !0, F = !0;
					break;
				case g:
					F = !0;
					break
			}
			let U = new Uint8Array(C.width * C.height * 4),
				K = n(V, k, C, L, T);
			return u(U, C.width, C.height, K.pixel_data, K.palettes), {
				data: U,
				width: C.width,
				height: C.height,
				flipY: !0,
				generateMipmaps: !0,
				minFilter: ki
			}
		}
	};
	var Xg = function(r) {
			return URL.createObjectURL(new Blob([r], {
				type: "text/javascript"
			}))
		},
		XM = function(r) {
			return new Worker(r)
		};
	try {
		URL.revokeObjectURL(Xg(""))
	} catch {
		Xg = function(e) {
			return "data:application/javascript;charset=UTF-8," + encodeURI(e)
		}, XM = function(e) {
			return new Worker(e, {
				type: "module"
			})
		}
	}
	var di = Uint8Array,
		ys = Uint16Array,
		gd = Uint32Array,
		qg = new di([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
		jg = new di([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
		qM = new di([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
		Yg = function(r, e) {
			for (var t = new ys(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
			for (var i = new gd(t[30]), n = 1; n < 30; ++n)
				for (var s = t[n]; s < t[n + 1]; ++s) i[s] = s - t[n] << 5 | n;
			return [t, i]
		},
		Kg = Yg(qg, 2),
		Zg = Kg[0],
		jM = Kg[1];
	Zg[28] = 258, jM[258] = 28;
	var Jg = Yg(jg, 0),
		YM = Jg[0],
		fR = Jg[1],
		yd = new ys(32768);
	for (Dt = 0; Dt < 32768; ++Dt) zr = (Dt & 43690) >>> 1 | (Dt & 21845) << 1, zr = (zr & 52428) >>> 2 | (zr & 13107) << 2, zr = (zr & 61680) >>> 4 | (zr & 3855) << 4, yd[Dt] = ((zr & 65280) >>> 8 | (zr & 255) << 8) >>> 1;
	var zr, Dt, Hl = function(r, e, t) {
			for (var n = r.length, i = 0, s = new ys(e); i < n; ++i) ++s[r[i] - 1];
			var o = new ys(e);
			for (i = 0; i < e; ++i) o[i] = o[i - 1] + s[i - 1] << 1;
			var a;
			if (t) {
				a = new ys(1 << e);
				var l = 15 - e;
				for (i = 0; i < n; ++i)
					if (r[i])
						for (var c = i << 4 | r[i], u = e - r[i], h = o[r[i] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h) a[yd[h] >>> l] = c
			} else
				for (a = new ys(n), i = 0; i < n; ++i) r[i] && (a[i] = yd[o[r[i] - 1]++] >>> 15 - r[i]);
			return a
		},
		Wl = new di(288);
	for (Dt = 0; Dt < 144; ++Dt) Wl[Dt] = 8;
	var Dt;
	for (Dt = 144; Dt < 256; ++Dt) Wl[Dt] = 9;
	var Dt;
	for (Dt = 256; Dt < 280; ++Dt) Wl[Dt] = 7;
	var Dt;
	for (Dt = 280; Dt < 288; ++Dt) Wl[Dt] = 8;
	var Dt, $g = new di(32);
	for (Dt = 0; Dt < 32; ++Dt) $g[Dt] = 5;
	var Dt;
	var KM = Hl(Wl, 9, 1);
	var ZM = Hl($g, 5, 1),
		dd = function(r) {
			for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
			return e
		},
		ji = function(r, e, t) {
			var n = e / 8 | 0;
			return (r[n] | r[n + 1] << 8) >> (e & 7) & t
		},
		pd = function(r, e) {
			var t = e / 8 | 0;
			return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
		},
		JM = function(r) {
			return (r / 8 | 0) + (r & 7 && 1)
		},
		xd = function(r, e, t) {
			(e == null || e < 0) && (e = 0), (t == null || t > r.length) && (t = r.length);
			var n = new(r instanceof ys ? ys : r instanceof gd ? gd : di)(t - e);
			return n.set(r.subarray(e, t)), n
		},
		Qg = function(r, e, t) {
			var n = r.length;
			if (!n || t && !t.l && n < 5) return e || new di(0);
			var i = !e || t,
				s = !t || t.i;
			t || (t = {}), e || (e = new di(n * 3));
			var o = function(S) {
					var A = e.length;
					if (S > A) {
						var G = new di(Math.max(A * 2, S));
						G.set(e), e = G
					}
				},
				a = t.f || 0,
				l = t.p || 0,
				c = t.b || 0,
				u = t.l,
				h = t.d,
				f = t.m,
				m = t.n,
				g = n * 8;
			do {
				if (!u) {
					t.f = a = ji(r, l, 1);
					var y = ji(r, l + 1, 3);
					if (l += 3, y)
						if (y == 1) u = KM, h = ZM, f = 9, m = 5;
						else if (y == 2) {
						var v = ji(r, l, 31) + 257,
							x = ji(r, l + 10, 15) + 4,
							M = v + ji(r, l + 5, 31) + 1;
						l += 14;
						for (var I = new di(M), w = new di(19), L = 0; L < x; ++L) w[qM[L]] = ji(r, l + L * 3, 7);
						l += x * 3;
						for (var T = dd(w), C = (1 << T) - 1, V = Hl(w, T, 1), L = 0; L < M;) {
							var k = V[ji(r, l, C)];
							l += k & 15;
							var d = k >>> 4;
							if (d < 16) I[L++] = d;
							else {
								var F = 0,
									U = 0;
								for (d == 16 ? (U = 3 + ji(r, l, 3), l += 2, F = I[L - 1]) : d == 17 ? (U = 3 + ji(r, l, 7), l += 3) : d == 18 && (U = 11 + ji(r, l, 127), l += 7); U--;) I[L++] = F
							}
						}
						var K = I.subarray(0, v),
							Z = I.subarray(v);
						f = dd(K), m = dd(Z), u = Hl(K, f, 1), h = Hl(Z, m, 1)
					} else throw "invalid block type";
					else {
						var d = JM(l) + 4,
							p = r[d - 4] | r[d - 3] << 8,
							_ = d + p;
						if (_ > n) {
							if (s) throw "unexpected EOF";
							break
						}
						i && o(c + p), e.set(r.subarray(d, _), c), t.b = c += p, t.p = l = _ * 8;
						continue
					}
					if (l > g) {
						if (s) throw "unexpected EOF";
						break
					}
				}
				i && o(c + 131072);
				for (var Y = (1 << f) - 1, H = (1 << m) - 1, oe = l;; oe = l) {
					var F = u[pd(r, l) & Y],
						de = F >>> 4;
					if (l += F & 15, l > g) {
						if (s) throw "unexpected EOF";
						break
					}
					if (!F) throw "invalid length/literal";
					if (de < 256) e[c++] = de;
					else if (de == 256) {
						oe = l, u = null;
						break
					} else {
						var te = de - 254;
						if (de > 264) {
							var L = de - 257,
								fe = qg[L];
							te = ji(r, l, (1 << fe) - 1) + Zg[L], l += fe
						}
						var me = h[pd(r, l) & H],
							P = me >>> 4;
						if (!me) throw "invalid distance";
						l += me & 15;
						var Z = YM[P];
						if (P > 3) {
							var fe = jg[P];
							Z += pd(r, l) & (1 << fe) - 1, l += fe
						}
						if (l > g) {
							if (s) throw "unexpected EOF";
							break
						}
						i && o(c + 131072);
						for (var b = c + te; c < b; c += 4) e[c] = e[c - Z], e[c + 1] = e[c + 1 - Z], e[c + 2] = e[c + 2 - Z], e[c + 3] = e[c + 3 - Z];
						c = b
					}
				}
				t.l = u, t.p = oe, t.b = c, u && (a = 1, t.m = f, t.d = h, t.n = m)
			} while (!a);
			return c == e.length ? e : xd(e, 0, c)
		};
	var $M = new di(0);
	var pr = function(r, e) {
			return r[e] | r[e + 1] << 8
		},
		Yi = function(r, e) {
			return (r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24) >>> 0
		},
		md = function(r, e) {
			return Yi(r, e) + Yi(r, e + 4) * 4294967296
		};
	var QM = function(r) {
		if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31) throw "invalid zlib data";
		if (r[1] & 32) throw "invalid zlib data: preset dictionaries not supported"
	};

	function eb(r, e) {
		return Qg(r, e)
	}

	function e0(r, e) {
		return Qg((QM(r), r.subarray(2, -4)), e)
	}
	var vd = typeof TextDecoder < "u" && new TextDecoder,
		tb = 0;
	try {
		vd.decode($M, {
			stream: !0
		}), tb = 1
	} catch {}
	var nb = function(r) {
		for (var e = "", t = 0;;) {
			var n = r[t++],
				i = (n > 127) + (n > 223) + (n > 239);
			if (t + i > r.length) return [e, xd(r, t - 1)];
			i ? i == 3 ? (n = ((n & 15) << 18 | (r[t++] & 63) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) - 65536, e += String.fromCharCode(55296 | n >> 10, 56320 | n & 1023)) : i & 1 ? e += String.fromCharCode((n & 31) << 6 | r[t++] & 63) : e += String.fromCharCode((n & 15) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) : e += String.fromCharCode(n)
		}
	};

	function ib(r, e) {
		if (e) {
			for (var t = "", n = 0; n < r.length; n += 16384) t += String.fromCharCode.apply(null, r.subarray(n, n + 16384));
			return t
		} else {
			if (vd) return vd.decode(r);
			var i = nb(r),
				s = i[0],
				o = i[1];
			if (o.length) throw "invalid utf-8 data";
			return s
		}
	}
	var rb = function(r, e) {
			return e + 30 + pr(r, e + 26) + pr(r, e + 28)
		},
		sb = function(r, e, t) {
			var n = pr(r, e + 28),
				i = ib(r.subarray(e + 46, e + 46 + n), !(pr(r, e + 8) & 2048)),
				s = e + 46 + n,
				o = Yi(r, e + 20),
				a = t && o == 4294967295 ? ob(r, s) : [o, Yi(r, e + 24), Yi(r, e + 42)],
				l = a[0],
				c = a[1],
				u = a[2];
			return [pr(r, e + 10), l, c, i, s + pr(r, e + 30) + pr(r, e + 32), u]
		},
		ob = function(r, e) {
			for (; pr(r, e) != 1; e += 4 + pr(r, e + 2));
			return [md(r, e + 12), md(r, e + 4), md(r, e + 20)]
		};

	function Yu(r) {
		for (var e = {}, t = r.length - 22; Yi(r, t) != 101010256; --t)
			if (!t || r.length - t > 65558) throw "invalid zip file";
		var n = pr(r, t + 8);
		if (!n) return {};
		var i = Yi(r, t + 16),
			s = i == 4294967295;
		if (s) {
			if (t = Yi(r, t - 12), Yi(r, t) != 101075792) throw "invalid zip file";
			n = Yi(r, t + 32), i = Yi(r, t + 48)
		}
		for (var o = 0; o < n; ++o) {
			var a = sb(r, i, s),
				l = a[0],
				c = a[1],
				u = a[2],
				h = a[3],
				f = a[4],
				m = a[5],
				g = rb(r, m);
			if (i = f, !l) e[h] = xd(r, g, g + c);
			else if (l == 8) e[h] = eb(r.subarray(g, g + c), new di(u));
			else throw "unknown compression type " + l
		}
		return e
	}

	function t0(r, e, t) {
		let n = t.length - r - 1;
		if (e >= t[n]) return n - 1;
		if (e <= t[r]) return r;
		let i = r,
			s = n,
			o = Math.floor((i + s) / 2);
		for (; e < t[o] || e >= t[o + 1];) e < t[o] ? s = o : i = o, o = Math.floor((i + s) / 2);
		return o
	}

	function ab(r, e, t, n) {
		let i = [],
			s = [],
			o = [];
		i[0] = 1;
		for (let a = 1; a <= t; ++a) {
			s[a] = e - n[r + 1 - a], o[a] = n[r + a] - e;
			let l = 0;
			for (let c = 0; c < a; ++c) {
				let u = o[c + 1],
					h = s[a - c],
					f = i[c] / (u + h);
				i[c] = l + u * f, l = h * f
			}
			i[a] = l
		}
		return i
	}

	function n0(r, e, t, n) {
		let i = t0(r, n, e),
			s = ab(i, n, r, e),
			o = new Ct(0, 0, 0, 0);
		for (let a = 0; a <= r; ++a) {
			let l = t[i - r + a],
				c = s[a],
				u = l.w * c;
			o.x += l.x * u, o.y += l.y * u, o.z += l.z * u, o.w += l.w * c
		}
		return o
	}

	function lb(r, e, t, n, i) {
		let s = [];
		for (let h = 0; h <= t; ++h) s[h] = 0;
		let o = [];
		for (let h = 0; h <= n; ++h) o[h] = s.slice(0);
		let a = [];
		for (let h = 0; h <= t; ++h) a[h] = s.slice(0);
		a[0][0] = 1;
		let l = s.slice(0),
			c = s.slice(0);
		for (let h = 1; h <= t; ++h) {
			l[h] = e - i[r + 1 - h], c[h] = i[r + h] - e;
			let f = 0;
			for (let m = 0; m < h; ++m) {
				let g = c[m + 1],
					y = l[h - m];
				a[h][m] = g + y;
				let d = a[m][h - 1] / a[h][m];
				a[m][h] = f + g * d, f = y * d
			}
			a[h][h] = f
		}
		for (let h = 0; h <= t; ++h) o[0][h] = a[h][t];
		for (let h = 0; h <= t; ++h) {
			let f = 0,
				m = 1,
				g = [];
			for (let y = 0; y <= t; ++y) g[y] = s.slice(0);
			g[0][0] = 1;
			for (let y = 1; y <= n; ++y) {
				let d = 0,
					p = h - y,
					_ = t - y;
				h >= y && (g[m][0] = g[f][0] / a[_ + 1][p], d = g[m][0] * a[p][_]);
				let v = p >= -1 ? 1 : -p,
					x = h - 1 <= _ ? y - 1 : t - h;
				for (let I = v; I <= x; ++I) g[m][I] = (g[f][I] - g[f][I - 1]) / a[_ + 1][p + I], d += g[m][I] * a[p + I][_];
				h <= _ && (g[m][y] = -g[f][y - 1] / a[_ + 1][h], d += g[m][y] * a[h][_]), o[y][h] = d;
				let M = f;
				f = m, m = M
			}
		}
		let u = t;
		for (let h = 1; h <= n; ++h) {
			for (let f = 0; f <= t; ++f) o[h][f] *= u;
			u *= t - h
		}
		return o
	}

	function cb(r, e, t, n, i) {
		let s = i < r ? i : r,
			o = [],
			a = t0(r, n, e),
			l = lb(a, n, r, s, e),
			c = [];
		for (let u = 0; u < t.length; ++u) {
			let h = t[u].clone(),
				f = h.w;
			h.x *= f, h.y *= f, h.z *= f, c[u] = h
		}
		for (let u = 0; u <= s; ++u) {
			let h = c[a - r].clone().multiplyScalar(l[u][0]);
			for (let f = 1; f <= r; ++f) h.add(c[a - r + f].clone().multiplyScalar(l[u][f]));
			o[u] = h
		}
		for (let u = s + 1; u <= i + 1; ++u) o[u] = new Ct(0, 0, 0);
		return o
	}

	function ub(r, e) {
		let t = 1;
		for (let i = 2; i <= r; ++i) t *= i;
		let n = 1;
		for (let i = 2; i <= e; ++i) n *= i;
		for (let i = 2; i <= r - e; ++i) n *= i;
		return t / n
	}

	function hb(r) {
		let e = r.length,
			t = [],
			n = [];
		for (let s = 0; s < e; ++s) {
			let o = r[s];
			t[s] = new re(o.x, o.y, o.z), n[s] = o.w
		}
		let i = [];
		for (let s = 0; s < e; ++s) {
			let o = t[s].clone();
			for (let a = 1; a <= s; ++a) o.sub(i[s - a].clone().multiplyScalar(ub(s, a) * n[a]));
			i[s] = o.divideScalar(n[0])
		}
		return i
	}

	function i0(r, e, t, n, i) {
		let s = cb(r, e, t, n, i);
		return hb(s)
	}
	var Ku = class extends ei {
		constructor(e, t, n, i, s) {
			super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = s || this.knots.length - 1;
			for (let o = 0; o < n.length; ++o) {
				let a = n[o];
				this.controlPoints[o] = new Ct(a.x, a.y, a.z, a.w)
			}
		}
		getPoint(e, t = new re) {
			let n = t,
				i = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
				s = n0(this.degree, this.knots, this.controlPoints, i);
			return s.w !== 1 && s.divideScalar(s.w), n.set(s.x, s.y, s.z)
		}
		getTangent(e, t = new re) {
			let n = t,
				i = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
				s = i0(this.degree, this.knots, this.controlPoints, i, 1);
			return n.copy(s[1]).normalize(), n
		}
	};
	var At, un, ri, Ju = class extends Ot {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = this,
					o = s.path === "" ? ds.extractUrlBase(e) : s.path,
					a = new jn(this.manager);
				a.setPath(s.path), a.setResponseType("arraybuffer"), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
					try {
						t(s.parse(l, o))
					} catch (c) {
						i ? i(c) : console.error(c), s.manager.itemError(e)
					}
				}, n, i)
			}
			parse(e, t) {
				if (db(e)) At = new wd().parse(e);
				else {
					let i = l0(e);
					if (!pb(i)) throw new Error("THREE.FBXLoader: Unknown format.");
					if (r0(i) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r0(i));
					At = new Ad().parse(i)
				}
				let n = new bi(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
				return new Md(n, this.manager).parse(At)
			}
		},
		Md = class {
			constructor(e, t) {
				this.textureLoader = e, this.manager = t
			}
			parse() {
				un = this.parseConnections();
				let e = this.parseImages(),
					t = this.parseTextures(e),
					n = this.parseMaterials(t),
					i = this.parseDeformers(),
					s = new bd().parse(i);
				return this.parseScene(i, s, n), ri
			}
			parseConnections() {
				let e = new Map;
				return "Connections" in At && At.Connections.connections.forEach(function(n) {
					let i = n[0],
						s = n[1],
						o = n[2];
					e.has(i) || e.set(i, {
						parents: [],
						children: []
					});
					let a = {
						ID: s,
						relationship: o
					};
					e.get(i).parents.push(a), e.has(s) || e.set(s, {
						parents: [],
						children: []
					});
					let l = {
						ID: i,
						relationship: o
					};
					e.get(s).children.push(l)
				}), e
			}
			parseImages() {
				let e = {},
					t = {};
				if ("Video" in At.Objects) {
					let n = At.Objects.Video;
					for (let i in n) {
						let s = n[i],
							o = parseInt(i);
						if (e[o] = s.RelativeFilename || s.Filename, "Content" in s) {
							let a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0,
								l = typeof s.Content == "string" && s.Content !== "";
							if (a || l) {
								let c = this.parseImage(n[i]);
								t[s.RelativeFilename || s.Filename] = c
							}
						}
					}
				}
				for (let n in e) {
					let i = e[n];
					t[i] !== void 0 ? e[n] = t[i] : e[n] = e[n].split("\\").pop()
				}
				return e
			}
			parseImage(e) {
				let t = e.Content,
					n = e.RelativeFilename || e.Filename,
					i = n.slice(n.lastIndexOf(".") + 1).toLowerCase(),
					s;
				switch (i) {
					case "bmp":
						s = "image/bmp";
						break;
					case "jpg":
					case "jpeg":
						s = "image/jpeg";
						break;
					case "png":
						s = "image/png";
						break;
					case "tif":
						s = "image/tiff";
						break;
					case "tga":
						this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), s = "image/tga";
						break;
					default:
						console.warn('FBXLoader: Image type "' + i + '" is not supported.');
						return
				}
				if (typeof t == "string") return "data:" + s + ";base64," + t;
				{
					let o = new Uint8Array(t);
					return window.URL.createObjectURL(new Blob([o], {
						type: s
					}))
				}
			}
			parseTextures(e) {
				let t = new Map;
				if ("Texture" in At.Objects) {
					let n = At.Objects.Texture;
					for (let i in n) {
						let s = this.parseTexture(n[i], e);
						t.set(parseInt(i), s)
					}
				}
				return t
			}
			parseTexture(e, t) {
				let n = this.loadTexture(e, t);
				n.ID = e.id, n.name = e.attrName;
				let i = e.WrapModeU,
					s = e.WrapModeV,
					o = i !== void 0 ? i.value : 0,
					a = s !== void 0 ? s.value : 0;
				if (n.wrapS = o === 0 ? Qt : Wt, n.wrapT = a === 0 ? Qt : Wt, "Scaling" in e) {
					let l = e.Scaling.value;
					n.repeat.x = l[0], n.repeat.y = l[1]
				}
				if ("Translation" in e) {
					let l = e.Translation.value;
					n.offset.x = l[0], n.offset.y = l[1]
				}
				return n
			}
			loadTexture(e, t) {
				let n, i = this.textureLoader.path,
					s = un.get(e.id).children;
				s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (n = t[s[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
				let o, a = e.FileName.slice(-3).toLowerCase();
				if (a === "tga") {
					let l = this.manager.getHandler(".tga");
					l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new Gn) : (l.setPath(this.textureLoader.path), o = l.load(n))
				} else a === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new Gn) : o = this.textureLoader.load(n);
				return this.textureLoader.setPath(i), o
			}
			parseMaterials(e) {
				let t = new Map;
				if ("Material" in At.Objects) {
					let n = At.Objects.Material;
					for (let i in n) {
						let s = this.parseMaterial(n[i], e);
						s !== null && t.set(parseInt(i), s)
					}
				}
				return t
			}
			parseMaterial(e, t) {
				let n = e.id,
					i = e.attrName,
					s = e.ShadingModel;
				if (typeof s == "object" && (s = s.value), !un.has(n)) return null;
				let o = this.parseParameters(e, t, n),
					a;
				switch (s.toLowerCase()) {
					case "phong":
						a = new Xt;
						break;
					case "lambert":
						a = new fa;
						break;
					default:
						console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), a = new Xt;
						break
				}
				return a.setValues(o), a.name = i, a
			}
			parseParameters(e, t, n) {
				let i = {};
				e.BumpFactor && (i.bumpScale = e.BumpFactor.value), e.Diffuse ? i.color = new qe().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (i.color = new qe().fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value), e.Emissive ? i.emissive = new qe().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (i.emissive = new qe().fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (i.opacity = parseFloat(e.Opacity.value)), i.opacity < 1 && (i.transparent = !0), e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value), e.Shininess && (i.shininess = e.Shininess.value), e.Specular ? i.specular = new qe().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (i.specular = new qe().fromArray(e.SpecularColor.value).convertSRGBToLinear());
				let s = this;
				return un.get(n).children.forEach(function(o) {
					let a = o.relationship;
					switch (a) {
						case "Bump":
							i.bumpMap = s.getTexture(t, o.ID);
							break;
						case "Maya|TEX_ao_map":
							i.aoMap = s.getTexture(t, o.ID);
							break;
						case "DiffuseColor":
						case "Maya|TEX_color_map":
							i.map = s.getTexture(t, o.ID), i.map !== void 0 && (i.map.colorSpace = ot);
							break;
						case "DisplacementColor":
							i.displacementMap = s.getTexture(t, o.ID);
							break;
						case "EmissiveColor":
							i.emissiveMap = s.getTexture(t, o.ID), i.emissiveMap !== void 0 && (i.emissiveMap.colorSpace = ot);
							break;
						case "NormalMap":
						case "Maya|TEX_normal_map":
							i.normalMap = s.getTexture(t, o.ID);
							break;
						case "ReflectionColor":
							i.envMap = s.getTexture(t, o.ID), i.envMap !== void 0 && (i.envMap.mapping = Sl, i.envMap.colorSpace = ot);
							break;
						case "SpecularColor":
							i.specularMap = s.getTexture(t, o.ID), i.specularMap !== void 0 && (i.specularMap.colorSpace = ot);
							break;
						case "TransparentColor":
						case "TransparencyFactor":
							i.alphaMap = s.getTexture(t, o.ID), i.transparent = !0;
							break;
						case "AmbientColor":
						case "ShininessExponent":
						case "SpecularFactor":
						case "VectorDisplacementColor":
						default:
							console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
							break
					}
				}), i
			}
			getTexture(e, t) {
				return "LayeredTexture" in At.Objects && t in At.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = un.get(t).children[0].ID), e.get(t)
			}
			parseDeformers() {
				let e = {},
					t = {};
				if ("Deformer" in At.Objects) {
					let n = At.Objects.Deformer;
					for (let i in n) {
						let s = n[i],
							o = un.get(parseInt(i));
						if (s.attrType === "Skin") {
							let a = this.parseSkeleton(o, n);
							a.ID = i, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = o.parents[0].ID, e[i] = a
						} else if (s.attrType === "BlendShape") {
							let a = {
								id: i
							};
							a.rawTargets = this.parseMorphTargets(o, n), a.id = i, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[i] = a
						}
					}
				}
				return {
					skeletons: e,
					morphTargets: t
				}
			}
			parseSkeleton(e, t) {
				let n = [];
				return e.children.forEach(function(i) {
					let s = t[i.ID];
					if (s.attrType !== "Cluster") return;
					let o = {
						ID: i.ID,
						indices: [],
						weights: [],
						transformLink: new Je().fromArray(s.TransformLink.a)
					};
					"Indexes" in s && (o.indices = s.Indexes.a, o.weights = s.Weights.a), n.push(o)
				}), {
					rawBones: n,
					bones: []
				}
			}
			parseMorphTargets(e, t) {
				let n = [];
				for (let i = 0; i < e.children.length; i++) {
					let s = e.children[i],
						o = t[s.ID],
						a = {
							name: o.attrName,
							initialWeight: o.DeformPercent,
							id: o.id,
							fullWeights: o.FullWeights.a
						};
					if (o.attrType !== "BlendShapeChannel") return;
					a.geoID = un.get(parseInt(s.ID)).children.filter(function(l) {
						return l.relationship === void 0
					})[0].ID, n.push(a)
				}
				return n
			}
			parseScene(e, t, n) {
				ri = new cn;
				let i = this.parseModels(e.skeletons, t, n),
					s = At.Objects.Model,
					o = this;
				i.forEach(function(l) {
					let c = s[l.ID];
					o.setLookAtProperties(l, c), un.get(l.ID).parents.forEach(function(h) {
						let f = i.get(h.ID);
						f !== void 0 && f.add(l)
					}), l.parent === null && ri.add(l)
				}), this.bindSkeleton(e.skeletons, t, i), this.createAmbientLight(), ri.traverse(function(l) {
					if (l.userData.transformData) {
						l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
						let c = o0(l.userData.transformData);
						l.applyMatrix4(c), l.updateWorldMatrix()
					}
				});
				let a = new Sd().parse();
				ri.children.length === 1 && ri.children[0].isGroup && (ri.children[0].animations = a, ri = ri.children[0]), ri.animations = a
			}
			parseModels(e, t, n) {
				let i = new Map,
					s = At.Objects.Model;
				for (let o in s) {
					let a = parseInt(o),
						l = s[o],
						c = un.get(a),
						u = this.buildSkeleton(c, e, a, l.attrName);
					if (!u) {
						switch (l.attrType) {
							case "Camera":
								u = this.createCamera(c);
								break;
							case "Light":
								u = this.createLight(c);
								break;
							case "Mesh":
								u = this.createMesh(c, t, n);
								break;
							case "NurbsCurve":
								u = this.createCurve(c, t);
								break;
							case "LimbNode":
							case "Root":
								u = new as;
								break;
							case "Null":
							default:
								u = new cn;
								break
						}
						u.name = l.attrName ? Gt.sanitizeNodeName(l.attrName) : "", u.ID = a
					}
					this.getTransformData(u, l), i.set(a, u)
				}
				return i
			}
			buildSkeleton(e, t, n, i) {
				let s = null;
				return e.parents.forEach(function(o) {
					for (let a in t) {
						let l = t[a];
						l.rawBones.forEach(function(c, u) {
							if (c.ID === o.ID) {
								let h = s;
								s = new as, s.matrixWorld.copy(c.transformLink), s.name = i ? Gt.sanitizeNodeName(i) : "", s.ID = n, l.bones[u] = s, h !== null && s.add(h)
							}
						})
					}
				}), s
			}
			createCamera(e) {
				let t, n;
				if (e.children.forEach(function(i) {
						let s = At.Objects.NodeAttribute[i.ID];
						s !== void 0 && (n = s)
					}), n === void 0) t = new Rt;
				else {
					let i = 0;
					n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (i = 1);
					let s = 1;
					n.NearPlane !== void 0 && (s = n.NearPlane.value / 1e3);
					let o = 1e3;
					n.FarPlane !== void 0 && (o = n.FarPlane.value / 1e3);
					let a = window.innerWidth,
						l = window.innerHeight;
					n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value, l = n.AspectHeight.value);
					let c = a / l,
						u = 45;
					n.FieldOfView !== void 0 && (u = n.FieldOfView.value);
					let h = n.FocalLength ? n.FocalLength.value : null;
					switch (i) {
						case 0:
							t = new Yt(u, c, s, o), h !== null && t.setFocalLength(h);
							break;
						case 1:
							t = new cr(-a / 2, a / 2, l / 2, -l / 2, s, o);
							break;
						default:
							console.warn("THREE.FBXLoader: Unknown camera type " + i + "."), t = new Rt;
							break
					}
				}
				return t
			}
			createLight(e) {
				let t, n;
				if (e.children.forEach(function(i) {
						let s = At.Objects.NodeAttribute[i.ID];
						s !== void 0 && (n = s)
					}), n === void 0) t = new Rt;
				else {
					let i;
					n.LightType === void 0 ? i = 0 : i = n.LightType.value;
					let s = 16777215;
					n.Color !== void 0 && (s = new qe().fromArray(n.Color.value).convertSRGBToLinear());
					let o = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
					n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (o = 0);
					let a = 0;
					n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);
					let l = 1;
					switch (i) {
						case 0:
							t = new Zs(s, o, a, l);
							break;
						case 1:
							t = new hr(s, o);
							break;
						case 2:
							let c = Math.PI / 3;
							n.InnerAngle !== void 0 && (c = Nn.degToRad(n.InnerAngle.value));
							let u = 0;
							n.OuterAngle !== void 0 && (u = Nn.degToRad(n.OuterAngle.value), u = Math.max(u, 1)), t = new ma(s, o, a, c, u, l);
							break;
						default:
							console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new Zs(s, o);
							break
					}
					n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0)
				}
				return t
			}
			createMesh(e, t, n) {
				let i, s = null,
					o = null,
					a = [];
				return e.children.forEach(function(l) {
					t.has(l.ID) && (s = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID))
				}), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new Xt({
					name: Ot.DEFAULT_MATERIAL_NAME,
					color: 13421772
				}), a.push(o)), "color" in s.attributes && a.forEach(function(l) {
					l.vertexColors = !0
				}), s.FBX_Deformer ? (i = new la(s, o), i.normalizeSkinWeights()) : i = new Nt(s, o), i
			}
			createCurve(e, t) {
				let n = e.children.reduce(function(s, o) {
						return t.has(o.ID) && (s = t.get(o.ID)), s
					}, null),
					i = new Ei({
						name: Ot.DEFAULT_MATERIAL_NAME,
						color: 3342591,
						linewidth: 1
					});
				return new js(n, i)
			}
			getTransformData(e, t) {
				let n = {};
				"InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = a0(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n
			}
			setLookAtProperties(e, t) {
				"LookAtProperty" in t && un.get(e.ID).children.forEach(function(i) {
					if (i.relationship === "LookAtProperty") {
						let s = At.Objects.Model[i.ID];
						if ("Lcl_Translation" in s) {
							let o = s.Lcl_Translation.value;
							e.target !== void 0 ? (e.target.position.fromArray(o), ri.add(e.target)) : e.lookAt(new re().fromArray(o))
						}
					}
				})
			}
			bindSkeleton(e, t, n) {
				let i = this.parsePoseNodes();
				for (let s in e) {
					let o = e[s];
					un.get(parseInt(o.ID)).parents.forEach(function(l) {
						if (t.has(l.ID)) {
							let c = l.ID;
							un.get(c).parents.forEach(function(h) {
								n.has(h.ID) && n.get(h.ID).bind(new ua(o.bones), i[h.ID])
							})
						}
					})
				}
			}
			parsePoseNodes() {
				let e = {};
				if ("Pose" in At.Objects) {
					let t = At.Objects.Pose;
					for (let n in t)
						if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
							let i = t[n].PoseNode;
							Array.isArray(i) ? i.forEach(function(s) {
								e[s.Node] = new Je().fromArray(s.Matrix.a)
							}) : e[i.Node] = new Je().fromArray(i.Matrix.a)
						}
				}
				return e
			}
			createAmbientLight() {
				if ("GlobalSettings" in At && "AmbientColor" in At.GlobalSettings) {
					let e = At.GlobalSettings.AmbientColor.value,
						t = e[0],
						n = e[1],
						i = e[2];
					if (t !== 0 || n !== 0 || i !== 0) {
						let s = new qe(t, n, i).convertSRGBToLinear();
						ri.add(new fr(s, 1))
					}
				}
			}
		},
		bd = class {
			constructor() {
				this.negativeMaterialIndices = !1
			}
			parse(e) {
				let t = new Map;
				if ("Geometry" in At.Objects) {
					let n = At.Objects.Geometry;
					for (let i in n) {
						let s = un.get(parseInt(i)),
							o = this.parseGeometry(s, n[i], e);
						t.set(parseInt(i), o)
					}
				}
				return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t
			}
			parseGeometry(e, t, n) {
				switch (t.attrType) {
					case "Mesh":
						return this.parseMeshGeometry(e, t, n);
					case "NurbsCurve":
						return this.parseNurbsGeometry(t)
				}
			}
			parseMeshGeometry(e, t, n) {
				let i = n.skeletons,
					s = [],
					o = e.parents.map(function(h) {
						return At.Objects.Model[h.ID]
					});
				if (o.length === 0) return;
				let a = e.children.reduce(function(h, f) {
					return i[f.ID] !== void 0 && (h = i[f.ID]), h
				}, null);
				e.children.forEach(function(h) {
					n.morphTargets[h.ID] !== void 0 && s.push(n.morphTargets[h.ID])
				});
				let l = o[0],
					c = {};
				"RotationOrder" in l && (c.eulerOrder = a0(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
				let u = o0(c);
				return this.genGeometry(t, a, s, u)
			}
			genGeometry(e, t, n, i) {
				let s = new St;
				e.attrName && (s.name = e.attrName);
				let o = this.parseGeoNode(e, t),
					a = this.genBuffers(o),
					l = new ze(a.vertex, 3);
				if (l.applyMatrix4(i), s.setAttribute("position", l), a.colors.length > 0 && s.setAttribute("color", new ze(a.colors, 3)), t && (s.setAttribute("skinIndex", new oa(a.weightsIndices, 4)), s.setAttribute("skinWeight", new ze(a.vertexWeights, 4)), s.FBX_Deformer = t), a.normal.length > 0) {
					let c = new pt().getNormalMatrix(i),
						u = new ze(a.normal, 3);
					u.applyNormalMatrix(c), s.setAttribute("normal", u)
				}
				if (a.uvs.forEach(function(c, u) {
						let h = u === 0 ? "uv" : `uv${u}`;
						s.setAttribute(h, new ze(a.uvs[u], 2))
					}), o.material && o.material.mappingType !== "AllSame") {
					let c = a.materialIndex[0],
						u = 0;
					if (a.materialIndex.forEach(function(h, f) {
							h !== c && (s.addGroup(u, f - u, c), c = h, u = f)
						}), s.groups.length > 0) {
						let h = s.groups[s.groups.length - 1],
							f = h.start + h.count;
						f !== a.materialIndex.length && s.addGroup(f, a.materialIndex.length - f, c)
					}
					s.groups.length === 0 && s.addGroup(0, a.materialIndex.length, a.materialIndex[0])
				}
				return this.addMorphTargets(s, e, n, i), s
			}
			parseGeoNode(e, t) {
				let n = {};
				if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
					n.uv = [];
					let i = 0;
					for (; e.LayerElementUV[i];) e.LayerElementUV[i].UV && n.uv.push(this.parseUVs(e.LayerElementUV[i])), i++
				}
				return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(i, s) {
					i.indices.forEach(function(o, a) {
						n.weightTable[o] === void 0 && (n.weightTable[o] = []), n.weightTable[o].push({
							id: s,
							weight: i.weights[a]
						})
					})
				})), n
			}
			genBuffers(e) {
				let t = {
						vertex: [],
						normal: [],
						colors: [],
						uvs: [],
						materialIndex: [],
						vertexWeights: [],
						weightsIndices: []
					},
					n = 0,
					i = 0,
					s = !1,
					o = [],
					a = [],
					l = [],
					c = [],
					u = [],
					h = [],
					f = this;
				return e.vertexIndices.forEach(function(m, g) {
					let y, d = !1;
					m < 0 && (m = m ^ -1, d = !0);
					let p = [],
						_ = [];
					if (o.push(m * 3, m * 3 + 1, m * 3 + 2), e.color) {
						let v = Zu(g, n, m, e.color);
						l.push(v[0], v[1], v[2])
					}
					if (e.skeleton) {
						if (e.weightTable[m] !== void 0 && e.weightTable[m].forEach(function(v) {
								_.push(v.weight), p.push(v.id)
							}), _.length > 4) {
							s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
							let v = [0, 0, 0, 0],
								x = [0, 0, 0, 0];
							_.forEach(function(M, I) {
								let w = M,
									L = p[I];
								x.forEach(function(T, C, V) {
									if (w > T) {
										V[C] = w, w = T;
										let k = v[C];
										v[C] = L, L = k
									}
								})
							}), p = v, _ = x
						}
						for (; _.length < 4;) _.push(0), p.push(0);
						for (let v = 0; v < 4; ++v) u.push(_[v]), h.push(p[v])
					}
					if (e.normal) {
						let v = Zu(g, n, m, e.normal);
						a.push(v[0], v[1], v[2])
					}
					e.material && e.material.mappingType !== "AllSame" && (y = Zu(g, n, m, e.material)[0], y < 0 && (f.negativeMaterialIndices = !0, y = 0)), e.uv && e.uv.forEach(function(v, x) {
						let M = Zu(g, n, m, v);
						c[x] === void 0 && (c[x] = []), c[x].push(M[0]), c[x].push(M[1])
					}), i++, d && (i > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."), f.genFace(t, e, o, y, a, l, c, u, h, i), n++, i = 0, o = [], a = [], l = [], c = [], u = [], h = [])
				}), t
			}
			genFace(e, t, n, i, s, o, a, l, c, u) {
				for (let h = 2; h < u; h++) e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[h * 3]]), e.vertex.push(t.vertexPositions[n[h * 3 + 1]]), e.vertex.push(t.vertexPositions[n[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(h - 1) * 4]), e.vertexWeights.push(l[(h - 1) * 4 + 1]), e.vertexWeights.push(l[(h - 1) * 4 + 2]), e.vertexWeights.push(l[(h - 1) * 4 + 3]), e.vertexWeights.push(l[h * 4]), e.vertexWeights.push(l[h * 4 + 1]), e.vertexWeights.push(l[h * 4 + 2]), e.vertexWeights.push(l[h * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(h - 1) * 4]), e.weightsIndices.push(c[(h - 1) * 4 + 1]), e.weightsIndices.push(c[(h - 1) * 4 + 2]), e.weightsIndices.push(c[(h - 1) * 4 + 3]), e.weightsIndices.push(c[h * 4]), e.weightsIndices.push(c[h * 4 + 1]), e.weightsIndices.push(c[h * 4 + 2]), e.weightsIndices.push(c[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(i), e.materialIndex.push(i), e.materialIndex.push(i)), t.normal && (e.normal.push(s[0]), e.normal.push(s[1]), e.normal.push(s[2]), e.normal.push(s[(h - 1) * 3]), e.normal.push(s[(h - 1) * 3 + 1]), e.normal.push(s[(h - 1) * 3 + 2]), e.normal.push(s[h * 3]), e.normal.push(s[h * 3 + 1]), e.normal.push(s[h * 3 + 2])), t.uv && t.uv.forEach(function(f, m) {
					e.uvs[m] === void 0 && (e.uvs[m] = []), e.uvs[m].push(a[m][0]), e.uvs[m].push(a[m][1]), e.uvs[m].push(a[m][(h - 1) * 2]), e.uvs[m].push(a[m][(h - 1) * 2 + 1]), e.uvs[m].push(a[m][h * 2]), e.uvs[m].push(a[m][h * 2 + 1])
				})
			}
			addMorphTargets(e, t, n, i) {
				if (n.length === 0) return;
				e.morphTargetsRelative = !0, e.morphAttributes.position = [];
				let s = this;
				n.forEach(function(o) {
					o.rawTargets.forEach(function(a) {
						let l = At.Objects.Geometry[a.geoID];
						l !== void 0 && s.genMorphGeometry(e, t, l, i, a.name)
					})
				})
			}
			genMorphGeometry(e, t, n, i, s) {
				let o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [],
					a = n.Vertices !== void 0 ? n.Vertices.a : [],
					l = n.Indexes !== void 0 ? n.Indexes.a : [],
					c = e.attributes.position.count * 3,
					u = new Float32Array(c);
				for (let g = 0; g < l.length; g++) {
					let y = l[g] * 3;
					u[y] = a[g * 3], u[y + 1] = a[g * 3 + 1], u[y + 2] = a[g * 3 + 2]
				}
				let h = {
						vertexIndices: o,
						vertexPositions: u
					},
					f = this.genBuffers(h),
					m = new ze(f.vertex, 3);
				m.name = s || n.attrName, m.applyMatrix4(i), e.morphAttributes.position.push(m)
			}
			parseNormals(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType,
					i = e.Normals.a,
					s = [];
				return n === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), {
					dataSize: 3,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseUVs(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType,
					i = e.UV.a,
					s = [];
				return n === "IndexToDirect" && (s = e.UVIndex.a), {
					dataSize: 2,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseVertexColors(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType,
					i = e.Colors.a,
					s = [];
				n === "IndexToDirect" && (s = e.ColorIndex.a);
				for (let o = 0, a = new qe; o < i.length; o += 4) a.fromArray(i, o).convertSRGBToLinear().toArray(i, o);
				return {
					dataSize: 4,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseMaterialIndices(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType;
				if (t === "NoMappingInformation") return {
					dataSize: 1,
					buffer: [0],
					indices: [0],
					mappingType: "AllSame",
					referenceType: n
				};
				let i = e.Materials.a,
					s = [];
				for (let o = 0; o < i.length; ++o) s.push(o);
				return {
					dataSize: 1,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseNurbsGeometry(e) {
				let t = parseInt(e.Order);
				if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new St;
				let n = t - 1,
					i = e.KnotVector.a,
					s = [],
					o = e.Points.a;
				for (let h = 0, f = o.length; h < f; h += 4) s.push(new Ct().fromArray(o, h));
				let a, l;
				if (e.Form === "Closed") s.push(s[0]);
				else if (e.Form === "Periodic") {
					a = n, l = i.length - 1 - a;
					for (let h = 0; h < n; ++h) s.push(s[h])
				}
				let u = new Ku(n, i, s, a, l).getPoints(s.length * 12);
				return new St().setFromPoints(u)
			}
		},
		Sd = class {
			parse() {
				let e = [],
					t = this.parseClips();
				if (t !== void 0)
					for (let n in t) {
						let i = t[n],
							s = this.addClip(i);
						e.push(s)
					}
				return e
			}
			parseClips() {
				if (At.Objects.AnimationCurve === void 0) return;
				let e = this.parseAnimationCurveNodes();
				this.parseAnimationCurves(e);
				let t = this.parseAnimationLayers(e);
				return this.parseAnimStacks(t)
			}
			parseAnimationCurveNodes() {
				let e = At.Objects.AnimationCurveNode,
					t = new Map;
				for (let n in e) {
					let i = e[n];
					if (i.attrName.match(/S|R|T|DeformPercent/) !== null) {
						let s = {
							id: i.id,
							attr: i.attrName,
							curves: {}
						};
						t.set(s.id, s)
					}
				}
				return t
			}
			parseAnimationCurves(e) {
				let t = At.Objects.AnimationCurve;
				for (let n in t) {
					let i = {
							id: t[n].id,
							times: t[n].KeyTime.a.map(mb),
							values: t[n].KeyValueFloat.a
						},
						s = un.get(i.id);
					if (s !== void 0) {
						let o = s.parents[0].ID,
							a = s.parents[0].relationship;
						a.match(/X/) ? e.get(o).curves.x = i : a.match(/Y/) ? e.get(o).curves.y = i : a.match(/Z/) ? e.get(o).curves.z = i : a.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = i)
					}
				}
			}
			parseAnimationLayers(e) {
				let t = At.Objects.AnimationLayer,
					n = new Map;
				for (let i in t) {
					let s = [],
						o = un.get(parseInt(i));
					o !== void 0 && (o.children.forEach(function(l, c) {
						if (e.has(l.ID)) {
							let u = e.get(l.ID);
							if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
								if (s[c] === void 0) {
									let h = un.get(l.ID).parents.filter(function(f) {
										return f.relationship !== void 0
									})[0].ID;
									if (h !== void 0) {
										let f = At.Objects.Model[h.toString()];
										if (f === void 0) {
											console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
											return
										}
										let m = {
											modelName: f.attrName ? Gt.sanitizeNodeName(f.attrName) : "",
											ID: f.id,
											initialPosition: [0, 0, 0],
											initialRotation: [0, 0, 0],
											initialScale: [1, 1, 1]
										};
										ri.traverse(function(g) {
											g.ID === f.id && (m.transform = g.matrix, g.userData.transformData && (m.eulerOrder = g.userData.transformData.eulerOrder))
										}), m.transform || (m.transform = new Je), "PreRotation" in f && (m.preRotation = f.PreRotation.value), "PostRotation" in f && (m.postRotation = f.PostRotation.value), s[c] = m
									}
								}
								s[c] && (s[c][u.attr] = u)
							} else if (u.curves.morph !== void 0) {
								if (s[c] === void 0) {
									let h = un.get(l.ID).parents.filter(function(p) {
											return p.relationship !== void 0
										})[0].ID,
										f = un.get(h).parents[0].ID,
										m = un.get(f).parents[0].ID,
										g = un.get(m).parents[0].ID,
										y = At.Objects.Model[g],
										d = {
											modelName: y.attrName ? Gt.sanitizeNodeName(y.attrName) : "",
											morphName: At.Objects.Deformer[h].attrName
										};
									s[c] = d
								}
								s[c][u.attr] = u
							}
						}
					}), n.set(parseInt(i), s))
				}
				return n
			}
			parseAnimStacks(e) {
				let t = At.Objects.AnimationStack,
					n = {};
				for (let i in t) {
					let s = un.get(parseInt(i)).children;
					s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
					let o = e.get(s[0].ID);
					n[i] = {
						name: t[i].attrName,
						layer: o
					}
				}
				return n
			}
			addClip(e) {
				let t = [],
					n = this;
				return e.layer.forEach(function(i) {
					t = t.concat(n.generateTracks(i))
				}), new Ks(e.name, -1, t)
			}
			generateTracks(e) {
				let t = [],
					n = new re,
					i = new yn,
					s = new re;
				if (e.transform && e.transform.decompose(n, i, s), n = n.toArray(), i = new fi().setFromQuaternion(i, e.eulerOrder).toArray(), s = s.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
					let o = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
					o !== void 0 && t.push(o)
				}
				if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
					let o = this.generateRotationTrack(e.modelName, e.R.curves, i, e.preRotation, e.postRotation, e.eulerOrder);
					o !== void 0 && t.push(o)
				}
				if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
					let o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
					o !== void 0 && t.push(o)
				}
				if (e.DeformPercent !== void 0) {
					let o = this.generateMorphTrack(e);
					o !== void 0 && t.push(o)
				}
				return t
			}
			generateVectorTrack(e, t, n, i) {
				let s = this.getTimesForAllAxes(t),
					o = this.getKeyframeTrackValues(s, t, n);
				return new Hi(e + "." + i, s, o)
			}
			generateRotationTrack(e, t, n, i, s, o) {
				t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Nn.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Nn.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Nn.degToRad));
				let a = this.getTimesForAllAxes(t),
					l = this.getKeyframeTrackValues(a, t, n);
				i !== void 0 && (i = i.map(Nn.degToRad), i.push(o), i = new fi().fromArray(i), i = new yn().setFromEuler(i)), s !== void 0 && (s = s.map(Nn.degToRad), s.push(o), s = new fi().fromArray(s), s = new yn().setFromEuler(s).invert());
				let c = new yn,
					u = new fi,
					h = [];
				for (let f = 0; f < l.length; f += 3) u.set(l[f], l[f + 1], l[f + 2], o), c.setFromEuler(u), i !== void 0 && c.premultiply(i), s !== void 0 && c.multiply(s), c.toArray(h, f / 3 * 4);
				return new zi(e + ".quaternion", a, h)
			}
			generateMorphTrack(e) {
				let t = e.DeformPercent.curves.morph,
					n = t.values.map(function(s) {
						return s / 100
					}),
					i = ri.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
				return new hs(e.modelName + ".morphTargetInfluences[" + i + "]", t.times, n)
			}
			getTimesForAllAxes(e) {
				let t = [];
				if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, i) {
						return n - i
					}), t.length > 1) {
					let n = 1,
						i = t[0];
					for (let s = 1; s < t.length; s++) {
						let o = t[s];
						o !== i && (t[n] = o, i = o, n++)
					}
					t = t.slice(0, n)
				}
				return t
			}
			getKeyframeTrackValues(e, t, n) {
				let i = n,
					s = [],
					o = -1,
					a = -1,
					l = -1;
				return e.forEach(function(c) {
					if (t.x && (o = t.x.times.indexOf(c)), t.y && (a = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), o !== -1) {
						let u = t.x.values[o];
						s.push(u), i[0] = u
					} else s.push(i[0]);
					if (a !== -1) {
						let u = t.y.values[a];
						s.push(u), i[1] = u
					} else s.push(i[1]);
					if (l !== -1) {
						let u = t.z.values[l];
						s.push(u), i[2] = u
					} else s.push(i[2])
				}), s
			}
			interpolateRotations(e) {
				for (let t = 1; t < e.values.length; t++) {
					let n = e.values[t - 1],
						i = e.values[t] - n,
						s = Math.abs(i);
					if (s >= 180) {
						let o = s / 180,
							a = i / o,
							l = n + a,
							c = e.times[t - 1],
							h = (e.times[t] - c) / o,
							f = c + h,
							m = [],
							g = [];
						for (; f < e.times[t];) m.push(f), f += h, g.push(l), l += a;
						e.times = s0(e.times, t, m), e.values = s0(e.values, t, g)
					}
				}
			}
		},
		Ad = class {
			getPrevNode() {
				return this.nodeStack[this.currentIndent - 2]
			}
			getCurrentNode() {
				return this.nodeStack[this.currentIndent - 1]
			}
			getCurrentProp() {
				return this.currentProp
			}
			pushStack(e) {
				this.nodeStack.push(e), this.currentIndent += 1
			}
			popStack() {
				this.nodeStack.pop(), this.currentIndent -= 1
			}
			setCurrentProp(e, t) {
				this.currentProp = e, this.currentPropName = t
			}
			parse(e) {
				this.currentIndent = 0, this.allNodes = new Qu, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
				let t = this,
					n = e.split(/[\r\n]+/);
				return n.forEach(function(i, s) {
					let o = i.match(/^[\s\t]*;/),
						a = i.match(/^[\s\t]*$/);
					if (o || a) return;
					let l = i.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
						c = i.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
						u = i.match("^\\t{" + (t.currentIndent - 1) + "}}");
					l ? t.parseNodeBegin(i, l) : c ? t.parseNodeProperty(i, c, n[++s]) : u ? t.popStack() : i.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(i)
				}), this.allNodes
			}
			parseNodeBegin(e, t) {
				let n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
					i = t[2].split(",").map(function(l) {
						return l.trim().replace(/^"/, "").replace(/"$/, "")
					}),
					s = {
						name: n
					},
					o = this.parseNodeAttr(i),
					a = this.getCurrentNode();
				this.currentIndent === 0 ? this.allNodes.add(n, s) : n in a ? (n === "PoseNode" ? a.PoseNode.push(s) : a[n].id !== void 0 && (a[n] = {}, a[n][a[n].id] = a[n]), o.id !== "" && (a[n][o.id] = s)) : typeof o.id == "number" ? (a[n] = {}, a[n][o.id] = s) : n !== "Properties70" && (n === "PoseNode" ? a[n] = [s] : a[n] = s), typeof o.id == "number" && (s.id = o.id), o.name !== "" && (s.attrName = o.name), o.type !== "" && (s.attrType = o.type), this.pushStack(s)
			}
			parseNodeAttr(e) {
				let t = e[0];
				e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
				let n = "",
					i = "";
				return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), i = e[2]), {
					id: t,
					name: n,
					type: i
				}
			}
			parseNodeProperty(e, t, n) {
				let i = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
					s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
				i === "Content" && s === "," && (s = n.replace(/"/g, "").replace(/,$/, "").trim());
				let o = this.getCurrentNode();
				if (o.name === "Properties70") {
					this.parseNodeSpecialProperty(e, i, s);
					return
				}
				if (i === "C") {
					let l = s.split(",").slice(1),
						c = parseInt(l[0]),
						u = parseInt(l[1]),
						h = s.split(",").slice(3);
					h = h.map(function(f) {
						return f.trim().replace(/^"/, "")
					}), i = "connections", s = [c, u], yb(s, h), o[i] === void 0 && (o[i] = [])
				}
				i === "Node" && (o.id = s), i in o && Array.isArray(o[i]) ? o[i].push(s) : i !== "a" ? o[i] = s : o.a = s, this.setCurrentProp(o, i), i === "a" && s.slice(-1) !== "," && (o.a = Ed(s))
			}
			parseNodePropertyContinued(e) {
				let t = this.getCurrentNode();
				t.a += e, e.slice(-1) !== "," && (t.a = Ed(t.a))
			}
			parseNodeSpecialProperty(e, t, n) {
				let i = n.split('",').map(function(u) {
						return u.trim().replace(/^\"/, "").replace(/\s/, "_")
					}),
					s = i[0],
					o = i[1],
					a = i[2],
					l = i[3],
					c = i[4];
				switch (o) {
					case "int":
					case "enum":
					case "bool":
					case "ULongLong":
					case "double":
					case "Number":
					case "FieldOfView":
						c = parseFloat(c);
						break;
					case "Color":
					case "ColorRGB":
					case "Vector3D":
					case "Lcl_Translation":
					case "Lcl_Rotation":
					case "Lcl_Scaling":
						c = Ed(c);
						break
				}
				this.getPrevNode()[s] = {
					type: o,
					type2: a,
					flag: l,
					value: c
				}, this.setCurrentProp(this.getPrevNode(), s)
			}
		},
		wd = class {
			parse(e) {
				let t = new $u(e);
				t.skip(23);
				let n = t.getUint32();
				if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
				let i = new Qu;
				for (; !this.endOfContent(t);) {
					let s = this.parseNode(t, n);
					s !== null && i.add(s.name, s)
				}
				return i
			}
			endOfContent(e) {
				return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
			}
			parseNode(e, t) {
				let n = {},
					i = t >= 7500 ? e.getUint64() : e.getUint32(),
					s = t >= 7500 ? e.getUint64() : e.getUint32();
				t >= 7500 ? e.getUint64() : e.getUint32();
				let o = e.getUint8(),
					a = e.getString(o);
				if (i === 0) return null;
				let l = [];
				for (let f = 0; f < s; f++) l.push(this.parseProperty(e));
				let c = l.length > 0 ? l[0] : "",
					u = l.length > 1 ? l[1] : "",
					h = l.length > 2 ? l[2] : "";
				for (n.singleProperty = s === 1 && e.getOffset() === i; i > e.getOffset();) {
					let f = this.parseNode(e, t);
					f !== null && this.parseSubNode(a, n, f)
				}
				return n.propertyList = l, typeof c == "number" && (n.id = c), u !== "" && (n.attrName = u), h !== "" && (n.attrType = h), a !== "" && (n.name = a), n
			}
			parseSubNode(e, t, n) {
				if (n.singleProperty === !0) {
					let i = n.propertyList[0];
					Array.isArray(i) ? (t[n.name] = n, n.a = i) : t[n.name] = i
				} else if (e === "Connections" && n.name === "C") {
					let i = [];
					n.propertyList.forEach(function(s, o) {
						o !== 0 && i.push(s)
					}), t.connections === void 0 && (t.connections = []), t.connections.push(i)
				} else if (n.name === "Properties70") Object.keys(n).forEach(function(s) {
					t[s] = n[s]
				});
				else if (e === "Properties70" && n.name === "P") {
					let i = n.propertyList[0],
						s = n.propertyList[1],
						o = n.propertyList[2],
						a = n.propertyList[3],
						l;
					i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : l = n.propertyList[4], t[i] = {
						type: s,
						type2: o,
						flag: a,
						value: l
					}
				} else t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n)
			}
			parseProperty(e) {
				let t = e.getString(1),
					n;
				switch (t) {
					case "C":
						return e.getBoolean();
					case "D":
						return e.getFloat64();
					case "F":
						return e.getFloat32();
					case "I":
						return e.getInt32();
					case "L":
						return e.getInt64();
					case "R":
						return n = e.getUint32(), e.getArrayBuffer(n);
					case "S":
						return n = e.getUint32(), e.getString(n);
					case "Y":
						return e.getInt16();
					case "b":
					case "c":
					case "d":
					case "f":
					case "i":
					case "l":
						let i = e.getUint32(),
							s = e.getUint32(),
							o = e.getUint32();
						if (s === 0) switch (t) {
							case "b":
							case "c":
								return e.getBooleanArray(i);
							case "d":
								return e.getFloat64Array(i);
							case "f":
								return e.getFloat32Array(i);
							case "i":
								return e.getInt32Array(i);
							case "l":
								return e.getInt64Array(i)
						}
						let a = e0(new Uint8Array(e.getArrayBuffer(o))),
							l = new $u(a.buffer);
						switch (t) {
							case "b":
							case "c":
								return l.getBooleanArray(i);
							case "d":
								return l.getFloat64Array(i);
							case "f":
								return l.getFloat32Array(i);
							case "i":
								return l.getInt32Array(i);
							case "l":
								return l.getInt64Array(i)
						}
						break;
					default:
						throw new Error("THREE.FBXLoader: Unknown property type " + t)
				}
			}
		},
		$u = class {
			constructor(e, t) {
				this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0, this._textDecoder = new TextDecoder
			}
			getOffset() {
				return this.offset
			}
			size() {
				return this.dv.buffer.byteLength
			}
			skip(e) {
				this.offset += e
			}
			getBoolean() {
				return (this.getUint8() & 1) === 1
			}
			getBooleanArray(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getBoolean());
				return t
			}
			getUint8() {
				let e = this.dv.getUint8(this.offset);
				return this.offset += 1, e
			}
			getInt16() {
				let e = this.dv.getInt16(this.offset, this.littleEndian);
				return this.offset += 2, e
			}
			getInt32() {
				let e = this.dv.getInt32(this.offset, this.littleEndian);
				return this.offset += 4, e
			}
			getInt32Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getInt32());
				return t
			}
			getUint32() {
				let e = this.dv.getUint32(this.offset, this.littleEndian);
				return this.offset += 4, e
			}
			getInt64() {
				let e, t;
				return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e
			}
			getInt64Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getInt64());
				return t
			}
			getUint64() {
				let e, t;
				return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e
			}
			getFloat32() {
				let e = this.dv.getFloat32(this.offset, this.littleEndian);
				return this.offset += 4, e
			}
			getFloat32Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getFloat32());
				return t
			}
			getFloat64() {
				let e = this.dv.getFloat64(this.offset, this.littleEndian);
				return this.offset += 8, e
			}
			getFloat64Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getFloat64());
				return t
			}
			getArrayBuffer(e) {
				let t = this.dv.buffer.slice(this.offset, this.offset + e);
				return this.offset += e, t
			}
			getString(e) {
				let t = this.offset,
					n = new Uint8Array(this.dv.buffer, t, e);
				this.skip(e);
				let i = n.indexOf(0);
				return i >= 0 && (n = new Uint8Array(this.dv.buffer, t, i)), this._textDecoder.decode(n)
			}
		},
		Qu = class {
			add(e, t) {
				this[e] = t
			}
		};

	function db(r) {
		let e = "Kaydara FBX Binary  \0";
		return r.byteLength >= e.length && e === l0(r, 0, e.length)
	}

	function pb(r) {
		let e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"],
			t = 0;

		function n(i) {
			let s = r[i - 1];
			return r = r.slice(t + i), t++, s
		}
		for (let i = 0; i < e.length; ++i)
			if (n(1) === e[i]) return !1;
		return !0
	}

	function r0(r) {
		let e = /FBXVersion: (\d+)/,
			t = r.match(e);
		if (t) return parseInt(t[1]);
		throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
	}

	function mb(r) {
		return r / 46186158e3
	}
	var gb = [];

	function Zu(r, e, t, n) {
		let i;
		switch (n.mappingType) {
			case "ByPolygonVertex":
				i = r;
				break;
			case "ByPolygon":
				i = e;
				break;
			case "ByVertice":
				i = t;
				break;
			case "AllSame":
				i = n.indices[0];
				break;
			default:
				console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType)
		}
		n.referenceType === "IndexToDirect" && (i = n.indices[i]);
		let s = i * n.dataSize,
			o = s + n.dataSize;
		return vb(gb, n.buffer, s, o)
	}
	var Td = new fi,
		Ra = new re;

	function o0(r) {
		let e = new Je,
			t = new Je,
			n = new Je,
			i = new Je,
			s = new Je,
			o = new Je,
			a = new Je,
			l = new Je,
			c = new Je,
			u = new Je,
			h = new Je,
			f = new Je,
			m = r.inheritType ? r.inheritType : 0;
		if (r.translation && e.setPosition(Ra.fromArray(r.translation)), r.preRotation) {
			let C = r.preRotation.map(Nn.degToRad);
			C.push(r.eulerOrder || fi.DEFAULT_ORDER), t.makeRotationFromEuler(Td.fromArray(C))
		}
		if (r.rotation) {
			let C = r.rotation.map(Nn.degToRad);
			C.push(r.eulerOrder || fi.DEFAULT_ORDER), n.makeRotationFromEuler(Td.fromArray(C))
		}
		if (r.postRotation) {
			let C = r.postRotation.map(Nn.degToRad);
			C.push(r.eulerOrder || fi.DEFAULT_ORDER), i.makeRotationFromEuler(Td.fromArray(C)), i.invert()
		}
		r.scale && s.scale(Ra.fromArray(r.scale)), r.scalingOffset && a.setPosition(Ra.fromArray(r.scalingOffset)), r.scalingPivot && o.setPosition(Ra.fromArray(r.scalingPivot)), r.rotationOffset && l.setPosition(Ra.fromArray(r.rotationOffset)), r.rotationPivot && c.setPosition(Ra.fromArray(r.rotationPivot)), r.parentMatrixWorld && (h.copy(r.parentMatrix), u.copy(r.parentMatrixWorld));
		let g = t.clone().multiply(n).multiply(i),
			y = new Je;
		y.extractRotation(u);
		let d = new Je;
		d.copyPosition(u);
		let p = d.clone().invert().multiply(u),
			_ = y.clone().invert().multiply(p),
			v = s,
			x = new Je;
		if (m === 0) x.copy(y).multiply(g).multiply(_).multiply(v);
		else if (m === 1) x.copy(y).multiply(_).multiply(g).multiply(v);
		else {
			let V = new Je().scale(new re().setFromMatrixScale(h)).clone().invert(),
				k = _.clone().multiply(V);
			x.copy(y).multiply(g).multiply(k).multiply(v)
		}
		let M = c.clone().invert(),
			I = o.clone().invert(),
			w = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(i).multiply(M).multiply(a).multiply(o).multiply(s).multiply(I),
			L = new Je().copyPosition(w),
			T = u.clone().multiply(L);
		return f.copyPosition(T), w = f.clone().multiply(x), w.premultiply(u.invert()), w
	}

	function a0(r) {
		r = r || 0;
		let e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
		return r === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[r]
	}

	function Ed(r) {
		return r.split(",").map(function(t) {
			return parseFloat(t)
		})
	}

	function l0(r, e, t) {
		return e === void 0 && (e = 0), t === void 0 && (t = r.byteLength), new TextDecoder().decode(new Uint8Array(r, e, t))
	}

	function yb(r, e) {
		for (let t = 0, n = r.length, i = e.length; t < i; t++, n++) r[n] = e[t]
	}

	function vb(r, e, t, n) {
		for (let i = t, s = 0; i < n; i++, s++) r[s] = e[i];
		return r
	}

	function s0(r, e, t) {
		return r.slice(0, e).concat(t).concat(r.slice(e))
	}
	var eh = class extends Ot {
		constructor(e) {
			super(e)
		}
		load(e, t, n, i) {
			let s = this,
				o = s.path === "" ? ds.extractUrlBase(e) : s.path,
				a = new jn(s.manager);
			a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
				try {
					t(s.parse(l, o))
				} catch (c) {
					i ? i(c) : console.error(c), s.manager.itemError(e)
				}
			}, n, i)
		}
		parse(e, t) {
			function n(D, O) {
				let W = [],
					z = D.childNodes;
				for (let j = 0, be = z.length; j < be; j++) {
					let Re = z[j];
					Re.nodeName === O && W.push(Re)
				}
				return W
			}

			function i(D) {
				if (D.length === 0) return [];
				let O = D.trim().split(/\s+/),
					W = new Array(O.length);
				for (let z = 0, j = O.length; z < j; z++) W[z] = O[z];
				return W
			}

			function s(D) {
				if (D.length === 0) return [];
				let O = D.trim().split(/\s+/),
					W = new Array(O.length);
				for (let z = 0, j = O.length; z < j; z++) W[z] = parseFloat(O[z]);
				return W
			}

			function o(D) {
				if (D.length === 0) return [];
				let O = D.trim().split(/\s+/),
					W = new Array(O.length);
				for (let z = 0, j = O.length; z < j; z++) W[z] = parseInt(O[z]);
				return W
			}

			function a(D) {
				return D.substring(1)
			}

			function l() {
				return "three_default_" + q0++
			}

			function c(D) {
				return Object.keys(D).length === 0
			}

			function u(D) {
				return {
					unit: h(n(D, "unit")[0]),
					upAxis: f(n(D, "up_axis")[0])
				}
			}

			function h(D) {
				return D !== void 0 && D.hasAttribute("meter") === !0 ? parseFloat(D.getAttribute("meter")) : 1
			}

			function f(D) {
				return D !== void 0 ? D.textContent : "Y_UP"
			}

			function m(D, O, W, z) {
				let j = n(D, O)[0];
				if (j !== void 0) {
					let be = n(j, W);
					for (let Re = 0; Re < be.length; Re++) z(be[Re])
				}
			}

			function g(D, O) {
				for (let W in D) {
					let z = D[W];
					z.build = O(D[W])
				}
			}

			function y(D, O) {
				return D.build !== void 0 || (D.build = O(D)), D.build
			}

			function d(D) {
				let O = {
						sources: {},
						samplers: {},
						channels: {}
					},
					W = !1;
				for (let z = 0, j = D.childNodes.length; z < j; z++) {
					let be = D.childNodes[z];
					if (be.nodeType !== 1) continue;
					let Re;
					switch (be.nodeName) {
						case "source":
							Re = be.getAttribute("id"), O.sources[Re] = ve(be);
							break;
						case "sampler":
							Re = be.getAttribute("id"), O.samplers[Re] = p(be);
							break;
						case "channel":
							Re = be.getAttribute("target"), O.channels[Re] = _(be);
							break;
						case "animation":
							d(be), W = !0;
							break;
						default:
							console.log(be)
					}
				}
				W === !1 && (ut.animations[D.getAttribute("id") || Nn.generateUUID()] = O)
			}

			function p(D) {
				let O = {
					inputs: {}
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "input":
							let be = a(j.getAttribute("source")),
								Re = j.getAttribute("semantic");
							O.inputs[Re] = be;
							break
					}
				}
				return O
			}

			function _(D) {
				let O = {},
					z = D.getAttribute("target").split("/"),
					j = z.shift(),
					be = z.shift(),
					Re = be.indexOf("(") !== -1,
					Ze = be.indexOf(".") !== -1;
				if (Ze) z = be.split("."), be = z.shift(), O.member = z.shift();
				else if (Re) {
					let Ge = be.split("(");
					be = Ge.shift();
					for (let Xe = 0; Xe < Ge.length; Xe++) Ge[Xe] = parseInt(Ge[Xe].replace(/\)/, ""));
					O.indices = Ge
				}
				return O.id = j, O.sid = be, O.arraySyntax = Re, O.memberSyntax = Ze, O.sampler = a(D.getAttribute("source")), O
			}

			function v(D) {
				let O = [],
					W = D.channels,
					z = D.samplers,
					j = D.sources;
				for (let be in W)
					if (W.hasOwnProperty(be)) {
						let Re = W[be],
							Ze = z[Re.sampler],
							Ge = Ze.inputs.INPUT,
							Xe = Ze.inputs.OUTPUT,
							rt = j[Ge],
							Oe = j[Xe],
							nt = M(Re, rt, Oe);
						C(nt, O)
					} return O
			}

			function x(D) {
				return y(ut.animations[D], v)
			}

			function M(D, O, W) {
				let z = ut.nodes[D.id],
					j = qt(z.id),
					be = z.transforms[D.sid],
					Re = z.matrix.clone().transpose(),
					Ze, Ge, Xe, rt, Oe, nt, Qe = {};
				switch (be) {
					case "matrix":
						for (Xe = 0, rt = O.array.length; Xe < rt; Xe++)
							if (Ze = O.array[Xe], Ge = Xe * W.stride, Qe[Ze] === void 0 && (Qe[Ze] = {}), D.arraySyntax === !0) {
								let tn = W.array[Ge],
									kt = D.indices[0] + 4 * D.indices[1];
								Qe[Ze][kt] = tn
							} else
								for (Oe = 0, nt = W.stride; Oe < nt; Oe++) Qe[Ze][Oe] = W.array[Ge + Oe];
						break;
					case "translate":
						console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', be);
						break;
					case "rotate":
						console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', be);
						break;
					case "scale":
						console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', be);
						break
				}
				let ct = I(Qe, Re);
				return {
					name: j.uuid,
					keyframes: ct
				}
			}

			function I(D, O) {
				let W = [];
				for (let j in D) W.push({
					time: parseFloat(j),
					value: D[j]
				});
				W.sort(z);
				for (let j = 0; j < 16; j++) V(W, j, O.elements[j]);
				return W;

				function z(j, be) {
					return j.time - be.time
				}
			}
			let w = new re,
				L = new re,
				T = new yn;

			function C(D, O) {
				let W = D.keyframes,
					z = D.name,
					j = [],
					be = [],
					Re = [],
					Ze = [];
				for (let Ge = 0, Xe = W.length; Ge < Xe; Ge++) {
					let rt = W[Ge],
						Oe = rt.time,
						nt = rt.value;
					it.fromArray(nt).transpose(), it.decompose(w, T, L), j.push(Oe), be.push(w.x, w.y, w.z), Re.push(T.x, T.y, T.z, T.w), Ze.push(L.x, L.y, L.z)
				}
				return be.length > 0 && O.push(new Hi(z + ".position", j, be)), Re.length > 0 && O.push(new zi(z + ".quaternion", j, Re)), Ze.length > 0 && O.push(new Hi(z + ".scale", j, Ze)), O
			}

			function V(D, O, W) {
				let z, j = !0,
					be, Re;
				for (be = 0, Re = D.length; be < Re; be++) z = D[be], z.value[O] === void 0 ? z.value[O] = null : j = !1;
				if (j === !0)
					for (be = 0, Re = D.length; be < Re; be++) z = D[be], z.value[O] = W;
				else k(D, O)
			}

			function k(D, O) {
				let W, z;
				for (let j = 0, be = D.length; j < be; j++) {
					let Re = D[j];
					if (Re.value[O] === null) {
						if (W = F(D, j, O), z = U(D, j, O), W === null) {
							Re.value[O] = z.value[O];
							continue
						}
						if (z === null) {
							Re.value[O] = W.value[O];
							continue
						}
						K(Re, W, z, O)
					}
				}
			}

			function F(D, O, W) {
				for (; O >= 0;) {
					let z = D[O];
					if (z.value[W] !== null) return z;
					O--
				}
				return null
			}

			function U(D, O, W) {
				for (; O < D.length;) {
					let z = D[O];
					if (z.value[W] !== null) return z;
					O++
				}
				return null
			}

			function K(D, O, W, z) {
				if (W.time - O.time === 0) {
					D.value[z] = O.value[z];
					return
				}
				D.value[z] = (D.time - O.time) * (W.value[z] - O.value[z]) / (W.time - O.time) + O.value[z]
			}

			function Z(D) {
				let O = {
					name: D.getAttribute("id") || "default",
					start: parseFloat(D.getAttribute("start") || 0),
					end: parseFloat(D.getAttribute("end") || 0),
					animations: []
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "instance_animation":
							O.animations.push(a(j.getAttribute("url")));
							break
					}
				}
				ut.clips[D.getAttribute("id")] = O
			}

			function Y(D) {
				let O = [],
					W = D.name,
					z = D.end - D.start || -1,
					j = D.animations;
				for (let be = 0, Re = j.length; be < Re; be++) {
					let Ze = x(j[be]);
					for (let Ge = 0, Xe = Ze.length; Ge < Xe; Ge++) O.push(Ze[Ge])
				}
				return new Ks(W, z, O)
			}

			function H(D) {
				return y(ut.clips[D], Y)
			}

			function oe(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "skin":
							O.id = a(j.getAttribute("source")), O.skin = de(j);
							break;
						case "morph":
							O.id = a(j.getAttribute("source")), console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
							break
					}
				}
				ut.controllers[D.getAttribute("id")] = O
			}

			function de(D) {
				let O = {
					sources: {}
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "bind_shape_matrix":
							O.bindShapeMatrix = s(j.textContent);
							break;
						case "source":
							let be = j.getAttribute("id");
							O.sources[be] = ve(j);
							break;
						case "joints":
							O.joints = te(j);
							break;
						case "vertex_weights":
							O.vertexWeights = fe(j);
							break
					}
				}
				return O
			}

			function te(D) {
				let O = {
					inputs: {}
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "input":
							let be = j.getAttribute("semantic"),
								Re = a(j.getAttribute("source"));
							O.inputs[be] = Re;
							break
					}
				}
				return O
			}

			function fe(D) {
				let O = {
					inputs: {}
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "input":
							let be = j.getAttribute("semantic"),
								Re = a(j.getAttribute("source")),
								Ze = parseInt(j.getAttribute("offset"));
							O.inputs[be] = {
								id: Re,
								offset: Ze
							};
							break;
						case "vcount":
							O.vcount = o(j.textContent);
							break;
						case "v":
							O.v = o(j.textContent);
							break
					}
				}
				return O
			}

			function me(D) {
				let O = {
						id: D.id
					},
					W = ut.geometries[O.id];
				return D.skin !== void 0 && (O.skin = P(D.skin), W.sources.skinIndices = O.skin.indices, W.sources.skinWeights = O.skin.weights), O
			}

			function P(D) {
				let W = {
						joints: [],
						indices: {
							array: [],
							stride: 4
						},
						weights: {
							array: [],
							stride: 4
						}
					},
					z = D.sources,
					j = D.vertexWeights,
					be = j.vcount,
					Re = j.v,
					Ze = j.inputs.JOINT.offset,
					Ge = j.inputs.WEIGHT.offset,
					Xe = D.sources[D.joints.inputs.JOINT],
					rt = D.sources[D.joints.inputs.INV_BIND_MATRIX],
					Oe = z[j.inputs.WEIGHT.id].array,
					nt = 0,
					Qe, ct, at;
				for (Qe = 0, at = be.length; Qe < at; Qe++) {
					let kt = be[Qe],
						Pt = [];
					for (ct = 0; ct < kt; ct++) {
						let Lt = Re[nt + Ze],
							_r = Re[nt + Ge],
							Zn = Oe[_r];
						Pt.push({
							index: Lt,
							weight: Zn
						}), nt += 2
					}
					for (Pt.sort(tn), ct = 0; ct < 4; ct++) {
						let Lt = Pt[ct];
						Lt !== void 0 ? (W.indices.array.push(Lt.index), W.weights.array.push(Lt.weight)) : (W.indices.array.push(0), W.weights.array.push(0))
					}
				}
				for (D.bindShapeMatrix ? W.bindMatrix = new Je().fromArray(D.bindShapeMatrix).transpose() : W.bindMatrix = new Je().identity(), Qe = 0, at = Xe.array.length; Qe < at; Qe++) {
					let kt = Xe.array[Qe],
						Pt = new Je().fromArray(rt.array, Qe * rt.stride).transpose();
					W.joints.push({
						name: kt,
						boneInverse: Pt
					})
				}
				return W;

				function tn(kt, Pt) {
					return Pt.weight - kt.weight
				}
			}

			function b(D) {
				return y(ut.controllers[D], me)
			}

			function S(D) {
				let O = {
					init_from: n(D, "init_from")[0].textContent
				};
				ut.images[D.getAttribute("id")] = O
			}

			function A(D) {
				return D.build !== void 0 ? D.build : D.init_from
			}

			function G(D) {
				let O = ut.images[D];
				return O !== void 0 ? y(O, A) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", D), null)
			}

			function J(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "profile_COMMON":
							O.profile = $(j);
							break
					}
				}
				ut.effects[D.getAttribute("id")] = O
			}

			function $(D) {
				let O = {
					surfaces: {},
					samplers: {}
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "newparam":
							le(j, O);
							break;
						case "technique":
							O.technique = Q(j);
							break;
						case "extra":
							O.extra = Me(j);
							break
					}
				}
				return O
			}

			function le(D, O) {
				let W = D.getAttribute("sid");
				for (let z = 0, j = D.childNodes.length; z < j; z++) {
					let be = D.childNodes[z];
					if (be.nodeType === 1) switch (be.nodeName) {
						case "surface":
							O.surfaces[W] = N(be);
							break;
						case "sampler2D":
							O.samplers[W] = pe(be);
							break
					}
				}
			}

			function N(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "init_from":
							O.init_from = j.textContent;
							break
					}
				}
				return O
			}

			function pe(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "source":
							O.source = j.textContent;
							break
					}
				}
				return O
			}

			function Q(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "constant":
						case "lambert":
						case "blinn":
						case "phong":
							O.type = j.nodeName, O.parameters = he(j);
							break;
						case "extra":
							O.extra = Me(j);
							break
					}
				}
				return O
			}

			function he(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "emission":
						case "diffuse":
						case "specular":
						case "bump":
						case "ambient":
						case "shininess":
						case "transparency":
							O[j.nodeName] = ye(j);
							break;
						case "transparent":
							O[j.nodeName] = {
								opaque: j.hasAttribute("opaque") ? j.getAttribute("opaque") : "A_ONE",
								data: ye(j)
							};
							break
					}
				}
				return O
			}

			function ye(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "color":
							O[j.nodeName] = s(j.textContent);
							break;
						case "float":
							O[j.nodeName] = parseFloat(j.textContent);
							break;
						case "texture":
							O[j.nodeName] = {
								id: j.getAttribute("texture"),
								extra: Ee(j)
							};
							break
					}
				}
				return O
			}

			function Ee(D) {
				let O = {
					technique: {}
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "extra":
							ie(j, O);
							break
					}
				}
				return O
			}

			function ie(D, O) {
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "technique":
							q(j, O);
							break
					}
				}
			}

			function q(D, O) {
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "repeatU":
						case "repeatV":
						case "offsetU":
						case "offsetV":
							O.technique[j.nodeName] = parseFloat(j.textContent);
							break;
						case "wrapU":
						case "wrapV":
							j.textContent.toUpperCase() === "TRUE" ? O.technique[j.nodeName] = 1 : j.textContent.toUpperCase() === "FALSE" ? O.technique[j.nodeName] = 0 : O.technique[j.nodeName] = parseInt(j.textContent);
							break;
						case "bump":
							O[j.nodeName] = Ke(j);
							break
					}
				}
			}

			function Me(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "technique":
							O.technique = Pe(j);
							break
					}
				}
				return O
			}

			function Pe(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "double_sided":
							O[j.nodeName] = parseInt(j.textContent);
							break;
						case "bump":
							O[j.nodeName] = Ke(j);
							break
					}
				}
				return O
			}

			function Ke(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "texture":
							O[j.nodeName] = {
								id: j.getAttribute("texture"),
								texcoord: j.getAttribute("texcoord"),
								extra: Ee(j)
							};
							break
					}
				}
				return O
			}

			function R(D) {
				return D
			}

			function E(D) {
				return y(ut.effects[D], R)
			}

			function B(D) {
				let O = {
					name: D.getAttribute("name")
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "instance_effect":
							O.url = a(j.getAttribute("url"));
							break
					}
				}
				ut.materials[D.getAttribute("id")] = O
			}

			function ne(D) {
				let O, W = D.slice((D.lastIndexOf(".") - 1 >>> 0) + 2);
				switch (W = W.toLowerCase(), W) {
					case "tga":
						O = Eh;
						break;
					default:
						O = np
				}
				return O
			}

			function X(D) {
				let O = E(D.url),
					W = O.profile.technique,
					z;
				switch (W.type) {
					case "phong":
					case "blinn":
						z = new Xt;
						break;
					case "lambert":
						z = new fa;
						break;
					default:
						z = new Ti;
						break
				}
				z.name = D.name || "";

				function j(Ge, Xe = null) {
					let rt = O.profile.samplers[Ge.id],
						Oe = null;
					if (rt !== void 0) {
						let nt = O.profile.surfaces[rt.source];
						Oe = G(nt.init_from)
					} else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."), Oe = G(Ge.id);
					if (Oe !== null) {
						let nt = ne(Oe);
						if (nt !== void 0) {
							let Qe = nt.load(Oe),
								ct = Ge.extra;
							if (ct !== void 0 && ct.technique !== void 0 && c(ct.technique) === !1) {
								let at = ct.technique;
								Qe.wrapS = at.wrapU ? Qt : Wt, Qe.wrapT = at.wrapV ? Qt : Wt, Qe.offset.set(at.offsetU || 0, at.offsetV || 0), Qe.repeat.set(at.repeatU || 1, at.repeatV || 1)
							} else Qe.wrapS = Qt, Qe.wrapT = Qt;
							return Xe !== null && (Qe.colorSpace = Xe), Qe
						} else return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", Oe), null
					} else return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", Ge.id), null
				}
				let be = W.parameters;
				for (let Ge in be) {
					let Xe = be[Ge];
					switch (Ge) {
						case "diffuse":
							Xe.color && z.color.fromArray(Xe.color), Xe.texture && (z.map = j(Xe.texture, ot));
							break;
						case "specular":
							Xe.color && z.specular && z.specular.fromArray(Xe.color), Xe.texture && (z.specularMap = j(Xe.texture));
							break;
						case "bump":
							Xe.texture && (z.normalMap = j(Xe.texture));
							break;
						case "ambient":
							Xe.texture && (z.lightMap = j(Xe.texture, ot));
							break;
						case "shininess":
							Xe.float && z.shininess && (z.shininess = Xe.float);
							break;
						case "emission":
							Xe.color && z.emissive && z.emissive.fromArray(Xe.color), Xe.texture && (z.emissiveMap = j(Xe.texture, ot));
							break
					}
				}
				z.color.convertSRGBToLinear(), z.specular && z.specular.convertSRGBToLinear(), z.emissive && z.emissive.convertSRGBToLinear();
				let Re = be.transparent,
					Ze = be.transparency;
				if (Ze === void 0 && Re && (Ze = {
						float: 1
					}), Re === void 0 && Ze && (Re = {
						opaque: "A_ONE",
						data: {
							color: [1, 1, 1, 1]
						}
					}), Re && Ze)
					if (Re.data.texture) z.transparent = !0;
					else {
						let Ge = Re.data.color;
						switch (Re.opaque) {
							case "A_ONE":
								z.opacity = Ge[3] * Ze.float;
								break;
							case "RGB_ZERO":
								z.opacity = 1 - Ge[0] * Ze.float;
								break;
							case "A_ZERO":
								z.opacity = 1 - Ge[3] * Ze.float;
								break;
							case "RGB_ONE":
								z.opacity = Ge[0] * Ze.float;
								break;
							default:
								console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', Re.opaque)
						}
						z.opacity < 1 && (z.transparent = !0)
					} if (W.extra !== void 0 && W.extra.technique !== void 0) {
					let Ge = W.extra.technique;
					for (let Xe in Ge) {
						let rt = Ge[Xe];
						switch (Xe) {
							case "double_sided":
								z.side = rt === 1 ? wn : _i;
								break;
							case "bump":
								z.normalMap = j(rt.texture), z.normalScale = new Ce(1, 1);
								break
						}
					}
				}
				return z
			}

			function ae(D) {
				return y(ut.materials[D], X)
			}

			function ge(D) {
				let O = {
					name: D.getAttribute("name")
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "optics":
							O.optics = ue(j);
							break
					}
				}
				ut.cameras[D.getAttribute("id")] = O
			}

			function ue(D) {
				for (let O = 0; O < D.childNodes.length; O++) {
					let W = D.childNodes[O];
					switch (W.nodeName) {
						case "technique_common":
							return se(W)
					}
				}
				return {}
			}

			function se(D) {
				let O = {};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					switch (z.nodeName) {
						case "perspective":
						case "orthographic":
							O.technique = z.nodeName, O.parameters = _e(z);
							break
					}
				}
				return O
			}

			function _e(D) {
				let O = {};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					switch (z.nodeName) {
						case "xfov":
						case "yfov":
						case "xmag":
						case "ymag":
						case "znear":
						case "zfar":
						case "aspect_ratio":
							O[z.nodeName] = parseFloat(z.textContent);
							break
					}
				}
				return O
			}

			function Se(D) {
				let O;
				switch (D.optics.technique) {
					case "perspective":
						O = new Yt(D.optics.parameters.yfov, D.optics.parameters.aspect_ratio, D.optics.parameters.znear, D.optics.parameters.zfar);
						break;
					case "orthographic":
						let W = D.optics.parameters.ymag,
							z = D.optics.parameters.xmag,
							j = D.optics.parameters.aspect_ratio;
						z = z === void 0 ? W * j : z, W = W === void 0 ? z / j : W, z *= .5, W *= .5, O = new cr(-z, z, W, -W, D.optics.parameters.znear, D.optics.parameters.zfar);
						break;
					default:
						O = new Yt;
						break
				}
				return O.name = D.name || "", O
			}

			function Ne(D) {
				let O = ut.cameras[D];
				return O !== void 0 ? y(O, Se) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", D), null)
			}

			function Fe(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "technique_common":
							O = ke(j);
							break
					}
				}
				ut.lights[D.getAttribute("id")] = O
			}

			function ke(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "directional":
						case "point":
						case "spot":
						case "ambient":
							O.technique = j.nodeName, O.parameters = je(j)
					}
				}
				return O
			}

			function je(D) {
				let O = {};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "color":
							let be = s(j.textContent);
							O.color = new qe().fromArray(be).convertSRGBToLinear();
							break;
						case "falloff_angle":
							O.falloffAngle = parseFloat(j.textContent);
							break;
						case "quadratic_attenuation":
							let Re = parseFloat(j.textContent);
							O.distance = Re ? Math.sqrt(1 / Re) : 0;
							break
					}
				}
				return O
			}

			function We(D) {
				let O;
				switch (D.technique) {
					case "directional":
						O = new hr;
						break;
					case "point":
						O = new Zs;
						break;
					case "spot":
						O = new ma;
						break;
					case "ambient":
						O = new fr;
						break
				}
				return D.parameters.color && O.color.copy(D.parameters.color), D.parameters.distance && (O.distance = D.parameters.distance), O
			}

			function ce(D) {
				let O = ut.lights[D];
				return O !== void 0 ? y(O, We) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", D), null)
			}

			function Le(D) {
				let O = {
						name: D.getAttribute("name"),
						sources: {},
						vertices: {},
						primitives: []
					},
					W = n(D, "mesh")[0];
				if (W !== void 0) {
					for (let z = 0; z < W.childNodes.length; z++) {
						let j = W.childNodes[z];
						if (j.nodeType !== 1) continue;
						let be = j.getAttribute("id");
						switch (j.nodeName) {
							case "source":
								O.sources[be] = ve(j);
								break;
							case "vertices":
								O.vertices = Ie(j);
								break;
							case "polygons":
								console.warn("THREE.ColladaLoader: Unsupported primitive type: ", j.nodeName);
								break;
							case "lines":
							case "linestrips":
							case "polylist":
							case "triangles":
								O.primitives.push(De(j));
								break;
							default:
								console.log(j)
						}
					}
					ut.geometries[D.getAttribute("id")] = O
				}
			}

			function ve(D) {
				let O = {
					array: [],
					stride: 3
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "float_array":
							O.array = s(z.textContent);
							break;
						case "Name_array":
							O.array = i(z.textContent);
							break;
						case "technique_common":
							let j = n(z, "accessor")[0];
							j !== void 0 && (O.stride = parseInt(j.getAttribute("stride")));
							break
					}
				}
				return O
			}

			function Ie(D) {
				let O = {};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					z.nodeType === 1 && (O[z.getAttribute("semantic")] = a(z.getAttribute("source")))
				}
				return O
			}

			function De(D) {
				let O = {
					type: D.nodeName,
					material: D.getAttribute("material"),
					count: parseInt(D.getAttribute("count")),
					inputs: {},
					stride: 0,
					hasUV: !1
				};
				for (let W = 0, z = D.childNodes.length; W < z; W++) {
					let j = D.childNodes[W];
					if (j.nodeType === 1) switch (j.nodeName) {
						case "input":
							let be = a(j.getAttribute("source")),
								Re = j.getAttribute("semantic"),
								Ze = parseInt(j.getAttribute("offset")),
								Ge = parseInt(j.getAttribute("set")),
								Xe = Ge > 0 ? Re + Ge : Re;
							O.inputs[Xe] = {
								id: be,
								offset: Ze
							}, O.stride = Math.max(O.stride, Ze + 1), Re === "TEXCOORD" && (O.hasUV = !0);
							break;
						case "vcount":
							O.vcount = o(j.textContent);
							break;
						case "p":
							O.p = o(j.textContent);
							break
					}
				}
				return O
			}

			function et(D) {
				let O = {};
				for (let W = 0; W < D.length; W++) {
					let z = D[W];
					O[z.type] === void 0 && (O[z.type] = []), O[z.type].push(z)
				}
				return O
			}

			function vt(D) {
				let O = 0;
				for (let W = 0, z = D.length; W < z; W++) D[W].hasUV === !0 && O++;
				O > 0 && O < D.length && (D.uvsNeedsFix = !0)
			}

			function Mt(D) {
				let O = {},
					W = D.sources,
					z = D.vertices,
					j = D.primitives;
				if (j.length === 0) return {};
				let be = et(j);
				for (let Re in be) {
					let Ze = be[Re];
					vt(Ze), O[Re] = ft(Ze, W, z)
				}
				return O
			}

			function ft(D, O, W) {
				let z = {},
					j = {
						array: [],
						stride: 0
					},
					be = {
						array: [],
						stride: 0
					},
					Re = {
						array: [],
						stride: 0
					},
					Ze = {
						array: [],
						stride: 0
					},
					Ge = {
						array: [],
						stride: 0
					},
					Xe = {
						array: [],
						stride: 4
					},
					rt = {
						array: [],
						stride: 4
					},
					Oe = new St,
					nt = [],
					Qe = 0;
				for (let ct = 0; ct < D.length; ct++) {
					let at = D[ct],
						tn = at.inputs,
						kt = 0;
					switch (at.type) {
						case "lines":
						case "linestrips":
							kt = at.count * 2;
							break;
						case "triangles":
							kt = at.count * 3;
							break;
						case "polylist":
							for (let Pt = 0; Pt < at.count; Pt++) {
								let Lt = at.vcount[Pt];
								switch (Lt) {
									case 3:
										kt += 3;
										break;
									case 4:
										kt += 6;
										break;
									default:
										kt += (Lt - 2) * 3;
										break
								}
							}
							break;
						default:
							console.warn("THREE.ColladaLoader: Unknow primitive type:", at.type)
					}
					Oe.addGroup(Qe, kt, ct), Qe += kt, at.material && nt.push(at.material);
					for (let Pt in tn) {
						let Lt = tn[Pt];
						switch (Pt) {
							case "VERTEX":
								for (let _r in W) {
									let Zn = W[_r];
									switch (_r) {
										case "POSITION":
											let ro = j.array.length;
											if (Ue(at, O[Zn], Lt.offset, j.array), j.stride = O[Zn].stride, O.skinWeights && O.skinIndices && (Ue(at, O.skinIndices, Lt.offset, Xe.array), Ue(at, O.skinWeights, Lt.offset, rt.array)), at.hasUV === !1 && D.uvsNeedsFix === !0) {
												let j0 = (j.array.length - ro) / j.stride;
												for (let rp = 0; rp < j0; rp++) Re.array.push(0, 0)
											}
											break;
										case "NORMAL":
											Ue(at, O[Zn], Lt.offset, be.array), be.stride = O[Zn].stride;
											break;
										case "COLOR":
											Ue(at, O[Zn], Lt.offset, Ge.array), Ge.stride = O[Zn].stride;
											break;
										case "TEXCOORD":
											Ue(at, O[Zn], Lt.offset, Re.array), Re.stride = O[Zn].stride;
											break;
										case "TEXCOORD1":
											Ue(at, O[Zn], Lt.offset, Ze.array), Re.stride = O[Zn].stride;
											break;
										default:
											console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', _r)
									}
								}
								break;
							case "NORMAL":
								Ue(at, O[Lt.id], Lt.offset, be.array), be.stride = O[Lt.id].stride;
								break;
							case "COLOR":
								Ue(at, O[Lt.id], Lt.offset, Ge.array, !0), Ge.stride = O[Lt.id].stride;
								break;
							case "TEXCOORD":
								Ue(at, O[Lt.id], Lt.offset, Re.array), Re.stride = O[Lt.id].stride;
								break;
							case "TEXCOORD1":
								Ue(at, O[Lt.id], Lt.offset, Ze.array), Ze.stride = O[Lt.id].stride;
								break
						}
					}
				}
				return j.array.length > 0 && Oe.setAttribute("position", new ze(j.array, j.stride)), be.array.length > 0 && Oe.setAttribute("normal", new ze(be.array, be.stride)), Ge.array.length > 0 && Oe.setAttribute("color", new ze(Ge.array, Ge.stride)), Re.array.length > 0 && Oe.setAttribute("uv", new ze(Re.array, Re.stride)), Ze.array.length > 0 && Oe.setAttribute("uv1", new ze(Ze.array, Ze.stride)), Xe.array.length > 0 && Oe.setAttribute("skinIndex", new ze(Xe.array, Xe.stride)), rt.array.length > 0 && Oe.setAttribute("skinWeight", new ze(rt.array, rt.stride)), z.data = Oe, z.type = D[0].type, z.materialKeys = nt, z
			}

			function Ue(D, O, W, z, j = !1) {
				let be = D.p,
					Re = D.stride,
					Ze = D.vcount;

				function Ge(Oe) {
					let nt = be[Oe + W] * rt,
						Qe = nt + rt;
					for (; nt < Qe; nt++) z.push(Xe[nt]);
					if (j) {
						let ct = z.length - rt - 1;
						fc.setRGB(z[ct + 0], z[ct + 1], z[ct + 2]).convertSRGBToLinear(), z[ct + 0] = fc.r, z[ct + 1] = fc.g, z[ct + 2] = fc.b
					}
				}
				let Xe = O.array,
					rt = O.stride;
				if (D.vcount !== void 0) {
					let Oe = 0;
					for (let nt = 0, Qe = Ze.length; nt < Qe; nt++) {
						let ct = Ze[nt];
						if (ct === 4) {
							let at = Oe + Re * 0,
								tn = Oe + Re * 1,
								kt = Oe + Re * 2,
								Pt = Oe + Re * 3;
							Ge(at), Ge(tn), Ge(Pt), Ge(tn), Ge(kt), Ge(Pt)
						} else if (ct === 3) {
							let at = Oe + Re * 0,
								tn = Oe + Re * 1,
								kt = Oe + Re * 2;
							Ge(at), Ge(tn), Ge(kt)
						} else if (ct > 4)
							for (let at = 1, tn = ct - 2; at <= tn; at++) {
								let kt = Oe + Re * 0,
									Pt = Oe + Re * at,
									Lt = Oe + Re * (at + 1);
								Ge(kt), Ge(Pt), Ge(Lt)
							}
						Oe += Re * ct
					}
				} else
					for (let Oe = 0, nt = be.length; Oe < nt; Oe += Re) Ge(Oe)
			}

			function Ye(D) {
				return y(ut.geometries[D], Mt)
			}

			function Be(D) {
				let O = {
					name: D.getAttribute("name") || "",
					joints: {},
					links: []
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "technique_common":
							zt(z, O);
							break
					}
				}
				ut.kinematicsModels[D.getAttribute("id")] = O
			}

			function tt(D) {
				return D.build !== void 0 ? D.build : D
			}

			function st(D) {
				return y(ut.kinematicsModels[D], tt)
			}

			function zt(D, O) {
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "joint":
							O.joints[z.getAttribute("sid")] = Hn(z);
							break;
						case "link":
							O.links.push(Ci(z));
							break
					}
				}
			}

			function Hn(D) {
				let O;
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "prismatic":
						case "revolute":
							O = si(z);
							break
					}
				}
				return O
			}

			function si(D) {
				let O = {
					sid: D.getAttribute("sid"),
					name: D.getAttribute("name") || "",
					axis: new re,
					limits: {
						min: 0,
						max: 0
					},
					type: D.nodeName,
					static: !1,
					zeroPosition: 0,
					middlePosition: 0
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "axis":
							let j = s(z.textContent);
							O.axis.fromArray(j);
							break;
						case "limits":
							let be = z.getElementsByTagName("max")[0],
								Re = z.getElementsByTagName("min")[0];
							O.limits.max = parseFloat(be.textContent), O.limits.min = parseFloat(Re.textContent);
							break
					}
				}
				return O.limits.min >= O.limits.max && (O.static = !0), O.middlePosition = (O.limits.min + O.limits.max) / 2, O
			}

			function Ci(D) {
				let O = {
					sid: D.getAttribute("sid"),
					name: D.getAttribute("name") || "",
					attachments: [],
					transforms: []
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "attachment_full":
							O.attachments.push(cc(z));
							break;
						case "matrix":
						case "translate":
						case "rotate":
							O.transforms.push(uc(z));
							break
					}
				}
				return O
			}

			function cc(D) {
				let O = {
					joint: D.getAttribute("joint").split("/").pop(),
					transforms: [],
					links: []
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "link":
							O.links.push(Ci(z));
							break;
						case "matrix":
						case "translate":
						case "rotate":
							O.transforms.push(uc(z));
							break
					}
				}
				return O
			}

			function uc(D) {
				let O = {
						type: D.nodeName
					},
					W = s(D.textContent);
				switch (O.type) {
					case "matrix":
						O.obj = new Je, O.obj.fromArray(W).transpose();
						break;
					case "translate":
						O.obj = new re, O.obj.fromArray(W);
						break;
					case "rotate":
						O.obj = new re, O.obj.fromArray(W), O.angle = Nn.degToRad(W[3]);
						break
				}
				return O
			}

			function _h(D) {
				let O = {
					name: D.getAttribute("name") || "",
					rigidBodies: {}
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "rigid_body":
							O.rigidBodies[z.getAttribute("name")] = {}, Th(z, O.rigidBodies[z.getAttribute("name")]);
							break
					}
				}
				ut.physicsModels[D.getAttribute("id")] = O
			}

			function Th(D, O) {
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "technique_common":
							ee(z, O);
							break
					}
				}
			}

			function ee(D, O) {
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "inertia":
							O.inertia = s(z.textContent);
							break;
						case "mass":
							O.mass = s(z.textContent)[0];
							break
					}
				}
			}

			function Te(D) {
				let O = {
					bindJointAxis: []
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "bind_joint_axis":
							O.bindJointAxis.push(Ae(z));
							break
					}
				}
				ut.kinematicsScenes[a(D.getAttribute("url"))] = O
			}

			function Ae(D) {
				let O = {
					target: D.getAttribute("target").split("/").pop()
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "axis":
							let j = z.getElementsByTagName("param")[0];
							O.axis = j.textContent;
							let be = O.axis.split("inst_").pop().split("axis")[0];
							O.jointIndex = be.substring(0, be.length - 1);
							break
					}
				}
				return O
			}

			function xe(D) {
				return D.build !== void 0 ? D.build : D
			}

			function we(D) {
				return y(ut.kinematicsScenes[D], xe)
			}

			function $e() {
				let D = Object.keys(ut.kinematicsModels)[0],
					O = Object.keys(ut.kinematicsScenes)[0],
					W = Object.keys(ut.visualScenes)[0];
				if (D === void 0 || O === void 0) return;
				let z = st(D),
					j = we(O),
					be = io(W),
					Re = j.bindJointAxis,
					Ze = {};
				for (let rt = 0, Oe = Re.length; rt < Oe; rt++) {
					let nt = Re[rt],
						Qe = en.querySelector('[sid="' + nt.target + '"]');
					if (Qe) {
						let ct = Qe.parentElement;
						Ge(nt.jointIndex, ct)
					}
				}

				function Ge(rt, Oe) {
					let nt = Oe.getAttribute("name"),
						Qe = z.joints[rt];
					be.traverse(function(ct) {
						ct.name === nt && (Ze[rt] = {
							object: ct,
							transforms: lt(Oe),
							joint: Qe,
							position: Qe.zeroPosition
						})
					})
				}
				let Xe = new Je;
				ip = {
					joints: z && z.joints,
					getJointValue: function(rt) {
						let Oe = Ze[rt];
						if (Oe) return Oe.position;
						console.warn("THREE.ColladaLoader: Joint " + rt + " doesn't exist.")
					},
					setJointValue: function(rt, Oe) {
						let nt = Ze[rt];
						if (nt) {
							let Qe = nt.joint;
							if (Oe > Qe.limits.max || Oe < Qe.limits.min) console.warn("THREE.ColladaLoader: Joint " + rt + " value " + Oe + " outside of limits (min: " + Qe.limits.min + ", max: " + Qe.limits.max + ").");
							else if (Qe.static) console.warn("THREE.ColladaLoader: Joint " + rt + " is static.");
							else {
								let ct = nt.object,
									at = Qe.axis,
									tn = nt.transforms;
								it.identity();
								for (let kt = 0; kt < tn.length; kt++) {
									let Pt = tn[kt];
									if (Pt.sid && Pt.sid.indexOf(rt) !== -1) switch (Qe.type) {
										case "revolute":
											it.multiply(Xe.makeRotationAxis(at, Nn.degToRad(Oe)));
											break;
										case "prismatic":
											it.multiply(Xe.makeTranslation(at.x * Oe, at.y * Oe, at.z * Oe));
											break;
										default:
											console.warn("THREE.ColladaLoader: Unknown joint type: " + Qe.type);
											break
									} else switch (Pt.type) {
										case "matrix":
											it.multiply(Pt.obj);
											break;
										case "translate":
											it.multiply(Xe.makeTranslation(Pt.obj.x, Pt.obj.y, Pt.obj.z));
											break;
										case "scale":
											it.scale(Pt.obj);
											break;
										case "rotate":
											it.multiply(Xe.makeRotationAxis(Pt.obj, Pt.angle));
											break
									}
								}
								ct.matrix.copy(it), ct.matrix.decompose(ct.position, ct.quaternion, ct.scale), Ze[rt].position = Oe
							}
						} else console.log("THREE.ColladaLoader: " + rt + " does not exist.")
					}
				}
			}

			function lt(D) {
				let O = [],
					W = en.querySelector('[id="' + D.id + '"]');
				for (let z = 0; z < W.childNodes.length; z++) {
					let j = W.childNodes[z];
					if (j.nodeType !== 1) continue;
					let be, Re;
					switch (j.nodeName) {
						case "matrix":
							be = s(j.textContent);
							let Ze = new Je().fromArray(be).transpose();
							O.push({
								sid: j.getAttribute("sid"),
								type: j.nodeName,
								obj: Ze
							});
							break;
						case "translate":
						case "scale":
							be = s(j.textContent), Re = new re().fromArray(be), O.push({
								sid: j.getAttribute("sid"),
								type: j.nodeName,
								obj: Re
							});
							break;
						case "rotate":
							be = s(j.textContent), Re = new re().fromArray(be);
							let Ge = Nn.degToRad(be[3]);
							O.push({
								sid: j.getAttribute("sid"),
								type: j.nodeName,
								obj: Re,
								angle: Ge
							});
							break
					}
				}
				return O
			}

			function dt(D) {
				let O = D.getElementsByTagName("node");
				for (let W = 0; W < O.length; W++) {
					let z = O[W];
					z.hasAttribute("id") === !1 && z.setAttribute("id", l())
				}
			}
			let it = new Je,
				gt = new re;

			function mt(D) {
				let O = {
					name: D.getAttribute("name") || "",
					type: D.getAttribute("type"),
					id: D.getAttribute("id"),
					sid: D.getAttribute("sid"),
					matrix: new Je,
					nodes: [],
					instanceCameras: [],
					instanceControllers: [],
					instanceLights: [],
					instanceGeometries: [],
					instanceNodes: [],
					transforms: {}
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					if (z.nodeType !== 1) continue;
					let j;
					switch (z.nodeName) {
						case "node":
							O.nodes.push(z.getAttribute("id")), mt(z);
							break;
						case "instance_camera":
							O.instanceCameras.push(a(z.getAttribute("url")));
							break;
						case "instance_controller":
							O.instanceControllers.push(xt(z));
							break;
						case "instance_light":
							O.instanceLights.push(a(z.getAttribute("url")));
							break;
						case "instance_geometry":
							O.instanceGeometries.push(xt(z));
							break;
						case "instance_node":
							O.instanceNodes.push(a(z.getAttribute("url")));
							break;
						case "matrix":
							j = s(z.textContent), O.matrix.multiply(it.fromArray(j).transpose()), O.transforms[z.getAttribute("sid")] = z.nodeName;
							break;
						case "translate":
							j = s(z.textContent), gt.fromArray(j), O.matrix.multiply(it.makeTranslation(gt.x, gt.y, gt.z)), O.transforms[z.getAttribute("sid")] = z.nodeName;
							break;
						case "rotate":
							j = s(z.textContent);
							let be = Nn.degToRad(j[3]);
							O.matrix.multiply(it.makeRotationAxis(gt.fromArray(j), be)), O.transforms[z.getAttribute("sid")] = z.nodeName;
							break;
						case "scale":
							j = s(z.textContent), O.matrix.scale(gt.fromArray(j)), O.transforms[z.getAttribute("sid")] = z.nodeName;
							break;
						case "extra":
							break;
						default:
							console.log(z)
					}
				}
				return no(O.id) ? console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", O.id) : ut.nodes[O.id] = O, O
			}

			function xt(D) {
				let O = {
					id: a(D.getAttribute("url")),
					materials: {},
					skeletons: []
				};
				for (let W = 0; W < D.childNodes.length; W++) {
					let z = D.childNodes[W];
					switch (z.nodeName) {
						case "bind_material":
							let j = z.getElementsByTagName("instance_material");
							for (let be = 0; be < j.length; be++) {
								let Re = j[be],
									Ze = Re.getAttribute("symbol"),
									Ge = Re.getAttribute("target");
								O.materials[Ze] = a(Ge)
							}
							break;
						case "skeleton":
							O.skeletons.push(a(z.textContent));
							break;
						default:
							break
					}
				}
				return O
			}

			function Kt(D, O) {
				let W = [],
					z = [],
					j, be, Re;
				for (j = 0; j < D.length; j++) {
					let Xe = D[j],
						rt;
					if (no(Xe)) rt = qt(Xe), Zt(rt, O, W);
					else if (Ts(Xe)) {
						let nt = ut.visualScenes[Xe].children;
						for (let Qe = 0; Qe < nt.length; Qe++) {
							let ct = nt[Qe];
							if (ct.type === "JOINT") {
								let at = qt(ct.id);
								Zt(at, O, W)
							}
						}
					} else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", Xe)
				}
				for (j = 0; j < O.length; j++)
					for (be = 0; be < W.length; be++)
						if (Re = W[be], Re.bone.name === O[j].name) {
							z[j] = Re, Re.processed = !0;
							break
						} for (j = 0; j < W.length; j++) Re = W[j], Re.processed === !1 && (z.push(Re), Re.processed = !0);
				let Ze = [],
					Ge = [];
				for (j = 0; j < z.length; j++) Re = z[j], Ze.push(Re.bone), Ge.push(Re.boneInverse);
				return new ua(Ze, Ge)
			}

			function Zt(D, O, W) {
				D.traverse(function(z) {
					if (z.isBone === !0) {
						let j;
						for (let be = 0; be < O.length; be++) {
							let Re = O[be];
							if (Re.name === z.name) {
								j = Re.boneInverse;
								break
							}
						}
						j === void 0 && (j = new Je), W.push({
							bone: z,
							boneInverse: j,
							processed: !1
						})
					}
				})
			}

			function oi(D) {
				let O = [],
					W = D.matrix,
					z = D.nodes,
					j = D.type,
					be = D.instanceCameras,
					Re = D.instanceControllers,
					Ze = D.instanceLights,
					Ge = D.instanceGeometries,
					Xe = D.instanceNodes;
				for (let Oe = 0, nt = z.length; Oe < nt; Oe++) O.push(qt(z[Oe]));
				for (let Oe = 0, nt = be.length; Oe < nt; Oe++) {
					let Qe = Ne(be[Oe]);
					Qe !== null && O.push(Qe.clone())
				}
				for (let Oe = 0, nt = Re.length; Oe < nt; Oe++) {
					let Qe = Re[Oe],
						ct = b(Qe.id),
						at = Ye(ct.id),
						tn = bt(at, Qe.materials),
						kt = Qe.skeletons,
						Pt = ct.skin.joints,
						Lt = Kt(kt, Pt);
					for (let _r = 0, Zn = tn.length; _r < Zn; _r++) {
						let ro = tn[_r];
						ro.isSkinnedMesh && (ro.bind(Lt, ct.skin.bindMatrix), ro.normalizeSkinWeights()), O.push(ro)
					}
				}
				for (let Oe = 0, nt = Ze.length; Oe < nt; Oe++) {
					let Qe = ce(Ze[Oe]);
					Qe !== null && O.push(Qe.clone())
				}
				for (let Oe = 0, nt = Ge.length; Oe < nt; Oe++) {
					let Qe = Ge[Oe],
						ct = Ye(Qe.id),
						at = bt(ct, Qe.materials);
					for (let tn = 0, kt = at.length; tn < kt; tn++) O.push(at[tn])
				}
				for (let Oe = 0, nt = Xe.length; Oe < nt; Oe++) O.push(qt(Xe[Oe]).clone());
				let rt;
				if (z.length === 0 && O.length === 1) rt = O[0];
				else {
					rt = j === "JOINT" ? new as : new cn;
					for (let Oe = 0; Oe < O.length; Oe++) rt.add(O[Oe])
				}
				return rt.name = j === "JOINT" ? D.sid : D.name, rt.matrix.copy(W), rt.matrix.decompose(rt.position, rt.quaternion, rt.scale), rt
			}
			let Ri = new Ti({
				name: Ot.DEFAULT_MATERIAL_NAME,
				color: 16711935
			});

			function an(D, O) {
				let W = [];
				for (let z = 0, j = D.length; z < j; z++) {
					let be = O[D[z]];
					be === void 0 ? (console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", D[z]), W.push(Ri)) : W.push(ae(be))
				}
				return W
			}

			function bt(D, O) {
				let W = [];
				for (let z in D) {
					let j = D[z],
						be = an(j.materialKeys, O);
					if (be.length === 0 && (z === "lines" || z === "linestrips" ? be.push(new Ei) : be.push(new Xt)), z === "lines" || z === "linestrips")
						for (let Xe = 0, rt = be.length; Xe < rt; Xe++) {
							let Oe = be[Xe];
							if (Oe.isMeshPhongMaterial === !0 || Oe.isMeshLambertMaterial === !0) {
								let nt = new Ei;
								nt.color.copy(Oe.color), nt.opacity = Oe.opacity, nt.transparent = Oe.transparent, be[Xe] = nt
							}
						}
					let Re = j.data.attributes.skinIndex !== void 0,
						Ze = be.length === 1 ? be[0] : be,
						Ge;
					switch (z) {
						case "lines":
							Ge = new ls(j.data, Ze);
							break;
						case "linestrips":
							Ge = new js(j.data, Ze);
							break;
						case "triangles":
						case "polylist":
							Re ? Ge = new la(j.data, Ze) : Ge = new Nt(j.data, Ze);
							break
					}
					W.push(Ge)
				}
				return W
			}

			function no(D) {
				return ut.nodes[D] !== void 0
			}

			function qt(D) {
				return y(ut.nodes[D], oi)
			}

			function vr(D) {
				let O = {
					name: D.getAttribute("name"),
					children: []
				};
				dt(D);
				let W = n(D, "node");
				for (let z = 0; z < W.length; z++) O.children.push(mt(W[z]));
				ut.visualScenes[D.getAttribute("id")] = O
			}

			function Ka(D) {
				let O = new cn;
				O.name = D.name;
				let W = D.children;
				for (let z = 0; z < W.length; z++) {
					let j = W[z];
					O.add(qt(j.id))
				}
				return O
			}

			function Ts(D) {
				return ut.visualScenes[D] !== void 0
			}

			function io(D) {
				return y(ut.visualScenes[D], Ka)
			}

			function Rn(D) {
				let O = n(D, "instance_visual_scene")[0];
				return io(a(O.getAttribute("url")))
			}

			function xr() {
				let D = ut.clips;
				if (c(D) === !0) {
					if (c(ut.animations) === !1) {
						let O = [];
						for (let W in ut.animations) {
							let z = x(W);
							for (let j = 0, be = z.length; j < be; j++) O.push(z[j])
						}
						dc.push(new Ks("default", -1, O))
					}
				} else
					for (let O in D) dc.push(H(O))
			}

			function Za(D) {
				let O = "",
					W = [D];
				for (; W.length;) {
					let z = W.shift();
					z.nodeType === Node.TEXT_NODE ? O += z.textContent : (O += `
`, W.push.apply(W, z.childNodes))
				}
				return O.trim()
			}
			if (e.length === 0) return {
				scene: new ur
			};
			let Dn = new DOMParser().parseFromString(e, "application/xml"),
				en = n(Dn, "COLLADA")[0],
				Ja = Dn.getElementsByTagName("parsererror")[0];
			if (Ja !== void 0) {
				let D = n(Ja, "div")[0],
					O;
				return D ? O = D.textContent : O = Za(Ja), console.error(`THREE.ColladaLoader: Failed to parse collada file.
`, O), null
			}
			let hc = en.getAttribute("version");
			console.debug("THREE.ColladaLoader: File version", hc);
			let tp = u(n(en, "asset")[0]),
				np = new bi(this.manager);
			np.setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
			let Eh;
			gs && (Eh = new gs(this.manager), Eh.setPath(this.resourcePath || t));
			let fc = new qe,
				dc = [],
				ip = {},
				q0 = 0,
				ut = {
					animations: {},
					clips: {},
					controllers: {},
					images: {},
					effects: {},
					materials: {},
					cameras: {},
					lights: {},
					geometries: {},
					nodes: {},
					visualScenes: {},
					kinematicsModels: {},
					physicsModels: {},
					kinematicsScenes: {}
				};
			m(en, "library_animations", "animation", d), m(en, "library_animation_clips", "animation_clip", Z), m(en, "library_controllers", "controller", oe), m(en, "library_images", "image", S), m(en, "library_effects", "effect", J), m(en, "library_materials", "material", B), m(en, "library_cameras", "camera", ge), m(en, "library_lights", "light", Fe), m(en, "library_geometries", "geometry", Le), m(en, "library_nodes", "node", mt), m(en, "library_visual_scenes", "visual_scene", vr), m(en, "library_kinematics_models", "kinematics_model", Be), m(en, "library_physics_models", "physics_model", _h), m(en, "scene", "instance_kinematics_scene", Te), g(ut.animations, v), g(ut.clips, Y), g(ut.controllers, me), g(ut.images, A), g(ut.effects, R), g(ut.materials, X), g(ut.cameras, Se), g(ut.lights, We), g(ut.geometries, Mt), g(ut.visualScenes, Ka), xr(), $e();
			let pc = Rn(n(en, "scene")[0]);
			return pc.animations = dc, tp.upAxis === "Z_UP" && (console.warn("THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289."), pc.rotation.set(-Math.PI / 2, 0, 0)), pc.scale.multiplyScalar(tp.unit), {
				get animations() {
					return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."), dc
				},
				kinematics: ip,
				library: ut,
				scene: pc
			}
		}
	};
	var _t = (r, e) => () => (e || (e = {
			exports: {}
		}, r(e.exports, e)), e.exports),
		c0 = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.VERSION = void 0, r.VERSION = "9.0.1"
		}),
		Ft = _t((exports, module) => {
			"use strict";
			var __spreadArray = exports && exports.__spreadArray || function(r, e) {
				for (var t = 0, n = e.length, i = r.length; t < n; t++, i++) r[i] = e[t];
				return r
			};
			Object.defineProperty(exports, "__esModule", {
				value: !0
			}), exports.toFastProperties = exports.timer = exports.peek = exports.isES2015MapSupported = exports.PRINT_WARNING = exports.PRINT_ERROR = exports.packArray = exports.IDENTITY = exports.NOOP = exports.merge = exports.groupBy = exports.defaults = exports.assignNoOverwrite = exports.assign = exports.zipObject = exports.sortBy = exports.indexOf = exports.some = exports.difference = exports.every = exports.isObject = exports.isRegExp = exports.isArray = exports.partial = exports.uniq = exports.compact = exports.reduce = exports.findAll = exports.find = exports.cloneObj = exports.cloneArr = exports.contains = exports.has = exports.pick = exports.reject = exports.filter = exports.dropRight = exports.drop = exports.isFunction = exports.isUndefined = exports.isString = exports.forEach = exports.last = exports.first = exports.flatten = exports.map = exports.mapValues = exports.values = exports.keys = exports.isEmpty = void 0;

			function isEmpty(r) {
				return r && r.length === 0
			}
			exports.isEmpty = isEmpty;

			function keys(r) {
				return r == null ? [] : Object.keys(r)
			}
			exports.keys = keys;

			function values(r) {
				for (var e = [], t = Object.keys(r), n = 0; n < t.length; n++) e.push(r[t[n]]);
				return e
			}
			exports.values = values;

			function mapValues(r, e) {
				for (var t = [], n = keys(r), i = 0; i < n.length; i++) {
					var s = n[i];
					t.push(e.call(null, r[s], s))
				}
				return t
			}
			exports.mapValues = mapValues;

			function map(r, e) {
				for (var t = [], n = 0; n < r.length; n++) t.push(e.call(null, r[n], n));
				return t
			}
			exports.map = map;

			function flatten(r) {
				for (var e = [], t = 0; t < r.length; t++) {
					var n = r[t];
					Array.isArray(n) ? e = e.concat(flatten(n)) : e.push(n)
				}
				return e
			}
			exports.flatten = flatten;

			function first(r) {
				return isEmpty(r) ? void 0 : r[0]
			}
			exports.first = first;

			function last(r) {
				var e = r && r.length;
				return e ? r[e - 1] : void 0
			}
			exports.last = last;

			function forEach(r, e) {
				if (Array.isArray(r))
					for (var t = 0; t < r.length; t++) e.call(null, r[t], t);
				else if (isObject(r))
					for (var n = keys(r), t = 0; t < n.length; t++) {
						var i = n[t],
							s = r[i];
						e.call(null, s, i)
					} else throw Error("non exhaustive match")
			}
			exports.forEach = forEach;

			function isString(r) {
				return typeof r == "string"
			}
			exports.isString = isString;

			function isUndefined(r) {
				return r === void 0
			}
			exports.isUndefined = isUndefined;

			function isFunction(r) {
				return r instanceof Function
			}
			exports.isFunction = isFunction;

			function drop(r, e) {
				return e === void 0 && (e = 1), r.slice(e, r.length)
			}
			exports.drop = drop;

			function dropRight(r, e) {
				return e === void 0 && (e = 1), r.slice(0, r.length - e)
			}
			exports.dropRight = dropRight;

			function filter(r, e) {
				var t = [];
				if (Array.isArray(r))
					for (var n = 0; n < r.length; n++) {
						var i = r[n];
						e.call(null, i) && t.push(i)
					}
				return t
			}
			exports.filter = filter;

			function reject(r, e) {
				return filter(r, function(t) {
					return !e(t)
				})
			}
			exports.reject = reject;

			function pick(r, e) {
				for (var t = Object.keys(r), n = {}, i = 0; i < t.length; i++) {
					var s = t[i],
						o = r[s];
					e(o) && (n[s] = o)
				}
				return n
			}
			exports.pick = pick;

			function has(r, e) {
				return isObject(r) ? r.hasOwnProperty(e) : !1
			}
			exports.has = has;

			function contains(r, e) {
				return find(r, function(t) {
					return t === e
				}) !== void 0
			}
			exports.contains = contains;

			function cloneArr(r) {
				for (var e = [], t = 0; t < r.length; t++) e.push(r[t]);
				return e
			}
			exports.cloneArr = cloneArr;

			function cloneObj(r) {
				var e = {};
				for (var t in r) Object.prototype.hasOwnProperty.call(r, t) && (e[t] = r[t]);
				return e
			}
			exports.cloneObj = cloneObj;

			function find(r, e) {
				for (var t = 0; t < r.length; t++) {
					var n = r[t];
					if (e.call(null, n)) return n
				}
			}
			exports.find = find;

			function findAll(r, e) {
				for (var t = [], n = 0; n < r.length; n++) {
					var i = r[n];
					e.call(null, i) && t.push(i)
				}
				return t
			}
			exports.findAll = findAll;

			function reduce(r, e, t) {
				for (var n = Array.isArray(r), i = n ? r : values(r), s = n ? [] : keys(r), o = t, a = 0; a < i.length; a++) o = e.call(null, o, i[a], n ? a : s[a]);
				return o
			}
			exports.reduce = reduce;

			function compact(r) {
				return reject(r, function(e) {
					return e == null
				})
			}
			exports.compact = compact;

			function uniq(r, e) {
				e === void 0 && (e = function(n) {
					return n
				});
				var t = [];
				return reduce(r, function(n, i) {
					var s = e(i);
					return contains(t, s) ? n : (t.push(s), n.concat(i))
				}, [])
			}
			exports.uniq = uniq;

			function partial(r) {
				for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
				var n = [null],
					i = n.concat(e);
				return Function.bind.apply(r, i)
			}
			exports.partial = partial;

			function isArray(r) {
				return Array.isArray(r)
			}
			exports.isArray = isArray;

			function isRegExp(r) {
				return r instanceof RegExp
			}
			exports.isRegExp = isRegExp;

			function isObject(r) {
				return r instanceof Object
			}
			exports.isObject = isObject;

			function every(r, e) {
				for (var t = 0; t < r.length; t++)
					if (!e(r[t], t)) return !1;
				return !0
			}
			exports.every = every;

			function difference(r, e) {
				return reject(r, function(t) {
					return contains(e, t)
				})
			}
			exports.difference = difference;

			function some(r, e) {
				for (var t = 0; t < r.length; t++)
					if (e(r[t])) return !0;
				return !1
			}
			exports.some = some;

			function indexOf(r, e) {
				for (var t = 0; t < r.length; t++)
					if (r[t] === e) return t;
				return -1
			}
			exports.indexOf = indexOf;

			function sortBy(r, e) {
				var t = cloneArr(r);
				return t.sort(function(n, i) {
					return e(n) - e(i)
				}), t
			}
			exports.sortBy = sortBy;

			function zipObject(r, e) {
				if (r.length !== e.length) throw Error("can't zipObject with different number of keys and values!");
				for (var t = {}, n = 0; n < r.length; n++) t[r[n]] = e[n];
				return t
			}
			exports.zipObject = zipObject;

			function assign(r) {
				for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
				for (var n = 0; n < e.length; n++)
					for (var i = e[n], s = keys(i), o = 0; o < s.length; o++) {
						var a = s[o];
						r[a] = i[a]
					}
				return r
			}
			exports.assign = assign;

			function assignNoOverwrite(r) {
				for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
				for (var n = 0; n < e.length; n++)
					for (var i = e[n], s = keys(i), o = 0; o < s.length; o++) {
						var a = s[o];
						has(r, a) || (r[a] = i[a])
					}
				return r
			}
			exports.assignNoOverwrite = assignNoOverwrite;

			function defaults() {
				for (var r = [], e = 0; e < arguments.length; e++) r[e] = arguments[e];
				return assignNoOverwrite.apply(void 0, __spreadArray([{}], r))
			}
			exports.defaults = defaults;

			function groupBy(r, e) {
				var t = {};
				return forEach(r, function(n) {
					var i = e(n),
						s = t[i];
					s ? s.push(n) : t[i] = [n]
				}), t
			}
			exports.groupBy = groupBy;

			function merge(r, e) {
				for (var t = cloneObj(r), n = keys(e), i = 0; i < n.length; i++) {
					var s = n[i],
						o = e[s];
					t[s] = o
				}
				return t
			}
			exports.merge = merge;

			function NOOP() {}
			exports.NOOP = NOOP;

			function IDENTITY(r) {
				return r
			}
			exports.IDENTITY = IDENTITY;

			function packArray(r) {
				for (var e = [], t = 0; t < r.length; t++) {
					var n = r[t];
					e.push(n !== void 0 ? n : void 0)
				}
				return e
			}
			exports.packArray = packArray;

			function PRINT_ERROR(r) {
				console && console.error && console.error("Error: " + r)
			}
			exports.PRINT_ERROR = PRINT_ERROR;

			function PRINT_WARNING(r) {
				console && console.warn && console.warn("Warning: " + r)
			}
			exports.PRINT_WARNING = PRINT_WARNING;

			function isES2015MapSupported() {
				return typeof Map == "function"
			}
			exports.isES2015MapSupported = isES2015MapSupported;

			function peek(r) {
				return r[r.length - 1]
			}
			exports.peek = peek;

			function timer(r) {
				var e = new Date().getTime(),
					t = r(),
					n = new Date().getTime(),
					i = n - e;
				return {
					time: i,
					value: t
				}
			}
			exports.timer = timer;

			function toFastProperties(toBecomeFast) {
				function FakeConstructor() {}
				FakeConstructor.prototype = toBecomeFast;
				var fakeInstance = new FakeConstructor;

				function fakeAccess() {
					return typeof fakeInstance.bar
				}
				return fakeAccess(), fakeAccess(), toBecomeFast
			}
			exports.toFastProperties = toFastProperties
		}),
		Cd = _t((r, e) => {
			(function(t, n) {
				typeof define == "function" && define.amd ? define([], n) : typeof e == "object" && e.exports ? e.exports = n() : t.regexpToAst = n()
			})(typeof self < "u" ? self : r, function() {
				function t() {}
				t.prototype.saveState = function() {
					return {
						idx: this.idx,
						input: this.input,
						groupIdx: this.groupIdx
					}
				}, t.prototype.restoreState = function(d) {
					this.idx = d.idx, this.input = d.input, this.groupIdx = d.groupIdx
				}, t.prototype.pattern = function(d) {
					this.idx = 0, this.input = d, this.groupIdx = 0, this.consumeChar("/");
					var p = this.disjunction();
					this.consumeChar("/");
					for (var _ = {
							type: "Flags",
							loc: {
								begin: this.idx,
								end: d.length
							},
							global: !1,
							ignoreCase: !1,
							multiLine: !1,
							unicode: !1,
							sticky: !1
						}; this.isRegExpFlag();) switch (this.popChar()) {
						case "g":
							l(_, "global");
							break;
						case "i":
							l(_, "ignoreCase");
							break;
						case "m":
							l(_, "multiLine");
							break;
						case "u":
							l(_, "unicode");
							break;
						case "y":
							l(_, "sticky");
							break
					}
					if (this.idx !== this.input.length) throw Error("Redundant input: " + this.input.substring(this.idx));
					return {
						type: "Pattern",
						flags: _,
						value: p,
						loc: this.loc(0)
					}
				}, t.prototype.disjunction = function() {
					var d = [],
						p = this.idx;
					for (d.push(this.alternative()); this.peekChar() === "|";) this.consumeChar("|"), d.push(this.alternative());
					return {
						type: "Disjunction",
						value: d,
						loc: this.loc(p)
					}
				}, t.prototype.alternative = function() {
					for (var d = [], p = this.idx; this.isTerm();) d.push(this.term());
					return {
						type: "Alternative",
						value: d,
						loc: this.loc(p)
					}
				}, t.prototype.term = function() {
					return this.isAssertion() ? this.assertion() : this.atom()
				}, t.prototype.assertion = function() {
					var d = this.idx;
					switch (this.popChar()) {
						case "^":
							return {
								type: "StartAnchor", loc: this.loc(d)
							};
						case "$":
							return {
								type: "EndAnchor", loc: this.loc(d)
							};
						case "\\":
							switch (this.popChar()) {
								case "b":
									return {
										type: "WordBoundary", loc: this.loc(d)
									};
								case "B":
									return {
										type: "NonWordBoundary", loc: this.loc(d)
									}
							}
							throw Error("Invalid Assertion Escape");
						case "(":
							this.consumeChar("?");
							var p;
							switch (this.popChar()) {
								case "=":
									p = "Lookahead";
									break;
								case "!":
									p = "NegativeLookahead";
									break
							}
							c(p);
							var _ = this.disjunction();
							return this.consumeChar(")"), {
								type: p,
								value: _,
								loc: this.loc(d)
							}
					}
					u()
				}, t.prototype.quantifier = function(d) {
					var p, _ = this.idx;
					switch (this.popChar()) {
						case "*":
							p = {
								atLeast: 0,
								atMost: 1 / 0
							};
							break;
						case "+":
							p = {
								atLeast: 1,
								atMost: 1 / 0
							};
							break;
						case "?":
							p = {
								atLeast: 0,
								atMost: 1
							};
							break;
						case "{":
							var v = this.integerIncludingZero();
							switch (this.popChar()) {
								case "}":
									p = {
										atLeast: v,
										atMost: v
									};
									break;
								case ",":
									var x;
									this.isDigit() ? (x = this.integerIncludingZero(), p = {
										atLeast: v,
										atMost: x
									}) : p = {
										atLeast: v,
										atMost: 1 / 0
									}, this.consumeChar("}");
									break
							}
							if (d === !0 && p === void 0) return;
							c(p);
							break
					}
					if (!(d === !0 && p === void 0)) return c(p), this.peekChar(0) === "?" ? (this.consumeChar("?"), p.greedy = !1) : p.greedy = !0, p.type = "Quantifier", p.loc = this.loc(_), p
				}, t.prototype.atom = function() {
					var d, p = this.idx;
					switch (this.peekChar()) {
						case ".":
							d = this.dotAll();
							break;
						case "\\":
							d = this.atomEscape();
							break;
						case "[":
							d = this.characterClass();
							break;
						case "(":
							d = this.group();
							break
					}
					return d === void 0 && this.isPatternCharacter() && (d = this.patternCharacter()), c(d), d.loc = this.loc(p), this.isQuantifier() && (d.quantifier = this.quantifier()), d
				}, t.prototype.dotAll = function() {
					return this.consumeChar("."), {
						type: "Set",
						complement: !0,
						value: [o(`
`), o("\r"), o("\u2028"), o("\u2029")]
					}
				}, t.prototype.atomEscape = function() {
					switch (this.consumeChar("\\"), this.peekChar()) {
						case "1":
						case "2":
						case "3":
						case "4":
						case "5":
						case "6":
						case "7":
						case "8":
						case "9":
							return this.decimalEscapeAtom();
						case "d":
						case "D":
						case "s":
						case "S":
						case "w":
						case "W":
							return this.characterClassEscape();
						case "f":
						case "n":
						case "r":
						case "t":
						case "v":
							return this.controlEscapeAtom();
						case "c":
							return this.controlLetterEscapeAtom();
						case "0":
							return this.nulCharacterAtom();
						case "x":
							return this.hexEscapeSequenceAtom();
						case "u":
							return this.regExpUnicodeEscapeSequenceAtom();
						default:
							return this.identityEscapeAtom()
					}
				}, t.prototype.decimalEscapeAtom = function() {
					var d = this.positiveInteger();
					return {
						type: "GroupBackReference",
						value: d
					}
				}, t.prototype.characterClassEscape = function() {
					var d, p = !1;
					switch (this.popChar()) {
						case "d":
							d = f;
							break;
						case "D":
							d = f, p = !0;
							break;
						case "s":
							d = g;
							break;
						case "S":
							d = g, p = !0;
							break;
						case "w":
							d = m;
							break;
						case "W":
							d = m, p = !0;
							break
					}
					return c(d), {
						type: "Set",
						value: d,
						complement: p
					}
				}, t.prototype.controlEscapeAtom = function() {
					var d;
					switch (this.popChar()) {
						case "f":
							d = o("\f");
							break;
						case "n":
							d = o(`
`);
							break;
						case "r":
							d = o("\r");
							break;
						case "t":
							d = o("	");
							break;
						case "v":
							d = o("\v");
							break
					}
					return c(d), {
						type: "Character",
						value: d
					}
				}, t.prototype.controlLetterEscapeAtom = function() {
					this.consumeChar("c");
					var d = this.popChar();
					if (/[a-zA-Z]/.test(d) === !1) throw Error("Invalid ");
					var p = d.toUpperCase().charCodeAt(0) - 64;
					return {
						type: "Character",
						value: p
					}
				}, t.prototype.nulCharacterAtom = function() {
					return this.consumeChar("0"), {
						type: "Character",
						value: o("\0")
					}
				}, t.prototype.hexEscapeSequenceAtom = function() {
					return this.consumeChar("x"), this.parseHexDigits(2)
				}, t.prototype.regExpUnicodeEscapeSequenceAtom = function() {
					return this.consumeChar("u"), this.parseHexDigits(4)
				}, t.prototype.identityEscapeAtom = function() {
					var d = this.popChar();
					return {
						type: "Character",
						value: o(d)
					}
				}, t.prototype.classPatternCharacterAtom = function() {
					switch (this.peekChar()) {
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
						case "\\":
						case "]":
							throw Error("TBD");
						default:
							var d = this.popChar();
							return {
								type: "Character", value: o(d)
							}
					}
				}, t.prototype.characterClass = function() {
					var d = [],
						p = !1;
					for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), p = !0); this.isClassAtom();) {
						var _ = this.classAtom(),
							v = _.type === "Character";
						if (v && this.isRangeDash()) {
							this.consumeChar("-");
							var x = this.classAtom(),
								M = x.type === "Character";
							if (M) {
								if (x.value < _.value) throw Error("Range out of order in character class");
								d.push({
									from: _.value,
									to: x.value
								})
							} else a(_.value, d), d.push(o("-")), a(x.value, d)
						} else a(_.value, d)
					}
					return this.consumeChar("]"), {
						type: "Set",
						complement: p,
						value: d
					}
				}, t.prototype.classAtom = function() {
					switch (this.peekChar()) {
						case "]":
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
							throw Error("TBD");
						case "\\":
							return this.classEscape();
						default:
							return this.classPatternCharacterAtom()
					}
				}, t.prototype.classEscape = function() {
					switch (this.consumeChar("\\"), this.peekChar()) {
						case "b":
							return this.consumeChar("b"), {
								type: "Character",
								value: o("\b")
							};
						case "d":
						case "D":
						case "s":
						case "S":
						case "w":
						case "W":
							return this.characterClassEscape();
						case "f":
						case "n":
						case "r":
						case "t":
						case "v":
							return this.controlEscapeAtom();
						case "c":
							return this.controlLetterEscapeAtom();
						case "0":
							return this.nulCharacterAtom();
						case "x":
							return this.hexEscapeSequenceAtom();
						case "u":
							return this.regExpUnicodeEscapeSequenceAtom();
						default:
							return this.identityEscapeAtom()
					}
				}, t.prototype.group = function() {
					var d = !0;
					switch (this.consumeChar("("), this.peekChar(0)) {
						case "?":
							this.consumeChar("?"), this.consumeChar(":"), d = !1;
							break;
						default:
							this.groupIdx++;
							break
					}
					var p = this.disjunction();
					this.consumeChar(")");
					var _ = {
						type: "Group",
						capturing: d,
						value: p
					};
					return d && (_.idx = this.groupIdx), _
				}, t.prototype.positiveInteger = function() {
					var d = this.popChar();
					if (s.test(d) === !1) throw Error("Expecting a positive integer");
					for (; i.test(this.peekChar(0));) d += this.popChar();
					return parseInt(d, 10)
				}, t.prototype.integerIncludingZero = function() {
					var d = this.popChar();
					if (i.test(d) === !1) throw Error("Expecting an integer");
					for (; i.test(this.peekChar(0));) d += this.popChar();
					return parseInt(d, 10)
				}, t.prototype.patternCharacter = function() {
					var d = this.popChar();
					switch (d) {
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
						case "^":
						case "$":
						case "\\":
						case ".":
						case "*":
						case "+":
						case "?":
						case "(":
						case ")":
						case "[":
						case "|":
							throw Error("TBD");
						default:
							return {
								type: "Character", value: o(d)
							}
					}
				}, t.prototype.isRegExpFlag = function() {
					switch (this.peekChar(0)) {
						case "g":
						case "i":
						case "m":
						case "u":
						case "y":
							return !0;
						default:
							return !1
					}
				}, t.prototype.isRangeDash = function() {
					return this.peekChar() === "-" && this.isClassAtom(1)
				}, t.prototype.isDigit = function() {
					return i.test(this.peekChar(0))
				}, t.prototype.isClassAtom = function(d) {
					switch (d === void 0 && (d = 0), this.peekChar(d)) {
						case "]":
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
							return !1;
						default:
							return !0
					}
				}, t.prototype.isTerm = function() {
					return this.isAtom() || this.isAssertion()
				}, t.prototype.isAtom = function() {
					if (this.isPatternCharacter()) return !0;
					switch (this.peekChar(0)) {
						case ".":
						case "\\":
						case "[":
						case "(":
							return !0;
						default:
							return !1
					}
				}, t.prototype.isAssertion = function() {
					switch (this.peekChar(0)) {
						case "^":
						case "$":
							return !0;
						case "\\":
							switch (this.peekChar(1)) {
								case "b":
								case "B":
									return !0;
								default:
									return !1
							}
						case "(":
							return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
						default:
							return !1
					}
				}, t.prototype.isQuantifier = function() {
					var d = this.saveState();
					try {
						return this.quantifier(!0) !== void 0
					} catch {
						return !1
					} finally {
						this.restoreState(d)
					}
				}, t.prototype.isPatternCharacter = function() {
					switch (this.peekChar()) {
						case "^":
						case "$":
						case "\\":
						case ".":
						case "*":
						case "+":
						case "?":
						case "(":
						case ")":
						case "[":
						case "|":
						case "/":
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
							return !1;
						default:
							return !0
					}
				}, t.prototype.parseHexDigits = function(d) {
					for (var p = "", _ = 0; _ < d; _++) {
						var v = this.popChar();
						if (n.test(v) === !1) throw Error("Expecting a HexDecimal digits");
						p += v
					}
					var x = parseInt(p, 16);
					return {
						type: "Character",
						value: x
					}
				}, t.prototype.peekChar = function(d) {
					return d === void 0 && (d = 0), this.input[this.idx + d]
				}, t.prototype.popChar = function() {
					var d = this.peekChar(0);
					return this.consumeChar(), d
				}, t.prototype.consumeChar = function(d) {
					if (d !== void 0 && this.input[this.idx] !== d) throw Error("Expected: '" + d + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
					if (this.idx >= this.input.length) throw Error("Unexpected end of input");
					this.idx++
				}, t.prototype.loc = function(d) {
					return {
						begin: d,
						end: this.idx
					}
				};
				var n = /[0-9a-fA-F]/,
					i = /[0-9]/,
					s = /[1-9]/;

				function o(d) {
					return d.charCodeAt(0)
				}

				function a(d, p) {
					d.length !== void 0 ? d.forEach(function(_) {
						p.push(_)
					}) : p.push(d)
				}

				function l(d, p) {
					if (d[p] === !0) throw "duplicate flag " + p;
					d[p] = !0
				}

				function c(d) {
					if (d === void 0) throw Error("Internal Error - Should never get here!")
				}

				function u() {
					throw Error("Internal Error - Should never get here!")
				}
				var h, f = [];
				for (h = o("0"); h <= o("9"); h++) f.push(h);
				var m = [o("_")].concat(f);
				for (h = o("a"); h <= o("z"); h++) m.push(h);
				for (h = o("A"); h <= o("Z"); h++) m.push(h);
				var g = [o(" "), o("\f"), o(`
`), o("\r"), o("	"), o("\v"), o("	"), o("\xA0"), o("\u1680"), o("\u2000"), o("\u2001"), o("\u2002"), o("\u2003"), o("\u2004"), o("\u2005"), o("\u2006"), o("\u2007"), o("\u2008"), o("\u2009"), o("\u200A"), o("\u2028"), o("\u2029"), o("\u202F"), o("\u205F"), o("\u3000"), o("\uFEFF")];

				function y() {}
				return y.prototype.visitChildren = function(d) {
					for (var p in d) {
						var _ = d[p];
						d.hasOwnProperty(p) && (_.type !== void 0 ? this.visit(_) : Array.isArray(_) && _.forEach(function(v) {
							this.visit(v)
						}, this))
					}
				}, y.prototype.visit = function(d) {
					switch (d.type) {
						case "Pattern":
							this.visitPattern(d);
							break;
						case "Flags":
							this.visitFlags(d);
							break;
						case "Disjunction":
							this.visitDisjunction(d);
							break;
						case "Alternative":
							this.visitAlternative(d);
							break;
						case "StartAnchor":
							this.visitStartAnchor(d);
							break;
						case "EndAnchor":
							this.visitEndAnchor(d);
							break;
						case "WordBoundary":
							this.visitWordBoundary(d);
							break;
						case "NonWordBoundary":
							this.visitNonWordBoundary(d);
							break;
						case "Lookahead":
							this.visitLookahead(d);
							break;
						case "NegativeLookahead":
							this.visitNegativeLookahead(d);
							break;
						case "Character":
							this.visitCharacter(d);
							break;
						case "Set":
							this.visitSet(d);
							break;
						case "Group":
							this.visitGroup(d);
							break;
						case "GroupBackReference":
							this.visitGroupBackReference(d);
							break;
						case "Quantifier":
							this.visitQuantifier(d);
							break
					}
					this.visitChildren(d)
				}, y.prototype.visitPattern = function(d) {}, y.prototype.visitFlags = function(d) {}, y.prototype.visitDisjunction = function(d) {}, y.prototype.visitAlternative = function(d) {}, y.prototype.visitStartAnchor = function(d) {}, y.prototype.visitEndAnchor = function(d) {}, y.prototype.visitWordBoundary = function(d) {}, y.prototype.visitNonWordBoundary = function(d) {}, y.prototype.visitLookahead = function(d) {}, y.prototype.visitNegativeLookahead = function(d) {}, y.prototype.visitCharacter = function(d) {}, y.prototype.visitSet = function(d) {}, y.prototype.visitGroup = function(d) {}, y.prototype.visitGroupBackReference = function(d) {}, y.prototype.visitQuantifier = function(d) {}, {
					RegExpParser: t,
					BaseRegExpVisitor: y,
					VERSION: "0.5.0"
				}
			})
		}),
		Rd = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.clearRegExpParserCache = r.getRegExpAst = void 0;
			var e = Cd(),
				t = {},
				n = new e.RegExpParser;

			function i(o) {
				var a = o.toString();
				if (t.hasOwnProperty(a)) return t[a];
				var l = n.pattern(a);
				return t[a] = l, l
			}
			r.getRegExpAst = i;

			function s() {
				t = {}
			}
			r.clearRegExpParserCache = s
		}),
		xb = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var y = function(d, p) {
					return y = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(_, v) {
						_.__proto__ = v
					} || function(_, v) {
						for (var x in v) Object.prototype.hasOwnProperty.call(v, x) && (_[x] = v[x])
					}, y(d, p)
				};
				return function(d, p) {
					if (typeof p != "function" && p !== null) throw new TypeError("Class extends value " + String(p) + " is not a constructor or null");
					y(d, p);

					function _() {
						this.constructor = d
					}
					d.prototype = p === null ? Object.create(p) : (_.prototype = p.prototype, new _)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.canMatchCharCode = r.firstCharOptimizedIndices = r.getOptimizedStartCodesIndices = r.failedOptimizationPrefixMsg = void 0;
			var t = Cd(),
				n = Ft(),
				i = Rd(),
				s = u0(),
				o = "Complement Sets are not supported for first char optimization";
			r.failedOptimizationPrefixMsg = `Unable to use "first char" lexer optimizations:
`;

			function a(y, d) {
				d === void 0 && (d = !1);
				try {
					var p = i.getRegExpAst(y),
						_ = l(p.value, {}, p.flags.ignoreCase);
					return _
				} catch (x) {
					if (x.message === o) d && n.PRINT_WARNING("" + r.failedOptimizationPrefixMsg + ("	Unable to optimize: < " + y.toString() + ` >
`) + `	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
					else {
						var v = "";
						d && (v = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), n.PRINT_ERROR(r.failedOptimizationPrefixMsg + `
` + ("	Failed parsing: < " + y.toString() + ` >
`) + ("	Using the regexp-to-ast library version: " + t.VERSION + `
`) + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + v)
					}
				}
				return []
			}
			r.getOptimizedStartCodesIndices = a;

			function l(y, d, p) {
				switch (y.type) {
					case "Disjunction":
						for (var _ = 0; _ < y.value.length; _++) l(y.value[_], d, p);
						break;
					case "Alternative":
						for (var v = y.value, _ = 0; _ < v.length; _++) {
							var x = v[_];
							switch (x.type) {
								case "EndAnchor":
								case "GroupBackReference":
								case "Lookahead":
								case "NegativeLookahead":
								case "StartAnchor":
								case "WordBoundary":
								case "NonWordBoundary":
									continue
							}
							var M = x;
							switch (M.type) {
								case "Character":
									c(M.value, d, p);
									break;
								case "Set":
									if (M.complement === !0) throw Error(o);
									n.forEach(M.value, function(L) {
										if (typeof L == "number") c(L, d, p);
										else {
											var T = L;
											if (p === !0)
												for (var C = T.from; C <= T.to; C++) c(C, d, p);
											else {
												for (var C = T.from; C <= T.to && C < s.minOptimizationVal; C++) c(C, d, p);
												if (T.to >= s.minOptimizationVal)
													for (var V = T.from >= s.minOptimizationVal ? T.from : s.minOptimizationVal, k = T.to, F = s.charCodeToOptimizedIndex(V), U = s.charCodeToOptimizedIndex(k), K = F; K <= U; K++) d[K] = K
											}
										}
									});
									break;
								case "Group":
									l(M.value, d, p);
									break;
								default:
									throw Error("Non Exhaustive Match")
							}
							var I = M.quantifier !== void 0 && M.quantifier.atLeast === 0;
							if (M.type === "Group" && f(M) === !1 || M.type !== "Group" && I === !1) break
						}
						break;
					default:
						throw Error("non exhaustive match!")
				}
				return n.values(d)
			}
			r.firstCharOptimizedIndices = l;

			function c(y, d, p) {
				var _ = s.charCodeToOptimizedIndex(y);
				d[_] = _, p === !0 && u(y, d)
			}

			function u(y, d) {
				var p = String.fromCharCode(y),
					_ = p.toUpperCase();
				if (_ !== p) {
					var v = s.charCodeToOptimizedIndex(_.charCodeAt(0));
					d[v] = v
				} else {
					var x = p.toLowerCase();
					if (x !== p) {
						var v = s.charCodeToOptimizedIndex(x.charCodeAt(0));
						d[v] = v
					}
				}
			}

			function h(y, d) {
				return n.find(y.value, function(p) {
					if (typeof p == "number") return n.contains(d, p);
					var _ = p;
					return n.find(d, function(v) {
						return _.from <= v && v <= _.to
					}) !== void 0
				})
			}

			function f(y) {
				return y.quantifier && y.quantifier.atLeast === 0 ? !0 : y.value ? n.isArray(y.value) ? n.every(y.value, f) : f(y.value) : !1
			}
			var m = function(y) {
				e(d, y);

				function d(p) {
					var _ = y.call(this) || this;
					return _.targetCharCodes = p, _.found = !1, _
				}
				return d.prototype.visitChildren = function(p) {
					if (this.found !== !0) {
						switch (p.type) {
							case "Lookahead":
								this.visitLookahead(p);
								return;
							case "NegativeLookahead":
								this.visitNegativeLookahead(p);
								return
						}
						y.prototype.visitChildren.call(this, p)
					}
				}, d.prototype.visitCharacter = function(p) {
					n.contains(this.targetCharCodes, p.value) && (this.found = !0)
				}, d.prototype.visitSet = function(p) {
					p.complement ? h(p, this.targetCharCodes) === void 0 && (this.found = !0) : h(p, this.targetCharCodes) !== void 0 && (this.found = !0)
				}, d
			}(t.BaseRegExpVisitor);

			function g(y, d) {
				if (d instanceof RegExp) {
					var p = i.getRegExpAst(d),
						_ = new m(y);
					return _.visit(p), _.found
				} else return n.find(d, function(v) {
					return n.contains(y, v.charCodeAt(0))
				}) !== void 0
			}
			r.canMatchCharCode = g
		}),
		u0 = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var b = function(S, A) {
					return b = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(G, J) {
						G.__proto__ = J
					} || function(G, J) {
						for (var $ in J) Object.prototype.hasOwnProperty.call(J, $) && (G[$] = J[$])
					}, b(S, A)
				};
				return function(S, A) {
					if (typeof A != "function" && A !== null) throw new TypeError("Class extends value " + String(A) + " is not a constructor or null");
					b(S, A);

					function G() {
						this.constructor = S
					}
					S.prototype = A === null ? Object.create(A) : (G.prototype = A.prototype, new G)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.charCodeToOptimizedIndex = r.minOptimizationVal = r.buildLineBreakIssueMessage = r.LineTerminatorOptimizedTester = r.isShortPattern = r.isCustomPattern = r.cloneEmptyGroups = r.performWarningRuntimeChecks = r.performRuntimeChecks = r.addStickyFlag = r.addStartOfInput = r.findUnreachablePatterns = r.findModesThatDoNotExist = r.findInvalidGroupType = r.findDuplicatePatterns = r.findUnsupportedFlags = r.findStartOfInputAnchor = r.findEmptyMatchRegExps = r.findEndOfInputAnchor = r.findInvalidPatterns = r.findMissingPatterns = r.validatePatterns = r.analyzeTokenTypes = r.enableSticky = r.disableSticky = r.SUPPORT_STICKY = r.MODES = r.DEFAULT_MODE = void 0;
			var t = Cd(),
				n = th(),
				i = Ft(),
				s = xb(),
				o = Rd(),
				a = "PATTERN";
			r.DEFAULT_MODE = "defaultMode", r.MODES = "modes", r.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky == "boolean";

			function l() {
				r.SUPPORT_STICKY = !1
			}
			r.disableSticky = l;

			function c() {
				r.SUPPORT_STICKY = !0
			}
			r.enableSticky = c;

			function u(b, S) {
				S = i.defaults(S, {
					useSticky: r.SUPPORT_STICKY,
					debug: !1,
					safeMode: !1,
					positionTracking: "full",
					lineTerminatorCharacters: ["\r", `
`],
					tracer: function(R, E) {
						return E()
					}
				});
				var A = S.tracer;
				A("initCharCodeToOptimizedIndexMap", function() {
					P()
				});
				var G;
				A("Reject Lexer.NA", function() {
					G = i.reject(b, function(R) {
						return R[a] === n.Lexer.NA
					})
				});
				var J = !1,
					$;
				A("Transform Patterns", function() {
					J = !1, $ = i.map(G, function(R) {
						var E = R[a];
						if (i.isRegExp(E)) {
							var B = E.source;
							return B.length === 1 && B !== "^" && B !== "$" && B !== "." && !E.ignoreCase ? B : B.length === 2 && B[0] === "\\" && !i.contains(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], B[1]) ? B[1] : S.useSticky ? k(E) : V(E)
						} else {
							if (i.isFunction(E)) return J = !0, {
								exec: E
							};
							if (i.has(E, "exec")) return J = !0, E;
							if (typeof E == "string") {
								if (E.length === 1) return E;
								var ne = E.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"),
									X = new RegExp(ne);
								return S.useSticky ? k(X) : V(X)
							} else throw Error("non exhaustive match")
						}
					})
				});
				var le, N, pe, Q, he;
				A("misc mapping", function() {
					le = i.map(G, function(R) {
						return R.tokenTypeIdx
					}), N = i.map(G, function(R) {
						var E = R.GROUP;
						if (E !== n.Lexer.SKIPPED) {
							if (i.isString(E)) return E;
							if (i.isUndefined(E)) return !1;
							throw Error("non exhaustive match")
						}
					}), pe = i.map(G, function(R) {
						var E = R.LONGER_ALT;
						if (E) {
							var B = i.indexOf(G, E);
							return B
						}
					}), Q = i.map(G, function(R) {
						return R.PUSH_MODE
					}), he = i.map(G, function(R) {
						return i.has(R, "POP_MODE")
					})
				});
				var ye;
				A("Line Terminator Handling", function() {
					var R = de(S.lineTerminatorCharacters);
					ye = i.map(G, function(E) {
						return !1
					}), S.positionTracking !== "onlyOffset" && (ye = i.map(G, function(E) {
						if (i.has(E, "LINE_BREAKS")) return E.LINE_BREAKS;
						if (H(E, R) === !1) return s.canMatchCharCode(R, E.PATTERN)
					}))
				});
				var Ee, ie, q, Me;
				A("Misc Mapping #2", function() {
					Ee = i.map(G, Z), ie = i.map($, Y), q = i.reduce(G, function(R, E) {
						var B = E.GROUP;
						return i.isString(B) && B !== n.Lexer.SKIPPED && (R[B] = []), R
					}, {}), Me = i.map($, function(R, E) {
						return {
							pattern: $[E],
							longerAlt: pe[E],
							canLineTerminator: ye[E],
							isCustom: Ee[E],
							short: ie[E],
							group: N[E],
							push: Q[E],
							pop: he[E],
							tokenTypeIdx: le[E],
							tokenType: G[E]
						}
					})
				});
				var Pe = !0,
					Ke = [];
				return S.safeMode || A("First Char Optimization", function() {
					Ke = i.reduce(G, function(R, E, B) {
						if (typeof E.PATTERN == "string") {
							var ne = E.PATTERN.charCodeAt(0),
								X = me(ne);
							te(R, X, Me[B])
						} else if (i.isArray(E.START_CHARS_HINT)) {
							var ae;
							i.forEach(E.START_CHARS_HINT, function(ue) {
								var se = typeof ue == "string" ? ue.charCodeAt(0) : ue,
									_e = me(se);
								ae !== _e && (ae = _e, te(R, _e, Me[B]))
							})
						} else if (i.isRegExp(E.PATTERN))
							if (E.PATTERN.unicode) Pe = !1, S.ensureOptimizations && i.PRINT_ERROR("" + s.failedOptimizationPrefixMsg + ("	Unable to analyze < " + E.PATTERN.toString() + ` > pattern.
`) + `	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
							else {
								var ge = s.getOptimizedStartCodesIndices(E.PATTERN, S.ensureOptimizations);
								i.isEmpty(ge) && (Pe = !1), i.forEach(ge, function(ue) {
									te(R, ue, Me[B])
								})
							}
						else S.ensureOptimizations && i.PRINT_ERROR("" + s.failedOptimizationPrefixMsg + ("	TokenType: <" + E.name + `> is using a custom token pattern without providing <start_chars_hint> parameter.
`) + `	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), Pe = !1;
						return R
					}, [])
				}), A("ArrayPacking", function() {
					Ke = i.packArray(Ke)
				}), {
					emptyGroups: q,
					patternIdxToConfig: Me,
					charCodeToPatternIdxToConfig: Ke,
					hasCustom: J,
					canBeOptimized: Pe
				}
			}
			r.analyzeTokenTypes = u;

			function h(b, S) {
				var A = [],
					G = m(b);
				A = A.concat(G.errors);
				var J = g(G.valid),
					$ = J.valid;
				return A = A.concat(J.errors), A = A.concat(f($)), A = A.concat(I($)), A = A.concat(w($, S)), A = A.concat(L($)), A
			}
			r.validatePatterns = h;

			function f(b) {
				var S = [],
					A = i.filter(b, function(G) {
						return i.isRegExp(G[a])
					});
				return S = S.concat(d(A)), S = S.concat(v(A)), S = S.concat(x(A)), S = S.concat(M(A)), S = S.concat(p(A)), S
			}

			function m(b) {
				var S = i.filter(b, function(J) {
						return !i.has(J, a)
					}),
					A = i.map(S, function(J) {
						return {
							message: "Token Type: ->" + J.name + "<- missing static 'PATTERN' property",
							type: n.LexerDefinitionErrorType.MISSING_PATTERN,
							tokenTypes: [J]
						}
					}),
					G = i.difference(b, S);
				return {
					errors: A,
					valid: G
				}
			}
			r.findMissingPatterns = m;

			function g(b) {
				var S = i.filter(b, function(J) {
						var $ = J[a];
						return !i.isRegExp($) && !i.isFunction($) && !i.has($, "exec") && !i.isString($)
					}),
					A = i.map(S, function(J) {
						return {
							message: "Token Type: ->" + J.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
							type: n.LexerDefinitionErrorType.INVALID_PATTERN,
							tokenTypes: [J]
						}
					}),
					G = i.difference(b, S);
				return {
					errors: A,
					valid: G
				}
			}
			r.findInvalidPatterns = g;
			var y = /[^\\][\$]/;

			function d(b) {
				var S = function(J) {
						e($, J);

						function $() {
							var le = J !== null && J.apply(this, arguments) || this;
							return le.found = !1, le
						}
						return $.prototype.visitEndAnchor = function(le) {
							this.found = !0
						}, $
					}(t.BaseRegExpVisitor),
					A = i.filter(b, function(J) {
						var $ = J[a];
						try {
							var le = o.getRegExpAst($),
								N = new S;
							return N.visit(le), N.found
						} catch {
							return y.test($.source)
						}
					}),
					G = i.map(A, function(J) {
						return {
							message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + J.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
							type: n.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
							tokenTypes: [J]
						}
					});
				return G
			}
			r.findEndOfInputAnchor = d;

			function p(b) {
				var S = i.filter(b, function(G) {
						var J = G[a];
						return J.test("")
					}),
					A = i.map(S, function(G) {
						return {
							message: "Token Type: ->" + G.name + "<- static 'PATTERN' must not match an empty string",
							type: n.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
							tokenTypes: [G]
						}
					});
				return A
			}
			r.findEmptyMatchRegExps = p;
			var _ = /[^\\[][\^]|^\^/;

			function v(b) {
				var S = function(J) {
						e($, J);

						function $() {
							var le = J !== null && J.apply(this, arguments) || this;
							return le.found = !1, le
						}
						return $.prototype.visitStartAnchor = function(le) {
							this.found = !0
						}, $
					}(t.BaseRegExpVisitor),
					A = i.filter(b, function(J) {
						var $ = J[a];
						try {
							var le = o.getRegExpAst($),
								N = new S;
							return N.visit(le), N.found
						} catch {
							return _.test($.source)
						}
					}),
					G = i.map(A, function(J) {
						return {
							message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + J.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
							type: n.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
							tokenTypes: [J]
						}
					});
				return G
			}
			r.findStartOfInputAnchor = v;

			function x(b) {
				var S = i.filter(b, function(G) {
						var J = G[a];
						return J instanceof RegExp && (J.multiline || J.global)
					}),
					A = i.map(S, function(G) {
						return {
							message: "Token Type: ->" + G.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
							type: n.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
							tokenTypes: [G]
						}
					});
				return A
			}
			r.findUnsupportedFlags = x;

			function M(b) {
				var S = [],
					A = i.map(b, function($) {
						return i.reduce(b, function(le, N) {
							return $.PATTERN.source === N.PATTERN.source && !i.contains(S, N) && N.PATTERN !== n.Lexer.NA && (S.push(N), le.push(N)), le
						}, [])
					});
				A = i.compact(A);
				var G = i.filter(A, function($) {
						return $.length > 1
					}),
					J = i.map(G, function($) {
						var le = i.map($, function(pe) {
								return pe.name
							}),
							N = i.first($).PATTERN;
						return {
							message: "The same RegExp pattern ->" + N + "<-" + ("has been used in all of the following Token Types: " + le.join(", ") + " <-"),
							type: n.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
							tokenTypes: $
						}
					});
				return J
			}
			r.findDuplicatePatterns = M;

			function I(b) {
				var S = i.filter(b, function(G) {
						if (!i.has(G, "GROUP")) return !1;
						var J = G.GROUP;
						return J !== n.Lexer.SKIPPED && J !== n.Lexer.NA && !i.isString(J)
					}),
					A = i.map(S, function(G) {
						return {
							message: "Token Type: ->" + G.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
							type: n.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
							tokenTypes: [G]
						}
					});
				return A
			}
			r.findInvalidGroupType = I;

			function w(b, S) {
				var A = i.filter(b, function(J) {
						return J.PUSH_MODE !== void 0 && !i.contains(S, J.PUSH_MODE)
					}),
					G = i.map(A, function(J) {
						var $ = "Token Type: ->" + J.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + J.PUSH_MODE + "<-which does not exist";
						return {
							message: $,
							type: n.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
							tokenTypes: [J]
						}
					});
				return G
			}
			r.findModesThatDoNotExist = w;

			function L(b) {
				var S = [],
					A = i.reduce(b, function(G, J, $) {
						var le = J.PATTERN;
						return le === n.Lexer.NA || (i.isString(le) ? G.push({
							str: le,
							idx: $,
							tokenType: J
						}) : i.isRegExp(le) && C(le) && G.push({
							str: le.source,
							idx: $,
							tokenType: J
						})), G
					}, []);
				return i.forEach(b, function(G, J) {
					i.forEach(A, function($) {
						var le = $.str,
							N = $.idx,
							pe = $.tokenType;
						if (J < N && T(le, G.PATTERN)) {
							var Q = "Token: ->" + pe.name + `<- can never be matched.
` + ("Because it appears AFTER the Token Type ->" + G.name + "<-") + `in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
							S.push({
								message: Q,
								type: n.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
								tokenTypes: [G, pe]
							})
						}
					})
				}), S
			}
			r.findUnreachablePatterns = L;

			function T(b, S) {
				if (i.isRegExp(S)) {
					var A = S.exec(b);
					return A !== null && A.index === 0
				} else {
					if (i.isFunction(S)) return S(b, 0, [], {});
					if (i.has(S, "exec")) return S.exec(b, 0, [], {});
					if (typeof S == "string") return S === b;
					throw Error("non exhaustive match")
				}
			}

			function C(b) {
				var S = [".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"];
				return i.find(S, function(A) {
					return b.source.indexOf(A) !== -1
				}) === void 0
			}

			function V(b) {
				var S = b.ignoreCase ? "i" : "";
				return new RegExp("^(?:" + b.source + ")", S)
			}
			r.addStartOfInput = V;

			function k(b) {
				var S = b.ignoreCase ? "iy" : "y";
				return new RegExp("" + b.source, S)
			}
			r.addStickyFlag = k;

			function F(b, S, A) {
				var G = [];
				return i.has(b, r.DEFAULT_MODE) || G.push({
					message: "A MultiMode Lexer cannot be initialized without a <" + r.DEFAULT_MODE + `> property in its definition
`,
					type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
				}), i.has(b, r.MODES) || G.push({
					message: "A MultiMode Lexer cannot be initialized without a <" + r.MODES + `> property in its definition
`,
					type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
				}), i.has(b, r.MODES) && i.has(b, r.DEFAULT_MODE) && !i.has(b.modes, b.defaultMode) && G.push({
					message: "A MultiMode Lexer cannot be initialized with a " + r.DEFAULT_MODE + ": <" + b.defaultMode + `>which does not exist
`,
					type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
				}), i.has(b, r.MODES) && i.forEach(b.modes, function(J, $) {
					i.forEach(J, function(le, N) {
						i.isUndefined(le) && G.push({
							message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + ("<" + $ + "> at index: <" + N + `>
`),
							type: n.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
						})
					})
				}), G
			}
			r.performRuntimeChecks = F;

			function U(b, S, A) {
				var G = [],
					J = !1,
					$ = i.compact(i.flatten(i.mapValues(b.modes, function(pe) {
						return pe
					}))),
					le = i.reject($, function(pe) {
						return pe[a] === n.Lexer.NA
					}),
					N = de(A);
				return S && i.forEach(le, function(pe) {
					var Q = H(pe, N);
					if (Q !== !1) {
						var he = oe(pe, Q),
							ye = {
								message: he,
								type: Q.issue,
								tokenType: pe
							};
						G.push(ye)
					} else i.has(pe, "LINE_BREAKS") ? pe.LINE_BREAKS === !0 && (J = !0) : s.canMatchCharCode(N, pe.PATTERN) && (J = !0)
				}), S && !J && G.push({
					message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS
	for details.`,
					type: n.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
				}), G
			}
			r.performWarningRuntimeChecks = U;

			function K(b) {
				var S = {},
					A = i.keys(b);
				return i.forEach(A, function(G) {
					var J = b[G];
					if (i.isArray(J)) S[G] = [];
					else throw Error("non exhaustive match")
				}), S
			}
			r.cloneEmptyGroups = K;

			function Z(b) {
				var S = b.PATTERN;
				if (i.isRegExp(S)) return !1;
				if (i.isFunction(S) || i.has(S, "exec")) return !0;
				if (i.isString(S)) return !1;
				throw Error("non exhaustive match")
			}
			r.isCustomPattern = Z;

			function Y(b) {
				return i.isString(b) && b.length === 1 ? b.charCodeAt(0) : !1
			}
			r.isShortPattern = Y, r.LineTerminatorOptimizedTester = {
				test: function(b) {
					for (var S = b.length, A = this.lastIndex; A < S; A++) {
						var G = b.charCodeAt(A);
						if (G === 10) return this.lastIndex = A + 1, !0;
						if (G === 13) return b.charCodeAt(A + 1) === 10 ? this.lastIndex = A + 2 : this.lastIndex = A + 1, !0
					}
					return !1
				},
				lastIndex: 0
			};

			function H(b, S) {
				if (i.has(b, "LINE_BREAKS")) return !1;
				if (i.isRegExp(b.PATTERN)) {
					try {
						s.canMatchCharCode(S, b.PATTERN)
					} catch (A) {
						return {
							issue: n.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
							errMsg: A.message
						}
					}
					return !1
				} else {
					if (i.isString(b.PATTERN)) return !1;
					if (Z(b)) return {
						issue: n.LexerDefinitionErrorType.CUSTOM_LINE_BREAK
					};
					throw Error("non exhaustive match")
				}
			}

			function oe(b, S) {
				if (S.issue === n.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) return `Warning: unable to identify line terminator usage in pattern.
` + ("	The problem is in the <" + b.name + `> Token Type
`) + ("	 Root cause: " + S.errMsg + `.
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
				if (S.issue === n.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
` + ("	The problem is in the <" + b.name + `> Token Type
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
				throw Error("non exhaustive match")
			}
			r.buildLineBreakIssueMessage = oe;

			function de(b) {
				var S = i.map(b, function(A) {
					return i.isString(A) && A.length > 0 ? A.charCodeAt(0) : A
				});
				return S
			}

			function te(b, S, A) {
				b[S] === void 0 ? b[S] = [A] : b[S].push(A)
			}
			r.minOptimizationVal = 256;
			var fe = [];

			function me(b) {
				return b < r.minOptimizationVal ? b : fe[b]
			}
			r.charCodeToOptimizedIndex = me;

			function P() {
				if (i.isEmpty(fe)) {
					fe = new Array(65536);
					for (var b = 0; b < 65536; b++) fe[b] = b > 255 ? 255 + ~~(b / 255) : b
				}
			}
		}),
		Xl = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.isTokenType = r.hasExtendingTokensTypesMapProperty = r.hasExtendingTokensTypesProperty = r.hasCategoriesProperty = r.hasShortKeyProperty = r.singleAssignCategoriesToksMap = r.assignCategoriesMapProp = r.assignCategoriesTokensProp = r.assignTokenDefaultProps = r.expandCategories = r.augmentTokenTypes = r.tokenIdxToClass = r.tokenShortNameIdx = r.tokenStructuredMatcherNoCategories = r.tokenStructuredMatcher = void 0;
			var e = Ft();

			function t(y, d) {
				var p = y.tokenTypeIdx;
				return p === d.tokenTypeIdx ? !0 : d.isParent === !0 && d.categoryMatchesMap[p] === !0
			}
			r.tokenStructuredMatcher = t;

			function n(y, d) {
				return y.tokenTypeIdx === d.tokenTypeIdx
			}
			r.tokenStructuredMatcherNoCategories = n, r.tokenShortNameIdx = 1, r.tokenIdxToClass = {};

			function i(y) {
				var d = s(y);
				o(d), l(d), a(d), e.forEach(d, function(p) {
					p.isParent = p.categoryMatches.length > 0
				})
			}
			r.augmentTokenTypes = i;

			function s(y) {
				for (var d = e.cloneArr(y), p = y, _ = !0; _;) {
					p = e.compact(e.flatten(e.map(p, function(x) {
						return x.CATEGORIES
					})));
					var v = e.difference(p, d);
					d = d.concat(v), e.isEmpty(v) ? _ = !1 : p = v
				}
				return d
			}
			r.expandCategories = s;

			function o(y) {
				e.forEach(y, function(d) {
					u(d) || (r.tokenIdxToClass[r.tokenShortNameIdx] = d, d.tokenTypeIdx = r.tokenShortNameIdx++), h(d) && !e.isArray(d.CATEGORIES) && (d.CATEGORIES = [d.CATEGORIES]), h(d) || (d.CATEGORIES = []), f(d) || (d.categoryMatches = []), m(d) || (d.categoryMatchesMap = {})
				})
			}
			r.assignTokenDefaultProps = o;

			function a(y) {
				e.forEach(y, function(d) {
					d.categoryMatches = [], e.forEach(d.categoryMatchesMap, function(p, _) {
						d.categoryMatches.push(r.tokenIdxToClass[_].tokenTypeIdx)
					})
				})
			}
			r.assignCategoriesTokensProp = a;

			function l(y) {
				e.forEach(y, function(d) {
					c([], d)
				})
			}
			r.assignCategoriesMapProp = l;

			function c(y, d) {
				e.forEach(y, function(p) {
					d.categoryMatchesMap[p.tokenTypeIdx] = !0
				}), e.forEach(d.CATEGORIES, function(p) {
					var _ = y.concat(d);
					e.contains(_, p) || c(_, p)
				})
			}
			r.singleAssignCategoriesToksMap = c;

			function u(y) {
				return e.has(y, "tokenTypeIdx")
			}
			r.hasShortKeyProperty = u;

			function h(y) {
				return e.has(y, "CATEGORIES")
			}
			r.hasCategoriesProperty = h;

			function f(y) {
				return e.has(y, "categoryMatches")
			}
			r.hasExtendingTokensTypesProperty = f;

			function m(y) {
				return e.has(y, "categoryMatchesMap")
			}
			r.hasExtendingTokensTypesMapProperty = m;

			function g(y) {
				return e.has(y, "tokenTypeIdx")
			}
			r.isTokenType = g
		}),
		h0 = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.defaultLexerErrorProvider = void 0, r.defaultLexerErrorProvider = {
				buildUnableToPopLexerModeMessage: function(e) {
					return "Unable to pop Lexer Mode after encountering Token ->" + e.image + "<- The Mode Stack is empty"
				},
				buildUnexpectedCharactersMessage: function(e, t, n, i, s) {
					return "unexpected character: ->" + e.charAt(t) + "<- at offset: " + t + "," + (" skipped " + n + " characters.")
				}
			}
		}),
		th = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.Lexer = r.LexerDefinitionErrorType = void 0;
			var e = u0(),
				t = Ft(),
				n = Xl(),
				i = h0(),
				s = Rd(),
				o;
			(function(c) {
				c[c.MISSING_PATTERN = 0] = "MISSING_PATTERN", c[c.INVALID_PATTERN = 1] = "INVALID_PATTERN", c[c.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", c[c.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", c[c.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", c[c.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", c[c.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", c[c.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", c[c.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", c[c.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", c[c.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", c[c.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", c[c.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", c[c.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", c[c.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", c[c.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", c[c.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK"
			})(o = r.LexerDefinitionErrorType || (r.LexerDefinitionErrorType = {}));
			var a = {
				deferDefinitionErrorsHandling: !1,
				positionTracking: "full",
				lineTerminatorsPattern: /\n|\r\n?/g,
				lineTerminatorCharacters: [`
`, "\r"],
				ensureOptimizations: !1,
				safeMode: !1,
				errorMessageProvider: i.defaultLexerErrorProvider,
				traceInitPerf: !1,
				skipValidations: !1
			};
			Object.freeze(a);
			var l = function() {
				function c(u, h) {
					var f = this;
					if (h === void 0 && (h = a), this.lexerDefinition = u, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.config = void 0, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, typeof h == "boolean") throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
					this.config = t.merge(a, h);
					var m = this.config.traceInitPerf;
					m === !0 ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = !0) : typeof m == "number" && (this.traceInitMaxIdent = m, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", function() {
						var g, y = !0;
						f.TRACE_INIT("Lexer Config handling", function() {
							if (f.config.lineTerminatorsPattern === a.lineTerminatorsPattern) f.config.lineTerminatorsPattern = e.LineTerminatorOptimizedTester;
							else if (f.config.lineTerminatorCharacters === a.lineTerminatorCharacters) throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
							if (h.safeMode && h.ensureOptimizations) throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
							f.trackStartLines = /full|onlyStart/i.test(f.config.positionTracking), f.trackEndLines = /full/i.test(f.config.positionTracking), t.isArray(u) ? (g = {
								modes: {}
							}, g.modes[e.DEFAULT_MODE] = t.cloneArr(u), g[e.DEFAULT_MODE] = e.DEFAULT_MODE) : (y = !1, g = t.cloneObj(u))
						}), f.config.skipValidations === !1 && (f.TRACE_INIT("performRuntimeChecks", function() {
							f.lexerDefinitionErrors = f.lexerDefinitionErrors.concat(e.performRuntimeChecks(g, f.trackStartLines, f.config.lineTerminatorCharacters))
						}), f.TRACE_INIT("performWarningRuntimeChecks", function() {
							f.lexerDefinitionWarning = f.lexerDefinitionWarning.concat(e.performWarningRuntimeChecks(g, f.trackStartLines, f.config.lineTerminatorCharacters))
						})), g.modes = g.modes ? g.modes : {}, t.forEach(g.modes, function(v, x) {
							g.modes[x] = t.reject(v, function(M) {
								return t.isUndefined(M)
							})
						});
						var d = t.keys(g.modes);
						if (t.forEach(g.modes, function(v, x) {
								f.TRACE_INIT("Mode: <" + x + "> processing", function() {
									if (f.modes.push(x), f.config.skipValidations === !1 && f.TRACE_INIT("validatePatterns", function() {
											f.lexerDefinitionErrors = f.lexerDefinitionErrors.concat(e.validatePatterns(v, d))
										}), t.isEmpty(f.lexerDefinitionErrors)) {
										n.augmentTokenTypes(v);
										var M;
										f.TRACE_INIT("analyzeTokenTypes", function() {
											M = e.analyzeTokenTypes(v, {
												lineTerminatorCharacters: f.config.lineTerminatorCharacters,
												positionTracking: h.positionTracking,
												ensureOptimizations: h.ensureOptimizations,
												safeMode: h.safeMode,
												tracer: f.TRACE_INIT.bind(f)
											})
										}), f.patternIdxToConfig[x] = M.patternIdxToConfig, f.charCodeToPatternIdxToConfig[x] = M.charCodeToPatternIdxToConfig, f.emptyGroups = t.merge(f.emptyGroups, M.emptyGroups), f.hasCustom = M.hasCustom || f.hasCustom, f.canModeBeOptimized[x] = M.canBeOptimized
									}
								})
							}), f.defaultMode = g.defaultMode, !t.isEmpty(f.lexerDefinitionErrors) && !f.config.deferDefinitionErrorsHandling) {
							var p = t.map(f.lexerDefinitionErrors, function(v) {
									return v.message
								}),
								_ = p.join(`-----------------------
`);
							throw new Error(`Errors detected in definition of Lexer:
` + _)
						}
						t.forEach(f.lexerDefinitionWarning, function(v) {
							t.PRINT_WARNING(v.message)
						}), f.TRACE_INIT("Choosing sub-methods implementations", function() {
							if (e.SUPPORT_STICKY ? (f.chopInput = t.IDENTITY, f.match = f.matchWithTest) : (f.updateLastIndex = t.NOOP, f.match = f.matchWithExec), y && (f.handleModes = t.NOOP), f.trackStartLines === !1 && (f.computeNewColumn = t.IDENTITY), f.trackEndLines === !1 && (f.updateTokenEndLineColumnLocation = t.NOOP), /full/i.test(f.config.positionTracking)) f.createTokenInstance = f.createFullToken;
							else if (/onlyStart/i.test(f.config.positionTracking)) f.createTokenInstance = f.createStartOnlyToken;
							else if (/onlyOffset/i.test(f.config.positionTracking)) f.createTokenInstance = f.createOffsetOnlyToken;
							else throw Error('Invalid <positionTracking> config option: "' + f.config.positionTracking + '"');
							f.hasCustom ? (f.addToken = f.addTokenUsingPush, f.handlePayload = f.handlePayloadWithCustom) : (f.addToken = f.addTokenUsingMemberAccess, f.handlePayload = f.handlePayloadNoCustom)
						}), f.TRACE_INIT("Failed Optimization Warnings", function() {
							var v = t.reduce(f.canModeBeOptimized, function(x, M, I) {
								return M === !1 && x.push(I), x
							}, []);
							if (h.ensureOptimizations && !t.isEmpty(v)) throw Error("Lexer Modes: < " + v.join(", ") + ` > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)
						}), f.TRACE_INIT("clearRegExpParserCache", function() {
							s.clearRegExpParserCache()
						}), f.TRACE_INIT("toFastProperties", function() {
							t.toFastProperties(f)
						})
					})
				}
				return c.prototype.tokenize = function(u, h) {
					if (h === void 0 && (h = this.defaultMode), !t.isEmpty(this.lexerDefinitionErrors)) {
						var f = t.map(this.lexerDefinitionErrors, function(y) {
								return y.message
							}),
							m = f.join(`-----------------------
`);
						throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + m)
					}
					var g = this.tokenizeInternal(u, h);
					return g
				}, c.prototype.tokenizeInternal = function(u, h) {
					var f = this,
						m, g, y, d, p, _, v, x, M, I, w, L, T, C, V, k = u,
						F = k.length,
						U = 0,
						K = 0,
						Z = this.hasCustom ? 0 : Math.floor(u.length / 10),
						Y = new Array(Z),
						H = [],
						oe = this.trackStartLines ? 1 : void 0,
						de = this.trackStartLines ? 1 : void 0,
						te = e.cloneEmptyGroups(this.emptyGroups),
						fe = this.trackStartLines,
						me = this.config.lineTerminatorsPattern,
						P = 0,
						b = [],
						S = [],
						A = [],
						G = [];
					Object.freeze(G);
					var J = void 0;

					function $() {
						return b
					}

					function le(ue) {
						var se = e.charCodeToOptimizedIndex(ue),
							_e = S[se];
						return _e === void 0 ? G : _e
					}
					var N = function(ue) {
						if (A.length === 1 && ue.tokenType.PUSH_MODE === void 0) {
							var se = f.config.errorMessageProvider.buildUnableToPopLexerModeMessage(ue);
							H.push({
								offset: ue.startOffset,
								line: ue.startLine !== void 0 ? ue.startLine : void 0,
								column: ue.startColumn !== void 0 ? ue.startColumn : void 0,
								length: ue.image.length,
								message: se
							})
						} else {
							A.pop();
							var _e = t.last(A);
							b = f.patternIdxToConfig[_e], S = f.charCodeToPatternIdxToConfig[_e], P = b.length;
							var Se = f.canModeBeOptimized[_e] && f.config.safeMode === !1;
							S && Se ? J = le : J = $
						}
					};

					function pe(ue) {
						A.push(ue), S = this.charCodeToPatternIdxToConfig[ue], b = this.patternIdxToConfig[ue], P = b.length, P = b.length;
						var se = this.canModeBeOptimized[ue] && this.config.safeMode === !1;
						S && se ? J = le : J = $
					}
					pe.call(this, h);
					for (var Q; U < F;) {
						p = null;
						var he = k.charCodeAt(U),
							ye = J(he),
							Ee = ye.length;
						for (m = 0; m < Ee; m++) {
							Q = ye[m];
							var ie = Q.pattern;
							_ = null;
							var q = Q.short;
							if (q !== !1 ? he === q && (p = ie) : Q.isCustom === !0 ? (V = ie.exec(k, U, Y, te), V !== null ? (p = V[0], V.payload !== void 0 && (_ = V.payload)) : p = null) : (this.updateLastIndex(ie, U), p = this.match(ie, u, U)), p !== null) {
								if (d = Q.longerAlt, d !== void 0) {
									var Me = b[d],
										Pe = Me.pattern;
									v = null, Me.isCustom === !0 ? (V = Pe.exec(k, U, Y, te), V !== null ? (y = V[0], V.payload !== void 0 && (v = V.payload)) : y = null) : (this.updateLastIndex(Pe, U), y = this.match(Pe, u, U)), y && y.length > p.length && (p = y, _ = v, Q = Me)
								}
								break
							}
						}
						if (p !== null) {
							if (x = p.length, M = Q.group, M !== void 0 && (I = Q.tokenTypeIdx, w = this.createTokenInstance(p, U, I, Q.tokenType, oe, de, x), this.handlePayload(w, _), M === !1 ? K = this.addToken(Y, K, w) : te[M].push(w)), u = this.chopInput(u, x), U = U + x, de = this.computeNewColumn(de, x), fe === !0 && Q.canLineTerminator === !0) {
								var Ke = 0,
									R = void 0,
									E = void 0;
								me.lastIndex = 0;
								do R = me.test(p), R === !0 && (E = me.lastIndex - 1, Ke++); while (R === !0);
								Ke !== 0 && (oe = oe + Ke, de = x - E, this.updateTokenEndLineColumnLocation(w, M, E, Ke, oe, de, x))
							}
							this.handleModes(Q, N, pe, w)
						} else {
							for (var B = U, ne = oe, X = de, ae = !1; !ae && U < F;)
								for (T = k.charCodeAt(U), u = this.chopInput(u, 1), U++, g = 0; g < P; g++) {
									var ge = b[g],
										ie = ge.pattern,
										q = ge.short;
									if (q !== !1 ? k.charCodeAt(U) === q && (ae = !0) : ge.isCustom === !0 ? ae = ie.exec(k, U, Y, te) !== null : (this.updateLastIndex(ie, U), ae = ie.exec(u) !== null), ae === !0) break
								}
							L = U - B, C = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(k, B, L, ne, X), H.push({
								offset: B,
								line: ne,
								column: X,
								length: L,
								message: C
							})
						}
					}
					return this.hasCustom || (Y.length = K), {
						tokens: Y,
						groups: te,
						errors: H
					}
				}, c.prototype.handleModes = function(u, h, f, m) {
					if (u.pop === !0) {
						var g = u.push;
						h(m), g !== void 0 && f.call(this, g)
					} else u.push !== void 0 && f.call(this, u.push)
				}, c.prototype.chopInput = function(u, h) {
					return u.substring(h)
				}, c.prototype.updateLastIndex = function(u, h) {
					u.lastIndex = h
				}, c.prototype.updateTokenEndLineColumnLocation = function(u, h, f, m, g, y, d) {
					var p, _;
					h !== void 0 && (p = f === d - 1, _ = p ? -1 : 0, m === 1 && p === !0 || (u.endLine = g + _, u.endColumn = y - 1 + -_))
				}, c.prototype.computeNewColumn = function(u, h) {
					return u + h
				}, c.prototype.createTokenInstance = function() {
					for (var u = [], h = 0; h < arguments.length; h++) u[h] = arguments[h];
					return null
				}, c.prototype.createOffsetOnlyToken = function(u, h, f, m) {
					return {
						image: u,
						startOffset: h,
						tokenTypeIdx: f,
						tokenType: m
					}
				}, c.prototype.createStartOnlyToken = function(u, h, f, m, g, y) {
					return {
						image: u,
						startOffset: h,
						startLine: g,
						startColumn: y,
						tokenTypeIdx: f,
						tokenType: m
					}
				}, c.prototype.createFullToken = function(u, h, f, m, g, y, d) {
					return {
						image: u,
						startOffset: h,
						endOffset: h + d - 1,
						startLine: g,
						endLine: g,
						startColumn: y,
						endColumn: y + d - 1,
						tokenTypeIdx: f,
						tokenType: m
					}
				}, c.prototype.addToken = function(u, h, f) {
					return 666
				}, c.prototype.addTokenUsingPush = function(u, h, f) {
					return u.push(f), h
				}, c.prototype.addTokenUsingMemberAccess = function(u, h, f) {
					return u[h] = f, h++, h
				}, c.prototype.handlePayload = function(u, h) {}, c.prototype.handlePayloadNoCustom = function(u, h) {}, c.prototype.handlePayloadWithCustom = function(u, h) {
					h !== null && (u.payload = h)
				}, c.prototype.match = function(u, h, f) {
					return null
				}, c.prototype.matchWithTest = function(u, h, f) {
					var m = u.test(h);
					return m === !0 ? h.substring(f, u.lastIndex) : null
				}, c.prototype.matchWithExec = function(u, h) {
					var f = u.exec(h);
					return f !== null ? f[0] : f
				}, c.prototype.TRACE_INIT = function(u, h) {
					if (this.traceInitPerf === !0) {
						this.traceInitIndent++;
						var f = new Array(this.traceInitIndent + 1).join("	");
						this.traceInitIndent < this.traceInitMaxIdent && console.log(f + "--> <" + u + ">");
						var m = t.timer(h),
							g = m.time,
							y = m.value,
							d = g > 10 ? console.warn : console.log;
						return this.traceInitIndent < this.traceInitMaxIdent && d(f + "<-- <" + u + "> time: " + g + "ms"), this.traceInitIndent--, y
					} else return h()
				}, c.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.", c.NA = /NOT_APPLICABLE/, c
			}();
			r.Lexer = l
		}),
		Qs = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.tokenMatcher = r.createTokenInstance = r.EOF = r.createToken = r.hasTokenLabel = r.tokenName = r.tokenLabel = void 0;
			var e = Ft(),
				t = th(),
				n = Xl();

			function i(x) {
				return o(x) ? x.LABEL : x.name
			}
			r.tokenLabel = i;

			function s(x) {
				return x.name
			}
			r.tokenName = s;

			function o(x) {
				return e.isString(x.LABEL) && x.LABEL !== ""
			}
			r.hasTokenLabel = o;
			var a = "parent",
				l = "categories",
				c = "label",
				u = "group",
				h = "push_mode",
				f = "pop_mode",
				m = "longer_alt",
				g = "line_breaks",
				y = "start_chars_hint";

			function d(x) {
				return p(x)
			}
			r.createToken = d;

			function p(x) {
				var M = x.pattern,
					I = {};
				if (I.name = x.name, e.isUndefined(M) || (I.PATTERN = M), e.has(x, a)) throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
				return e.has(x, l) && (I.CATEGORIES = x[l]), n.augmentTokenTypes([I]), e.has(x, c) && (I.LABEL = x[c]), e.has(x, u) && (I.GROUP = x[u]), e.has(x, f) && (I.POP_MODE = x[f]), e.has(x, h) && (I.PUSH_MODE = x[h]), e.has(x, m) && (I.LONGER_ALT = x[m]), e.has(x, g) && (I.LINE_BREAKS = x[g]), e.has(x, y) && (I.START_CHARS_HINT = x[y]), I
			}
			r.EOF = d({
				name: "EOF",
				pattern: t.Lexer.NA
			}), n.augmentTokenTypes([r.EOF]);

			function _(x, M, I, w, L, T, C, V) {
				return {
					image: M,
					startOffset: I,
					endOffset: w,
					startLine: L,
					endLine: T,
					startColumn: C,
					endColumn: V,
					tokenTypeIdx: x.tokenTypeIdx,
					tokenType: x
				}
			}
			r.createTokenInstance = _;

			function v(x, M) {
				return n.tokenStructuredMatcher(x, M)
			}
			r.tokenMatcher = v
		}),
		pi = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var p = function(_, v) {
					return p = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(x, M) {
						x.__proto__ = M
					} || function(x, M) {
						for (var I in M) Object.prototype.hasOwnProperty.call(M, I) && (x[I] = M[I])
					}, p(_, v)
				};
				return function(_, v) {
					if (typeof v != "function" && v !== null) throw new TypeError("Class extends value " + String(v) + " is not a constructor or null");
					p(_, v);

					function x() {
						this.constructor = _
					}
					_.prototype = v === null ? Object.create(v) : (x.prototype = v.prototype, new x)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.serializeProduction = r.serializeGrammar = r.Terminal = r.Alternation = r.RepetitionWithSeparator = r.Repetition = r.RepetitionMandatoryWithSeparator = r.RepetitionMandatory = r.Option = r.Alternative = r.Rule = r.NonTerminal = r.AbstractProduction = void 0;
			var t = Ft(),
				n = Qs(),
				i = function() {
					function p(_) {
						this._definition = _
					}
					return Object.defineProperty(p.prototype, "definition", {
						get: function() {
							return this._definition
						},
						set: function(_) {
							this._definition = _
						},
						enumerable: !1,
						configurable: !0
					}), p.prototype.accept = function(_) {
						_.visit(this), t.forEach(this.definition, function(v) {
							v.accept(_)
						})
					}, p
				}();
			r.AbstractProduction = i;
			var s = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, []) || this;
					return x.idx = 1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return Object.defineProperty(_.prototype, "definition", {
					get: function() {
						return this.referencedRule !== void 0 ? this.referencedRule.definition : []
					},
					set: function(v) {},
					enumerable: !1,
					configurable: !0
				}), _.prototype.accept = function(v) {
					v.visit(this)
				}, _
			}(i);
			r.NonTerminal = s;
			var o = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.orgText = "", t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return _
			}(i);
			r.Rule = o;
			var a = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.ignoreAmbiguities = !1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return _
			}(i);
			r.Alternative = a;
			var l = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.idx = 1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return _
			}(i);
			r.Option = l;
			var c = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.idx = 1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return _
			}(i);
			r.RepetitionMandatory = c;
			var u = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.idx = 1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return _
			}(i);
			r.RepetitionMandatoryWithSeparator = u;
			var h = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.idx = 1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return _
			}(i);
			r.Repetition = h;
			var f = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.idx = 1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return _
			}(i);
			r.RepetitionWithSeparator = f;
			var m = function(p) {
				e(_, p);

				function _(v) {
					var x = p.call(this, v.definition) || this;
					return x.idx = 1, x.ignoreAmbiguities = !1, x.hasPredicates = !1, t.assign(x, t.pick(v, function(M) {
						return M !== void 0
					})), x
				}
				return Object.defineProperty(_.prototype, "definition", {
					get: function() {
						return this._definition
					},
					set: function(v) {
						this._definition = v
					},
					enumerable: !1,
					configurable: !0
				}), _
			}(i);
			r.Alternation = m;
			var g = function() {
				function p(_) {
					this.idx = 1, t.assign(this, t.pick(_, function(v) {
						return v !== void 0
					}))
				}
				return p.prototype.accept = function(_) {
					_.visit(this)
				}, p
			}();
			r.Terminal = g;

			function y(p) {
				return t.map(p, d)
			}
			r.serializeGrammar = y;

			function d(p) {
				function _(M) {
					return t.map(M, d)
				}
				if (p instanceof s) return {
					type: "NonTerminal",
					name: p.nonTerminalName,
					idx: p.idx
				};
				if (p instanceof a) return {
					type: "Alternative",
					definition: _(p.definition)
				};
				if (p instanceof l) return {
					type: "Option",
					idx: p.idx,
					definition: _(p.definition)
				};
				if (p instanceof c) return {
					type: "RepetitionMandatory",
					idx: p.idx,
					definition: _(p.definition)
				};
				if (p instanceof u) return {
					type: "RepetitionMandatoryWithSeparator",
					idx: p.idx,
					separator: d(new g({
						terminalType: p.separator
					})),
					definition: _(p.definition)
				};
				if (p instanceof f) return {
					type: "RepetitionWithSeparator",
					idx: p.idx,
					separator: d(new g({
						terminalType: p.separator
					})),
					definition: _(p.definition)
				};
				if (p instanceof h) return {
					type: "Repetition",
					idx: p.idx,
					definition: _(p.definition)
				};
				if (p instanceof m) return {
					type: "Alternation",
					idx: p.idx,
					definition: _(p.definition)
				};
				if (p instanceof g) {
					var v = {
							type: "Terminal",
							name: p.terminalType.name,
							label: n.tokenLabel(p.terminalType),
							idx: p.idx
						},
						x = p.terminalType.PATTERN;
					return p.terminalType.PATTERN && (v.pattern = t.isRegExp(x) ? x.source : x), v
				} else {
					if (p instanceof o) return {
						type: "Rule",
						name: p.name,
						orgText: p.orgText,
						definition: _(p.definition)
					};
					throw Error("non exhaustive match")
				}
			}
			r.serializeProduction = d
		}),
		Id = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.RestWalker = void 0;
			var e = Ft(),
				t = pi(),
				n = function() {
					function s() {}
					return s.prototype.walk = function(o, a) {
						var l = this;
						a === void 0 && (a = []), e.forEach(o.definition, function(c, u) {
							var h = e.drop(o.definition, u + 1);
							if (c instanceof t.NonTerminal) l.walkProdRef(c, h, a);
							else if (c instanceof t.Terminal) l.walkTerminal(c, h, a);
							else if (c instanceof t.Alternative) l.walkFlat(c, h, a);
							else if (c instanceof t.Option) l.walkOption(c, h, a);
							else if (c instanceof t.RepetitionMandatory) l.walkAtLeastOne(c, h, a);
							else if (c instanceof t.RepetitionMandatoryWithSeparator) l.walkAtLeastOneSep(c, h, a);
							else if (c instanceof t.RepetitionWithSeparator) l.walkManySep(c, h, a);
							else if (c instanceof t.Repetition) l.walkMany(c, h, a);
							else if (c instanceof t.Alternation) l.walkOr(c, h, a);
							else throw Error("non exhaustive match")
						})
					}, s.prototype.walkTerminal = function(o, a, l) {}, s.prototype.walkProdRef = function(o, a, l) {}, s.prototype.walkFlat = function(o, a, l) {
						var c = a.concat(l);
						this.walk(o, c)
					}, s.prototype.walkOption = function(o, a, l) {
						var c = a.concat(l);
						this.walk(o, c)
					}, s.prototype.walkAtLeastOne = function(o, a, l) {
						var c = [new t.Option({
							definition: o.definition
						})].concat(a, l);
						this.walk(o, c)
					}, s.prototype.walkAtLeastOneSep = function(o, a, l) {
						var c = i(o, a, l);
						this.walk(o, c)
					}, s.prototype.walkMany = function(o, a, l) {
						var c = [new t.Option({
							definition: o.definition
						})].concat(a, l);
						this.walk(o, c)
					}, s.prototype.walkManySep = function(o, a, l) {
						var c = i(o, a, l);
						this.walk(o, c)
					}, s.prototype.walkOr = function(o, a, l) {
						var c = this,
							u = a.concat(l);
						e.forEach(o.definition, function(h) {
							var f = new t.Alternative({
								definition: [h]
							});
							c.walk(f, u)
						})
					}, s
				}();
			r.RestWalker = n;

			function i(s, o, a) {
				var l = [new t.Option({
						definition: [new t.Terminal({
							terminalType: s.separator
						})].concat(s.definition)
					})],
					c = l.concat(o, a);
				return c
			}
		}),
		ql = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.GAstVisitor = void 0;
			var e = pi(),
				t = function() {
					function n() {}
					return n.prototype.visit = function(i) {
						var s = i;
						switch (s.constructor) {
							case e.NonTerminal:
								return this.visitNonTerminal(s);
							case e.Alternative:
								return this.visitAlternative(s);
							case e.Option:
								return this.visitOption(s);
							case e.RepetitionMandatory:
								return this.visitRepetitionMandatory(s);
							case e.RepetitionMandatoryWithSeparator:
								return this.visitRepetitionMandatoryWithSeparator(s);
							case e.RepetitionWithSeparator:
								return this.visitRepetitionWithSeparator(s);
							case e.Repetition:
								return this.visitRepetition(s);
							case e.Alternation:
								return this.visitAlternation(s);
							case e.Terminal:
								return this.visitTerminal(s);
							case e.Rule:
								return this.visitRule(s);
							default:
								throw Error("non exhaustive match")
						}
					}, n.prototype.visitNonTerminal = function(i) {}, n.prototype.visitAlternative = function(i) {}, n.prototype.visitOption = function(i) {}, n.prototype.visitRepetition = function(i) {}, n.prototype.visitRepetitionMandatory = function(i) {}, n.prototype.visitRepetitionMandatoryWithSeparator = function(i) {}, n.prototype.visitRepetitionWithSeparator = function(i) {}, n.prototype.visitAlternation = function(i) {}, n.prototype.visitTerminal = function(i) {}, n.prototype.visitRule = function(i) {}, n
				}();
			r.GAstVisitor = t
		}),
		nh = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var f = function(m, g) {
					return f = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(y, d) {
						y.__proto__ = d
					} || function(y, d) {
						for (var p in d) Object.prototype.hasOwnProperty.call(d, p) && (y[p] = d[p])
					}, f(m, g)
				};
				return function(m, g) {
					if (typeof g != "function" && g !== null) throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
					f(m, g);

					function y() {
						this.constructor = m
					}
					m.prototype = g === null ? Object.create(g) : (y.prototype = g.prototype, new y)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.collectMethods = r.DslMethodsCollectorVisitor = r.getProductionDslName = r.isBranchingProd = r.isOptionalProd = r.isSequenceProd = void 0;
			var t = Ft(),
				n = pi(),
				i = ql();

			function s(f) {
				return f instanceof n.Alternative || f instanceof n.Option || f instanceof n.Repetition || f instanceof n.RepetitionMandatory || f instanceof n.RepetitionMandatoryWithSeparator || f instanceof n.RepetitionWithSeparator || f instanceof n.Terminal || f instanceof n.Rule
			}
			r.isSequenceProd = s;

			function o(f, m) {
				m === void 0 && (m = []);
				var g = f instanceof n.Option || f instanceof n.Repetition || f instanceof n.RepetitionWithSeparator;
				return g ? !0 : f instanceof n.Alternation ? t.some(f.definition, function(y) {
					return o(y, m)
				}) : f instanceof n.NonTerminal && t.contains(m, f) ? !1 : f instanceof n.AbstractProduction ? (f instanceof n.NonTerminal && m.push(f), t.every(f.definition, function(y) {
					return o(y, m)
				})) : !1
			}
			r.isOptionalProd = o;

			function a(f) {
				return f instanceof n.Alternation
			}
			r.isBranchingProd = a;

			function l(f) {
				if (f instanceof n.NonTerminal) return "SUBRULE";
				if (f instanceof n.Option) return "OPTION";
				if (f instanceof n.Alternation) return "OR";
				if (f instanceof n.RepetitionMandatory) return "AT_LEAST_ONE";
				if (f instanceof n.RepetitionMandatoryWithSeparator) return "AT_LEAST_ONE_SEP";
				if (f instanceof n.RepetitionWithSeparator) return "MANY_SEP";
				if (f instanceof n.Repetition) return "MANY";
				if (f instanceof n.Terminal) return "CONSUME";
				throw Error("non exhaustive match")
			}
			r.getProductionDslName = l;
			var c = function(f) {
				e(m, f);

				function m() {
					var g = f !== null && f.apply(this, arguments) || this;
					return g.separator = "-", g.dslMethods = {
						option: [],
						alternation: [],
						repetition: [],
						repetitionWithSeparator: [],
						repetitionMandatory: [],
						repetitionMandatoryWithSeparator: []
					}, g
				}
				return m.prototype.reset = function() {
					this.dslMethods = {
						option: [],
						alternation: [],
						repetition: [],
						repetitionWithSeparator: [],
						repetitionMandatory: [],
						repetitionMandatoryWithSeparator: []
					}
				}, m.prototype.visitTerminal = function(g) {
					var y = g.terminalType.name + this.separator + "Terminal";
					t.has(this.dslMethods, y) || (this.dslMethods[y] = []), this.dslMethods[y].push(g)
				}, m.prototype.visitNonTerminal = function(g) {
					var y = g.nonTerminalName + this.separator + "Terminal";
					t.has(this.dslMethods, y) || (this.dslMethods[y] = []), this.dslMethods[y].push(g)
				}, m.prototype.visitOption = function(g) {
					this.dslMethods.option.push(g)
				}, m.prototype.visitRepetitionWithSeparator = function(g) {
					this.dslMethods.repetitionWithSeparator.push(g)
				}, m.prototype.visitRepetitionMandatory = function(g) {
					this.dslMethods.repetitionMandatory.push(g)
				}, m.prototype.visitRepetitionMandatoryWithSeparator = function(g) {
					this.dslMethods.repetitionMandatoryWithSeparator.push(g)
				}, m.prototype.visitRepetition = function(g) {
					this.dslMethods.repetition.push(g)
				}, m.prototype.visitAlternation = function(g) {
					this.dslMethods.alternation.push(g)
				}, m
			}(i.GAstVisitor);
			r.DslMethodsCollectorVisitor = c;
			var u = new c;

			function h(f) {
				u.reset(), f.accept(u);
				var m = u.dslMethods;
				return u.reset(), m
			}
			r.collectMethods = h
		}),
		f0 = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.firstForTerminal = r.firstForBranching = r.firstForSequence = r.first = void 0;
			var e = Ft(),
				t = pi(),
				n = nh();

			function i(l) {
				if (l instanceof t.NonTerminal) return i(l.referencedRule);
				if (l instanceof t.Terminal) return a(l);
				if (n.isSequenceProd(l)) return s(l);
				if (n.isBranchingProd(l)) return o(l);
				throw Error("non exhaustive match")
			}
			r.first = i;

			function s(l) {
				for (var c = [], u = l.definition, h = 0, f = u.length > h, m, g = !0; f && g;) m = u[h], g = n.isOptionalProd(m), c = c.concat(i(m)), h = h + 1, f = u.length > h;
				return e.uniq(c)
			}
			r.firstForSequence = s;

			function o(l) {
				var c = e.map(l.definition, function(u) {
					return i(u)
				});
				return e.uniq(e.flatten(c))
			}
			r.firstForBranching = o;

			function a(l) {
				return [l.terminalType]
			}
			r.firstForTerminal = a
		}),
		d0 = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.IN = void 0, r.IN = "_~IN~_"
		}),
		_b = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var h = function(f, m) {
					return h = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(g, y) {
						g.__proto__ = y
					} || function(g, y) {
						for (var d in y) Object.prototype.hasOwnProperty.call(y, d) && (g[d] = y[d])
					}, h(f, m)
				};
				return function(f, m) {
					if (typeof m != "function" && m !== null) throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
					h(f, m);

					function g() {
						this.constructor = f
					}
					f.prototype = m === null ? Object.create(m) : (g.prototype = m.prototype, new g)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.buildInProdFollowPrefix = r.buildBetweenProdsFollowPrefix = r.computeAllProdsFollows = r.ResyncFollowsWalker = void 0;
			var t = Id(),
				n = f0(),
				i = Ft(),
				s = d0(),
				o = pi(),
				a = function(h) {
					e(f, h);

					function f(m) {
						var g = h.call(this) || this;
						return g.topProd = m, g.follows = {}, g
					}
					return f.prototype.startWalking = function() {
						return this.walk(this.topProd), this.follows
					}, f.prototype.walkTerminal = function(m, g, y) {}, f.prototype.walkProdRef = function(m, g, y) {
						var d = c(m.referencedRule, m.idx) + this.topProd.name,
							p = g.concat(y),
							_ = new o.Alternative({
								definition: p
							}),
							v = n.first(_);
						this.follows[d] = v
					}, f
				}(t.RestWalker);
			r.ResyncFollowsWalker = a;

			function l(h) {
				var f = {};
				return i.forEach(h, function(m) {
					var g = new a(m).startWalking();
					i.assign(f, g)
				}), f
			}
			r.computeAllProdsFollows = l;

			function c(h, f) {
				return h.name + f + s.IN
			}
			r.buildBetweenProdsFollowPrefix = c;

			function u(h) {
				var f = h.terminalType.name;
				return f + h.idx + s.IN
			}
			r.buildInProdFollowPrefix = u
		}),
		ih = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.defaultGrammarValidatorErrorProvider = r.defaultGrammarResolverErrorProvider = r.defaultParserErrorProvider = void 0;
			var e = Qs(),
				t = Ft(),
				n = Ft(),
				i = pi(),
				s = nh();
			r.defaultParserErrorProvider = {
				buildMismatchTokenMessage: function(o) {
					var a = o.expected,
						l = o.actual,
						c = o.previous,
						u = o.ruleName,
						h = e.hasTokenLabel(a),
						f = h ? "--> " + e.tokenLabel(a) + " <--" : "token of type --> " + a.name + " <--",
						m = "Expecting " + f + " but found --> '" + l.image + "' <--";
					return m
				},
				buildNotAllInputParsedMessage: function(o) {
					var a = o.firstRedundant,
						l = o.ruleName;
					return "Redundant input, expecting EOF but found: " + a.image
				},
				buildNoViableAltMessage: function(o) {
					var a = o.expectedPathsPerAlt,
						l = o.actual,
						c = o.previous,
						u = o.customUserDescription,
						h = o.ruleName,
						f = "Expecting: ",
						m = n.first(l).image,
						g = `
but found: '` + m + "'";
					if (u) return f + u + g;
					var y = n.reduce(a, function(v, x) {
							return v.concat(x)
						}, []),
						d = n.map(y, function(v) {
							return "[" + n.map(v, function(x) {
								return e.tokenLabel(x)
							}).join(", ") + "]"
						}),
						p = n.map(d, function(v, x) {
							return "  " + (x + 1) + ". " + v
						}),
						_ = `one of these possible Token sequences:
` + p.join(`
`);
					return f + _ + g
				},
				buildEarlyExitMessage: function(o) {
					var a = o.expectedIterationPaths,
						l = o.actual,
						c = o.customUserDescription,
						u = o.ruleName,
						h = "Expecting: ",
						f = n.first(l).image,
						m = `
but found: '` + f + "'";
					if (c) return h + c + m;
					var g = n.map(a, function(d) {
							return "[" + n.map(d, function(p) {
								return e.tokenLabel(p)
							}).join(",") + "]"
						}),
						y = `expecting at least one iteration which starts with one of these possible Token sequences::
  ` + ("<" + g.join(" ,") + ">");
					return h + y + m
				}
			}, Object.freeze(r.defaultParserErrorProvider), r.defaultGrammarResolverErrorProvider = {
				buildRuleNotFoundError: function(o, a) {
					var l = "Invalid grammar, reference to a rule which is not defined: ->" + a.nonTerminalName + `<-
inside top level rule: ->` + o.name + "<-";
					return l
				}
			}, r.defaultGrammarValidatorErrorProvider = {
				buildDuplicateFoundError: function(o, a) {
					function l(d) {
						return d instanceof i.Terminal ? d.terminalType.name : d instanceof i.NonTerminal ? d.nonTerminalName : ""
					}
					var c = o.name,
						u = n.first(a),
						h = u.idx,
						f = s.getProductionDslName(u),
						m = l(u),
						g = h > 0,
						y = "->" + f + (g ? h : "") + "<- " + (m ? "with argument: ->" + m + "<-" : "") + `
                  appears more than once (` + a.length + " times) in the top level rule: ->" + c + `<-.
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES
                  `;
					return y = y.replace(/[ \t]+/g, " "), y = y.replace(/\s\s+/g, `
`), y
				},
				buildNamespaceConflictError: function(o) {
					var a = `Namespace conflict found in grammar.
` + ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + o.name + `>.
`) + `To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
					return a
				},
				buildAlternationPrefixAmbiguityError: function(o) {
					var a = n.map(o.prefixPath, function(u) {
							return e.tokenLabel(u)
						}).join(", "),
						l = o.alternation.idx === 0 ? "" : o.alternation.idx,
						c = "Ambiguous alternatives: <" + o.ambiguityIndices.join(" ,") + `> due to common lookahead prefix
` + ("in <OR" + l + "> inside <" + o.topLevelRule.name + `> Rule,
`) + ("<" + a + `> may appears as a prefix path in all these alternatives.
`) + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
					return c
				},
				buildAlternationAmbiguityError: function(o) {
					var a = n.map(o.prefixPath, function(u) {
							return e.tokenLabel(u)
						}).join(", "),
						l = o.alternation.idx === 0 ? "" : o.alternation.idx,
						c = "Ambiguous Alternatives Detected: <" + o.ambiguityIndices.join(" ,") + "> in <OR" + l + ">" + (" inside <" + o.topLevelRule.name + `> Rule,
`) + ("<" + a + `> may appears as a prefix path in all these alternatives.
`);
					return c = c + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, c
				},
				buildEmptyRepetitionError: function(o) {
					var a = s.getProductionDslName(o.repetition);
					o.repetition.idx !== 0 && (a += o.repetition.idx);
					var l = "The repetition <" + a + "> within Rule <" + o.topLevelRule.name + `> can never consume any tokens.
This could lead to an infinite loop.`;
					return l
				},
				buildTokenNameError: function(o) {
					return "deprecated"
				},
				buildEmptyAlternationError: function(o) {
					var a = "Ambiguous empty alternative: <" + (o.emptyChoiceIdx + 1) + ">" + (" in <OR" + o.alternation.idx + "> inside <" + o.topLevelRule.name + `> Rule.
`) + "Only the last alternative may be an empty alternative.";
					return a
				},
				buildTooManyAlternativesError: function(o) {
					var a = `An Alternation cannot have more than 256 alternatives:
` + ("<OR" + o.alternation.idx + "> inside <" + o.topLevelRule.name + `> Rule.
 has ` + (o.alternation.definition.length + 1) + " alternatives.");
					return a
				},
				buildLeftRecursionError: function(o) {
					var a = o.topLevelRule.name,
						l = t.map(o.leftRecursionPath, function(h) {
							return h.name
						}),
						c = a + " --> " + l.concat([a]).join(" --> "),
						u = `Left Recursion found in grammar.
` + ("rule: <" + a + `> can be invoked from itself (directly or indirectly)
`) + (`without consuming any Tokens. The grammar path that causes this is:
 ` + c + `
`) + ` To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.`;
					return u
				},
				buildInvalidRuleNameError: function(o) {
					return "deprecated"
				},
				buildDuplicateRuleNameError: function(o) {
					var a;
					o.topLevelRule instanceof i.Rule ? a = o.topLevelRule.name : a = o.topLevelRule;
					var l = "Duplicate definition, rule: ->" + a + "<- is already defined in the grammar: ->" + o.grammarName + "<-";
					return l
				}
			}
		}),
		Tb = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var a = function(l, c) {
					return a = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(u, h) {
						u.__proto__ = h
					} || function(u, h) {
						for (var f in h) Object.prototype.hasOwnProperty.call(h, f) && (u[f] = h[f])
					}, a(l, c)
				};
				return function(l, c) {
					if (typeof c != "function" && c !== null) throw new TypeError("Class extends value " + String(c) + " is not a constructor or null");
					a(l, c);

					function u() {
						this.constructor = l
					}
					l.prototype = c === null ? Object.create(c) : (u.prototype = c.prototype, new u)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.GastRefResolverVisitor = r.resolveGrammar = void 0;
			var t = Ai(),
				n = Ft(),
				i = ql();

			function s(a, l) {
				var c = new o(a, l);
				return c.resolveRefs(), c.errors
			}
			r.resolveGrammar = s;
			var o = function(a) {
				e(l, a);

				function l(c, u) {
					var h = a.call(this) || this;
					return h.nameToTopRule = c, h.errMsgProvider = u, h.errors = [], h
				}
				return l.prototype.resolveRefs = function() {
					var c = this;
					n.forEach(n.values(this.nameToTopRule), function(u) {
						c.currTopLevel = u, u.accept(c)
					})
				}, l.prototype.visitNonTerminal = function(c) {
					var u = this.nameToTopRule[c.nonTerminalName];
					if (u) c.referencedRule = u;
					else {
						var h = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, c);
						this.errors.push({
							message: h,
							type: t.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
							ruleName: this.currTopLevel.name,
							unresolvedRefName: c.nonTerminalName
						})
					}
				}, l
			}(i.GAstVisitor);
			r.GastRefResolverVisitor = o
		}),
		rh = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var d = function(p, _) {
					return d = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(v, x) {
						v.__proto__ = x
					} || function(v, x) {
						for (var M in x) Object.prototype.hasOwnProperty.call(x, M) && (v[M] = x[M])
					}, d(p, _)
				};
				return function(p, _) {
					if (typeof _ != "function" && _ !== null) throw new TypeError("Class extends value " + String(_) + " is not a constructor or null");
					d(p, _);

					function v() {
						this.constructor = p
					}
					p.prototype = _ === null ? Object.create(_) : (v.prototype = _.prototype, new v)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.nextPossibleTokensAfter = r.possiblePathsFrom = r.NextTerminalAfterAtLeastOneSepWalker = r.NextTerminalAfterAtLeastOneWalker = r.NextTerminalAfterManySepWalker = r.NextTerminalAfterManyWalker = r.AbstractNextTerminalAfterProductionWalker = r.NextAfterTokenWalker = r.AbstractNextPossibleTokensWalker = void 0;
			var t = Id(),
				n = Ft(),
				i = f0(),
				s = pi(),
				o = function(d) {
					e(p, d);

					function p(_, v) {
						var x = d.call(this) || this;
						return x.topProd = _, x.path = v, x.possibleTokTypes = [], x.nextProductionName = "", x.nextProductionOccurrence = 0, x.found = !1, x.isAtEndOfPath = !1, x
					}
					return p.prototype.startWalking = function() {
						if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name) throw Error("The path does not start with the walker's top Rule!");
						return this.ruleStack = n.cloneArr(this.path.ruleStack).reverse(), this.occurrenceStack = n.cloneArr(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes
					}, p.prototype.walk = function(_, v) {
						v === void 0 && (v = []), this.found || d.prototype.walk.call(this, _, v)
					}, p.prototype.walkProdRef = function(_, v, x) {
						if (_.referencedRule.name === this.nextProductionName && _.idx === this.nextProductionOccurrence) {
							var M = v.concat(x);
							this.updateExpectedNext(), this.walk(_.referencedRule, M)
						}
					}, p.prototype.updateExpectedNext = function() {
						n.isEmpty(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop())
					}, p
				}(t.RestWalker);
			r.AbstractNextPossibleTokensWalker = o;
			var a = function(d) {
				e(p, d);

				function p(_, v) {
					var x = d.call(this, _, v) || this;
					return x.path = v, x.nextTerminalName = "", x.nextTerminalOccurrence = 0, x.nextTerminalName = x.path.lastTok.name, x.nextTerminalOccurrence = x.path.lastTokOccurrence, x
				}
				return p.prototype.walkTerminal = function(_, v, x) {
					if (this.isAtEndOfPath && _.terminalType.name === this.nextTerminalName && _.idx === this.nextTerminalOccurrence && !this.found) {
						var M = v.concat(x),
							I = new s.Alternative({
								definition: M
							});
						this.possibleTokTypes = i.first(I), this.found = !0
					}
				}, p
			}(o);
			r.NextAfterTokenWalker = a;
			var l = function(d) {
				e(p, d);

				function p(_, v) {
					var x = d.call(this) || this;
					return x.topRule = _, x.occurrence = v, x.result = {
						token: void 0,
						occurrence: void 0,
						isEndOfRule: void 0
					}, x
				}
				return p.prototype.startWalking = function() {
					return this.walk(this.topRule), this.result
				}, p
			}(t.RestWalker);
			r.AbstractNextTerminalAfterProductionWalker = l;
			var c = function(d) {
				e(p, d);

				function p() {
					return d !== null && d.apply(this, arguments) || this
				}
				return p.prototype.walkMany = function(_, v, x) {
					if (_.idx === this.occurrence) {
						var M = n.first(v.concat(x));
						this.result.isEndOfRule = M === void 0, M instanceof s.Terminal && (this.result.token = M.terminalType, this.result.occurrence = M.idx)
					} else d.prototype.walkMany.call(this, _, v, x)
				}, p
			}(l);
			r.NextTerminalAfterManyWalker = c;
			var u = function(d) {
				e(p, d);

				function p() {
					return d !== null && d.apply(this, arguments) || this
				}
				return p.prototype.walkManySep = function(_, v, x) {
					if (_.idx === this.occurrence) {
						var M = n.first(v.concat(x));
						this.result.isEndOfRule = M === void 0, M instanceof s.Terminal && (this.result.token = M.terminalType, this.result.occurrence = M.idx)
					} else d.prototype.walkManySep.call(this, _, v, x)
				}, p
			}(l);
			r.NextTerminalAfterManySepWalker = u;
			var h = function(d) {
				e(p, d);

				function p() {
					return d !== null && d.apply(this, arguments) || this
				}
				return p.prototype.walkAtLeastOne = function(_, v, x) {
					if (_.idx === this.occurrence) {
						var M = n.first(v.concat(x));
						this.result.isEndOfRule = M === void 0, M instanceof s.Terminal && (this.result.token = M.terminalType, this.result.occurrence = M.idx)
					} else d.prototype.walkAtLeastOne.call(this, _, v, x)
				}, p
			}(l);
			r.NextTerminalAfterAtLeastOneWalker = h;
			var f = function(d) {
				e(p, d);

				function p() {
					return d !== null && d.apply(this, arguments) || this
				}
				return p.prototype.walkAtLeastOneSep = function(_, v, x) {
					if (_.idx === this.occurrence) {
						var M = n.first(v.concat(x));
						this.result.isEndOfRule = M === void 0, M instanceof s.Terminal && (this.result.token = M.terminalType, this.result.occurrence = M.idx)
					} else d.prototype.walkAtLeastOneSep.call(this, _, v, x)
				}, p
			}(l);
			r.NextTerminalAfterAtLeastOneSepWalker = f;

			function m(d, p, _) {
				_ === void 0 && (_ = []), _ = n.cloneArr(_);
				var v = [],
					x = 0;

				function M(T) {
					return T.concat(n.drop(d, x + 1))
				}

				function I(T) {
					var C = m(M(T), p, _);
					return v.concat(C)
				}
				for (; _.length < p && x < d.length;) {
					var w = d[x];
					if (w instanceof s.Alternative || w instanceof s.NonTerminal) return I(w.definition);
					if (w instanceof s.Option) v = I(w.definition);
					else if (w instanceof s.RepetitionMandatory) {
						var L = w.definition.concat([new s.Repetition({
							definition: w.definition
						})]);
						return I(L)
					} else if (w instanceof s.RepetitionMandatoryWithSeparator) {
						var L = [new s.Alternative({
							definition: w.definition
						}), new s.Repetition({
							definition: [new s.Terminal({
								terminalType: w.separator
							})].concat(w.definition)
						})];
						return I(L)
					} else if (w instanceof s.RepetitionWithSeparator) {
						var L = w.definition.concat([new s.Repetition({
							definition: [new s.Terminal({
								terminalType: w.separator
							})].concat(w.definition)
						})]);
						v = I(L)
					} else if (w instanceof s.Repetition) {
						var L = w.definition.concat([new s.Repetition({
							definition: w.definition
						})]);
						v = I(L)
					} else {
						if (w instanceof s.Alternation) return n.forEach(w.definition, function(T) {
							n.isEmpty(T.definition) === !1 && (v = I(T.definition))
						}), v;
						if (w instanceof s.Terminal) _.push(w.terminalType);
						else throw Error("non exhaustive match")
					}
					x++
				}
				return v.push({
					partialPath: _,
					suffixDef: n.drop(d, x)
				}), v
			}
			r.possiblePathsFrom = m;

			function g(d, p, _, v) {
				var x = "EXIT_NONE_TERMINAL",
					M = [x],
					I = "EXIT_ALTERNATIVE",
					w = !1,
					L = p.length,
					T = L - v - 1,
					C = [],
					V = [];
				for (V.push({
						idx: -1,
						def: d,
						ruleStack: [],
						occurrenceStack: []
					}); !n.isEmpty(V);) {
					var k = V.pop();
					if (k === I) {
						w && n.last(V).idx <= T && V.pop();
						continue
					}
					var F = k.def,
						U = k.idx,
						K = k.ruleStack,
						Z = k.occurrenceStack;
					if (!n.isEmpty(F)) {
						var Y = F[0];
						if (Y === x) {
							var H = {
								idx: U,
								def: n.drop(F),
								ruleStack: n.dropRight(K),
								occurrenceStack: n.dropRight(Z)
							};
							V.push(H)
						} else if (Y instanceof s.Terminal)
							if (U < L - 1) {
								var oe = U + 1,
									de = p[oe];
								if (_(de, Y.terminalType)) {
									var H = {
										idx: oe,
										def: n.drop(F),
										ruleStack: K,
										occurrenceStack: Z
									};
									V.push(H)
								}
							} else if (U === L - 1) C.push({
							nextTokenType: Y.terminalType,
							nextTokenOccurrence: Y.idx,
							ruleStack: K,
							occurrenceStack: Z
						}), w = !0;
						else throw Error("non exhaustive match");
						else if (Y instanceof s.NonTerminal) {
							var te = n.cloneArr(K);
							te.push(Y.nonTerminalName);
							var fe = n.cloneArr(Z);
							fe.push(Y.idx);
							var H = {
								idx: U,
								def: Y.definition.concat(M, n.drop(F)),
								ruleStack: te,
								occurrenceStack: fe
							};
							V.push(H)
						} else if (Y instanceof s.Option) {
							var me = {
								idx: U,
								def: n.drop(F),
								ruleStack: K,
								occurrenceStack: Z
							};
							V.push(me), V.push(I);
							var P = {
								idx: U,
								def: Y.definition.concat(n.drop(F)),
								ruleStack: K,
								occurrenceStack: Z
							};
							V.push(P)
						} else if (Y instanceof s.RepetitionMandatory) {
							var b = new s.Repetition({
									definition: Y.definition,
									idx: Y.idx
								}),
								S = Y.definition.concat([b], n.drop(F)),
								H = {
									idx: U,
									def: S,
									ruleStack: K,
									occurrenceStack: Z
								};
							V.push(H)
						} else if (Y instanceof s.RepetitionMandatoryWithSeparator) {
							var A = new s.Terminal({
									terminalType: Y.separator
								}),
								b = new s.Repetition({
									definition: [A].concat(Y.definition),
									idx: Y.idx
								}),
								S = Y.definition.concat([b], n.drop(F)),
								H = {
									idx: U,
									def: S,
									ruleStack: K,
									occurrenceStack: Z
								};
							V.push(H)
						} else if (Y instanceof s.RepetitionWithSeparator) {
							var me = {
								idx: U,
								def: n.drop(F),
								ruleStack: K,
								occurrenceStack: Z
							};
							V.push(me), V.push(I);
							var A = new s.Terminal({
									terminalType: Y.separator
								}),
								G = new s.Repetition({
									definition: [A].concat(Y.definition),
									idx: Y.idx
								}),
								S = Y.definition.concat([G], n.drop(F)),
								P = {
									idx: U,
									def: S,
									ruleStack: K,
									occurrenceStack: Z
								};
							V.push(P)
						} else if (Y instanceof s.Repetition) {
							var me = {
								idx: U,
								def: n.drop(F),
								ruleStack: K,
								occurrenceStack: Z
							};
							V.push(me), V.push(I);
							var G = new s.Repetition({
									definition: Y.definition,
									idx: Y.idx
								}),
								S = Y.definition.concat([G], n.drop(F)),
								P = {
									idx: U,
									def: S,
									ruleStack: K,
									occurrenceStack: Z
								};
							V.push(P)
						} else if (Y instanceof s.Alternation)
							for (var J = Y.definition.length - 1; J >= 0; J--) {
								var $ = Y.definition[J],
									le = {
										idx: U,
										def: $.definition.concat(n.drop(F)),
										ruleStack: K,
										occurrenceStack: Z
									};
								V.push(le), V.push(I)
							} else if (Y instanceof s.Alternative) V.push({
								idx: U,
								def: Y.definition.concat(n.drop(F)),
								ruleStack: K,
								occurrenceStack: Z
							});
							else if (Y instanceof s.Rule) V.push(y(Y, U, K, Z));
						else throw Error("non exhaustive match")
					}
				}
				return C
			}
			r.nextPossibleTokensAfter = g;

			function y(d, p, _, v) {
				var x = n.cloneArr(_);
				x.push(d.name);
				var M = n.cloneArr(v);
				return M.push(1), {
					idx: p,
					def: d.definition,
					ruleStack: x,
					occurrenceStack: M
				}
			}
		}),
		sh = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var T = function(C, V) {
					return T = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(k, F) {
						k.__proto__ = F
					} || function(k, F) {
						for (var U in F) Object.prototype.hasOwnProperty.call(F, U) && (k[U] = F[U])
					}, T(C, V)
				};
				return function(C, V) {
					if (typeof V != "function" && V !== null) throw new TypeError("Class extends value " + String(V) + " is not a constructor or null");
					T(C, V);

					function k() {
						this.constructor = C
					}
					C.prototype = V === null ? Object.create(V) : (k.prototype = V.prototype, new k)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.areTokenCategoriesNotUsed = r.isStrictPrefixOfPath = r.containsPath = r.getLookaheadPathsForOptionalProd = r.getLookaheadPathsForOr = r.lookAheadSequenceFromAlternatives = r.buildSingleAlternativeLookaheadFunction = r.buildAlternativesLookAheadFunc = r.buildLookaheadFuncForOptionalProd = r.buildLookaheadFuncForOr = r.getProdType = r.PROD_TYPE = void 0;
			var t = Ft(),
				n = rh(),
				i = Id(),
				s = Xl(),
				o = pi(),
				a = ql(),
				l;
			(function(T) {
				T[T.OPTION = 0] = "OPTION", T[T.REPETITION = 1] = "REPETITION", T[T.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", T[T.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", T[T.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", T[T.ALTERNATION = 5] = "ALTERNATION"
			})(l = r.PROD_TYPE || (r.PROD_TYPE = {}));

			function c(T) {
				if (T instanceof o.Option) return l.OPTION;
				if (T instanceof o.Repetition) return l.REPETITION;
				if (T instanceof o.RepetitionMandatory) return l.REPETITION_MANDATORY;
				if (T instanceof o.RepetitionMandatoryWithSeparator) return l.REPETITION_MANDATORY_WITH_SEPARATOR;
				if (T instanceof o.RepetitionWithSeparator) return l.REPETITION_WITH_SEPARATOR;
				if (T instanceof o.Alternation) return l.ALTERNATION;
				throw Error("non exhaustive match")
			}
			r.getProdType = c;

			function u(T, C, V, k, F, U) {
				var K = x(T, C, V),
					Z = L(K) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher;
				return U(K, k, Z, F)
			}
			r.buildLookaheadFuncForOr = u;

			function h(T, C, V, k, F, U) {
				var K = M(T, C, F, V),
					Z = L(K) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher;
				return U(K[0], Z, k)
			}
			r.buildLookaheadFuncForOptionalProd = h;

			function f(T, C, V, k) {
				var F = T.length,
					U = t.every(T, function(Y) {
						return t.every(Y, function(H) {
							return H.length === 1
						})
					});
				if (C) return function(Y) {
					for (var H = t.map(Y, function(G) {
							return G.GATE
						}), oe = 0; oe < F; oe++) {
						var de = T[oe],
							te = de.length,
							fe = H[oe];
						if (!(fe !== void 0 && fe.call(this) === !1)) e: for (var me = 0; me < te; me++) {
							for (var P = de[me], b = P.length, S = 0; S < b; S++) {
								var A = this.LA(S + 1);
								if (V(A, P[S]) === !1) continue e
							}
							return oe
						}
					}
				};
				if (U && !k) {
					var K = t.map(T, function(Y) {
							return t.flatten(Y)
						}),
						Z = t.reduce(K, function(Y, H, oe) {
							return t.forEach(H, function(de) {
								t.has(Y, de.tokenTypeIdx) || (Y[de.tokenTypeIdx] = oe), t.forEach(de.categoryMatches, function(te) {
									t.has(Y, te) || (Y[te] = oe)
								})
							}), Y
						}, []);
					return function() {
						var Y = this.LA(1);
						return Z[Y.tokenTypeIdx]
					}
				} else return function() {
					for (var Y = 0; Y < F; Y++) {
						var H = T[Y],
							oe = H.length;
						e: for (var de = 0; de < oe; de++) {
							for (var te = H[de], fe = te.length, me = 0; me < fe; me++) {
								var P = this.LA(me + 1);
								if (V(P, te[me]) === !1) continue e
							}
							return Y
						}
					}
				}
			}
			r.buildAlternativesLookAheadFunc = f;

			function m(T, C, V) {
				var k = t.every(T, function(H) {
						return H.length === 1
					}),
					F = T.length;
				if (k && !V) {
					var U = t.flatten(T);
					if (U.length === 1 && t.isEmpty(U[0].categoryMatches)) {
						var K = U[0],
							Z = K.tokenTypeIdx;
						return function() {
							return this.LA(1).tokenTypeIdx === Z
						}
					} else {
						var Y = t.reduce(U, function(H, oe, de) {
							return H[oe.tokenTypeIdx] = !0, t.forEach(oe.categoryMatches, function(te) {
								H[te] = !0
							}), H
						}, []);
						return function() {
							var H = this.LA(1);
							return Y[H.tokenTypeIdx] === !0
						}
					}
				} else return function() {
					e: for (var H = 0; H < F; H++) {
						for (var oe = T[H], de = oe.length, te = 0; te < de; te++) {
							var fe = this.LA(te + 1);
							if (C(fe, oe[te]) === !1) continue e
						}
						return !0
					}
					return !1
				}
			}
			r.buildSingleAlternativeLookaheadFunction = m;
			var g = function(T) {
					e(C, T);

					function C(V, k, F) {
						var U = T.call(this) || this;
						return U.topProd = V, U.targetOccurrence = k, U.targetProdType = F, U
					}
					return C.prototype.startWalking = function() {
						return this.walk(this.topProd), this.restDef
					}, C.prototype.checkIsTarget = function(V, k, F, U) {
						return V.idx === this.targetOccurrence && this.targetProdType === k ? (this.restDef = F.concat(U), !0) : !1
					}, C.prototype.walkOption = function(V, k, F) {
						this.checkIsTarget(V, l.OPTION, k, F) || T.prototype.walkOption.call(this, V, k, F)
					}, C.prototype.walkAtLeastOne = function(V, k, F) {
						this.checkIsTarget(V, l.REPETITION_MANDATORY, k, F) || T.prototype.walkOption.call(this, V, k, F)
					}, C.prototype.walkAtLeastOneSep = function(V, k, F) {
						this.checkIsTarget(V, l.REPETITION_MANDATORY_WITH_SEPARATOR, k, F) || T.prototype.walkOption.call(this, V, k, F)
					}, C.prototype.walkMany = function(V, k, F) {
						this.checkIsTarget(V, l.REPETITION, k, F) || T.prototype.walkOption.call(this, V, k, F)
					}, C.prototype.walkManySep = function(V, k, F) {
						this.checkIsTarget(V, l.REPETITION_WITH_SEPARATOR, k, F) || T.prototype.walkOption.call(this, V, k, F)
					}, C
				}(i.RestWalker),
				y = function(T) {
					e(C, T);

					function C(V, k, F) {
						var U = T.call(this) || this;
						return U.targetOccurrence = V, U.targetProdType = k, U.targetRef = F, U.result = [], U
					}
					return C.prototype.checkIsTarget = function(V, k) {
						V.idx === this.targetOccurrence && this.targetProdType === k && (this.targetRef === void 0 || V === this.targetRef) && (this.result = V.definition)
					}, C.prototype.visitOption = function(V) {
						this.checkIsTarget(V, l.OPTION)
					}, C.prototype.visitRepetition = function(V) {
						this.checkIsTarget(V, l.REPETITION)
					}, C.prototype.visitRepetitionMandatory = function(V) {
						this.checkIsTarget(V, l.REPETITION_MANDATORY)
					}, C.prototype.visitRepetitionMandatoryWithSeparator = function(V) {
						this.checkIsTarget(V, l.REPETITION_MANDATORY_WITH_SEPARATOR)
					}, C.prototype.visitRepetitionWithSeparator = function(V) {
						this.checkIsTarget(V, l.REPETITION_WITH_SEPARATOR)
					}, C.prototype.visitAlternation = function(V) {
						this.checkIsTarget(V, l.ALTERNATION)
					}, C
				}(a.GAstVisitor);

			function d(T) {
				for (var C = new Array(T), V = 0; V < T; V++) C[V] = [];
				return C
			}

			function p(T) {
				for (var C = [""], V = 0; V < T.length; V++) {
					for (var k = T[V], F = [], U = 0; U < C.length; U++) {
						var K = C[U];
						F.push(K + "_" + k.tokenTypeIdx);
						for (var Z = 0; Z < k.categoryMatches.length; Z++) {
							var Y = "_" + k.categoryMatches[Z];
							F.push(K + Y)
						}
					}
					C = F
				}
				return C
			}

			function _(T, C, V) {
				for (var k = 0; k < T.length; k++)
					if (k !== V)
						for (var F = T[k], U = 0; U < C.length; U++) {
							var K = C[U];
							if (F[K] === !0) return !1
						}
				return !0
			}

			function v(T, C) {
				for (var V = t.map(T, function(oe) {
						return n.possiblePathsFrom([oe], 1)
					}), k = d(V.length), F = t.map(V, function(oe) {
						var de = {};
						return t.forEach(oe, function(te) {
							var fe = p(te.partialPath);
							t.forEach(fe, function(me) {
								de[me] = !0
							})
						}), de
					}), U = V, K = 1; K <= C; K++) {
					var Z = U;
					U = d(Z.length);
					for (var Y = function(oe) {
							for (var de = Z[oe], te = 0; te < de.length; te++) {
								var fe = de[te].partialPath,
									me = de[te].suffixDef,
									P = p(fe),
									b = _(F, P, oe);
								if (b || t.isEmpty(me) || fe.length === C) {
									var S = k[oe];
									if (I(S, fe) === !1) {
										S.push(fe);
										for (var A = 0; A < P.length; A++) {
											var G = P[A];
											F[oe][G] = !0
										}
									}
								} else {
									var J = n.possiblePathsFrom(me, K + 1, fe);
									U[oe] = U[oe].concat(J), t.forEach(J, function($) {
										var le = p($.partialPath);
										t.forEach(le, function(N) {
											F[oe][N] = !0
										})
									})
								}
							}
						}, H = 0; H < Z.length; H++) Y(H)
				}
				return k
			}
			r.lookAheadSequenceFromAlternatives = v;

			function x(T, C, V, k) {
				var F = new y(T, l.ALTERNATION, k);
				return C.accept(F), v(F.result, V)
			}
			r.getLookaheadPathsForOr = x;

			function M(T, C, V, k) {
				var F = new y(T, V);
				C.accept(F);
				var U = F.result,
					K = new g(C, T, V),
					Z = K.startWalking(),
					Y = new o.Alternative({
						definition: U
					}),
					H = new o.Alternative({
						definition: Z
					});
				return v([Y, H], k)
			}
			r.getLookaheadPathsForOptionalProd = M;

			function I(T, C) {
				e: for (var V = 0; V < T.length; V++) {
					var k = T[V];
					if (k.length === C.length) {
						for (var F = 0; F < k.length; F++) {
							var U = C[F],
								K = k[F],
								Z = U === K || K.categoryMatchesMap[U.tokenTypeIdx] !== void 0;
							if (Z === !1) continue e
						}
						return !0
					}
				}
				return !1
			}
			r.containsPath = I;

			function w(T, C) {
				return T.length < C.length && t.every(T, function(V, k) {
					var F = C[k];
					return V === F || F.categoryMatchesMap[V.tokenTypeIdx]
				})
			}
			r.isStrictPrefixOfPath = w;

			function L(T) {
				return t.every(T, function(C) {
					return t.every(C, function(V) {
						return t.every(V, function(k) {
							return t.isEmpty(k.categoryMatches)
						})
					})
				})
			}
			r.areTokenCategoriesNotUsed = L
		}),
		p0 = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var k = function(F, U) {
					return k = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(K, Z) {
						K.__proto__ = Z
					} || function(K, Z) {
						for (var Y in Z) Object.prototype.hasOwnProperty.call(Z, Y) && (K[Y] = Z[Y])
					}, k(F, U)
				};
				return function(F, U) {
					if (typeof U != "function" && U !== null) throw new TypeError("Class extends value " + String(U) + " is not a constructor or null");
					k(F, U);

					function K() {
						this.constructor = F
					}
					F.prototype = U === null ? Object.create(U) : (K.prototype = U.prototype, new K)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.checkPrefixAlternativesAmbiguities = r.validateSomeNonEmptyLookaheadPath = r.validateTooManyAlts = r.RepetionCollector = r.validateAmbiguousAlternationAlternatives = r.validateEmptyOrAlternative = r.getFirstNoneTerminal = r.validateNoLeftRecursion = r.validateRuleIsOverridden = r.validateRuleDoesNotAlreadyExist = r.OccurrenceValidationCollector = r.identifyProductionForDuplicates = r.validateGrammar = void 0;
			var t = Ft(),
				n = Ft(),
				i = Ai(),
				s = nh(),
				o = sh(),
				a = rh(),
				l = pi(),
				c = ql();

			function u(k, F, U, K, Z) {
				var Y = t.map(k, function(b) {
						return h(b, K)
					}),
					H = t.map(k, function(b) {
						return p(b, b, K)
					}),
					oe = [],
					de = [],
					te = [];
				n.every(H, n.isEmpty) && (oe = n.map(k, function(b) {
					return x(b, K)
				}), de = n.map(k, function(b) {
					return M(b, F, K)
				}), te = L(k, F, K));
				var fe = V(k, U, K),
					me = n.map(k, function(b) {
						return w(b, K)
					}),
					P = n.map(k, function(b) {
						return y(b, k, Z, K)
					});
				return t.flatten(Y.concat(te, H, oe, de, fe, me, P))
			}
			r.validateGrammar = u;

			function h(k, F) {
				var U = new g;
				k.accept(U);
				var K = U.allProductions,
					Z = t.groupBy(K, f),
					Y = t.pick(Z, function(oe) {
						return oe.length > 1
					}),
					H = t.map(t.values(Y), function(oe) {
						var de = t.first(oe),
							te = F.buildDuplicateFoundError(k, oe),
							fe = s.getProductionDslName(de),
							me = {
								message: te,
								type: i.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
								ruleName: k.name,
								dslName: fe,
								occurrence: de.idx
							},
							P = m(de);
						return P && (me.parameter = P), me
					});
				return H
			}

			function f(k) {
				return s.getProductionDslName(k) + "_#_" + k.idx + "_#_" + m(k)
			}
			r.identifyProductionForDuplicates = f;

			function m(k) {
				return k instanceof l.Terminal ? k.terminalType.name : k instanceof l.NonTerminal ? k.nonTerminalName : ""
			}
			var g = function(k) {
				e(F, k);

				function F() {
					var U = k !== null && k.apply(this, arguments) || this;
					return U.allProductions = [], U
				}
				return F.prototype.visitNonTerminal = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitOption = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitRepetitionWithSeparator = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitRepetitionMandatory = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitRepetitionMandatoryWithSeparator = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitRepetition = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitAlternation = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitTerminal = function(U) {
					this.allProductions.push(U)
				}, F
			}(c.GAstVisitor);
			r.OccurrenceValidationCollector = g;

			function y(k, F, U, K) {
				var Z = [],
					Y = n.reduce(F, function(oe, de) {
						return de.name === k.name ? oe + 1 : oe
					}, 0);
				if (Y > 1) {
					var H = K.buildDuplicateRuleNameError({
						topLevelRule: k,
						grammarName: U
					});
					Z.push({
						message: H,
						type: i.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
						ruleName: k.name
					})
				}
				return Z
			}
			r.validateRuleDoesNotAlreadyExist = y;

			function d(k, F, U) {
				var K = [],
					Z;
				return t.contains(F, k) || (Z = "Invalid rule override, rule: ->" + k + "<- cannot be overridden in the grammar: ->" + U + "<-as it is not defined in any of the super grammars ", K.push({
					message: Z,
					type: i.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
					ruleName: k
				})), K
			}
			r.validateRuleIsOverridden = d;

			function p(k, F, U, K) {
				K === void 0 && (K = []);
				var Z = [],
					Y = _(F.definition);
				if (t.isEmpty(Y)) return [];
				var H = k.name,
					oe = t.contains(Y, k);
				oe && Z.push({
					message: U.buildLeftRecursionError({
						topLevelRule: k,
						leftRecursionPath: K
					}),
					type: i.ParserDefinitionErrorType.LEFT_RECURSION,
					ruleName: H
				});
				var de = t.difference(Y, K.concat([k])),
					te = t.map(de, function(fe) {
						var me = t.cloneArr(K);
						return me.push(fe), p(k, fe, U, me)
					});
				return Z.concat(t.flatten(te))
			}
			r.validateNoLeftRecursion = p;

			function _(k) {
				var F = [];
				if (t.isEmpty(k)) return F;
				var U = t.first(k);
				if (U instanceof l.NonTerminal) F.push(U.referencedRule);
				else if (U instanceof l.Alternative || U instanceof l.Option || U instanceof l.RepetitionMandatory || U instanceof l.RepetitionMandatoryWithSeparator || U instanceof l.RepetitionWithSeparator || U instanceof l.Repetition) F = F.concat(_(U.definition));
				else if (U instanceof l.Alternation) F = t.flatten(t.map(U.definition, function(H) {
					return _(H.definition)
				}));
				else if (!(U instanceof l.Terminal)) throw Error("non exhaustive match");
				var K = s.isOptionalProd(U),
					Z = k.length > 1;
				if (K && Z) {
					var Y = t.drop(k);
					return F.concat(_(Y))
				} else return F
			}
			r.getFirstNoneTerminal = _;
			var v = function(k) {
				e(F, k);

				function F() {
					var U = k !== null && k.apply(this, arguments) || this;
					return U.alternations = [], U
				}
				return F.prototype.visitAlternation = function(U) {
					this.alternations.push(U)
				}, F
			}(c.GAstVisitor);

			function x(k, F) {
				var U = new v;
				k.accept(U);
				var K = U.alternations,
					Z = t.reduce(K, function(Y, H) {
						var oe = t.dropRight(H.definition),
							de = t.map(oe, function(te, fe) {
								var me = a.nextPossibleTokensAfter([te], [], null, 1);
								return t.isEmpty(me) ? {
									message: F.buildEmptyAlternationError({
										topLevelRule: k,
										alternation: H,
										emptyChoiceIdx: fe
									}),
									type: i.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
									ruleName: k.name,
									occurrence: H.idx,
									alternative: fe + 1
								} : null
							});
						return Y.concat(t.compact(de))
					}, []);
				return Z
			}
			r.validateEmptyOrAlternative = x;

			function M(k, F, U) {
				var K = new v;
				k.accept(K);
				var Z = K.alternations;
				Z = n.reject(Z, function(H) {
					return H.ignoreAmbiguities === !0
				});
				var Y = t.reduce(Z, function(H, oe) {
					var de = oe.idx,
						te = oe.maxLookahead || F,
						fe = o.getLookaheadPathsForOr(de, k, te, oe),
						me = T(fe, oe, k, U),
						P = C(fe, oe, k, U);
					return H.concat(me, P)
				}, []);
				return Y
			}
			r.validateAmbiguousAlternationAlternatives = M;
			var I = function(k) {
				e(F, k);

				function F() {
					var U = k !== null && k.apply(this, arguments) || this;
					return U.allProductions = [], U
				}
				return F.prototype.visitRepetitionWithSeparator = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitRepetitionMandatory = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitRepetitionMandatoryWithSeparator = function(U) {
					this.allProductions.push(U)
				}, F.prototype.visitRepetition = function(U) {
					this.allProductions.push(U)
				}, F
			}(c.GAstVisitor);
			r.RepetionCollector = I;

			function w(k, F) {
				var U = new v;
				k.accept(U);
				var K = U.alternations,
					Z = t.reduce(K, function(Y, H) {
						return H.definition.length > 255 && Y.push({
							message: F.buildTooManyAlternativesError({
								topLevelRule: k,
								alternation: H
							}),
							type: i.ParserDefinitionErrorType.TOO_MANY_ALTS,
							ruleName: k.name,
							occurrence: H.idx
						}), Y
					}, []);
				return Z
			}
			r.validateTooManyAlts = w;

			function L(k, F, U) {
				var K = [];
				return n.forEach(k, function(Z) {
					var Y = new I;
					Z.accept(Y);
					var H = Y.allProductions;
					n.forEach(H, function(oe) {
						var de = o.getProdType(oe),
							te = oe.maxLookahead || F,
							fe = oe.idx,
							me = o.getLookaheadPathsForOptionalProd(fe, Z, de, te),
							P = me[0];
						if (n.isEmpty(n.flatten(P))) {
							var b = U.buildEmptyRepetitionError({
								topLevelRule: Z,
								repetition: oe
							});
							K.push({
								message: b,
								type: i.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
								ruleName: Z.name
							})
						}
					})
				}), K
			}
			r.validateSomeNonEmptyLookaheadPath = L;

			function T(k, F, U, K) {
				var Z = [],
					Y = n.reduce(k, function(oe, de, te) {
						return F.definition[te].ignoreAmbiguities === !0 || n.forEach(de, function(fe) {
							var me = [te];
							n.forEach(k, function(P, b) {
								te !== b && o.containsPath(P, fe) && F.definition[b].ignoreAmbiguities !== !0 && me.push(b)
							}), me.length > 1 && !o.containsPath(Z, fe) && (Z.push(fe), oe.push({
								alts: me,
								path: fe
							}))
						}), oe
					}, []),
					H = t.map(Y, function(oe) {
						var de = n.map(oe.alts, function(fe) {
								return fe + 1
							}),
							te = K.buildAlternationAmbiguityError({
								topLevelRule: U,
								alternation: F,
								ambiguityIndices: de,
								prefixPath: oe.path
							});
						return {
							message: te,
							type: i.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
							ruleName: U.name,
							occurrence: F.idx,
							alternatives: [oe.alts]
						}
					});
				return H
			}

			function C(k, F, U, K) {
				var Z = [],
					Y = n.reduce(k, function(H, oe, de) {
						var te = n.map(oe, function(fe) {
							return {
								idx: de,
								path: fe
							}
						});
						return H.concat(te)
					}, []);
				return n.forEach(Y, function(H) {
					var oe = F.definition[H.idx];
					if (oe.ignoreAmbiguities !== !0) {
						var de = H.idx,
							te = H.path,
							fe = n.findAll(Y, function(P) {
								return F.definition[P.idx].ignoreAmbiguities !== !0 && P.idx < de && o.isStrictPrefixOfPath(P.path, te)
							}),
							me = n.map(fe, function(P) {
								var b = [P.idx + 1, de + 1],
									S = F.idx === 0 ? "" : F.idx,
									A = K.buildAlternationPrefixAmbiguityError({
										topLevelRule: U,
										alternation: F,
										ambiguityIndices: b,
										prefixPath: P.path
									});
								return {
									message: A,
									type: i.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
									ruleName: U.name,
									occurrence: S,
									alternatives: b
								}
							});
						Z = Z.concat(me)
					}
				}), Z
			}
			r.checkPrefixAlternativesAmbiguities = C;

			function V(k, F, U) {
				var K = [],
					Z = n.map(F, function(Y) {
						return Y.name
					});
				return n.forEach(k, function(Y) {
					var H = Y.name;
					if (n.contains(Z, H)) {
						var oe = U.buildNamespaceConflictError(Y);
						K.push({
							message: oe,
							type: i.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
							ruleName: H
						})
					}
				}), K
			}
		}),
		Eb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.validateGrammar = r.resolveGrammar = void 0;
			var e = Ft(),
				t = Tb(),
				n = p0(),
				i = ih();

			function s(a) {
				a = e.defaults(a, {
					errMsgProvider: i.defaultGrammarResolverErrorProvider
				});
				var l = {};
				return e.forEach(a.rules, function(c) {
					l[c.name] = c
				}), t.resolveGrammar(l, a.errMsgProvider)
			}
			r.resolveGrammar = s;

			function o(a) {
				return a = e.defaults(a, {
					errMsgProvider: i.defaultGrammarValidatorErrorProvider
				}), n.validateGrammar(a.rules, a.maxLookahead, a.tokenTypes, a.errMsgProvider, a.grammarName)
			}
			r.validateGrammar = o
		}),
		jl = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var g = function(y, d) {
					return g = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(p, _) {
						p.__proto__ = _
					} || function(p, _) {
						for (var v in _) Object.prototype.hasOwnProperty.call(_, v) && (p[v] = _[v])
					}, g(y, d)
				};
				return function(y, d) {
					if (typeof d != "function" && d !== null) throw new TypeError("Class extends value " + String(d) + " is not a constructor or null");
					g(y, d);

					function p() {
						this.constructor = y
					}
					y.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.EarlyExitException = r.NotAllInputParsedException = r.NoViableAltException = r.MismatchedTokenException = r.isRecognitionException = void 0;
			var t = Ft(),
				n = "MismatchedTokenException",
				i = "NoViableAltException",
				s = "EarlyExitException",
				o = "NotAllInputParsedException",
				a = [n, i, s, o];
			Object.freeze(a);

			function l(g) {
				return t.contains(a, g.name)
			}
			r.isRecognitionException = l;
			var c = function(g) {
					e(y, g);

					function y(d, p) {
						var _ = this.constructor,
							v = g.call(this, d) || this;
						return v.token = p, v.resyncedTokens = [], Object.setPrototypeOf(v, _.prototype), Error.captureStackTrace && Error.captureStackTrace(v, v.constructor), v
					}
					return y
				}(Error),
				u = function(g) {
					e(y, g);

					function y(d, p, _) {
						var v = g.call(this, d, p) || this;
						return v.previousToken = _, v.name = n, v
					}
					return y
				}(c);
			r.MismatchedTokenException = u;
			var h = function(g) {
				e(y, g);

				function y(d, p, _) {
					var v = g.call(this, d, p) || this;
					return v.previousToken = _, v.name = i, v
				}
				return y
			}(c);
			r.NoViableAltException = h;
			var f = function(g) {
				e(y, g);

				function y(d, p) {
					var _ = g.call(this, d, p) || this;
					return _.name = o, _
				}
				return y
			}(c);
			r.NotAllInputParsedException = f;
			var m = function(g) {
				e(y, g);

				function y(d, p, _) {
					var v = g.call(this, d, p) || this;
					return v.previousToken = _, v.name = s, v
				}
				return y
			}(c);
			r.EarlyExitException = m
		}),
		m0 = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.attemptInRepetitionRecovery = r.Recoverable = r.InRuleRecoveryException = r.IN_RULE_RECOVERY_EXCEPTION = r.EOF_FOLLOW_KEY = void 0;
			var e = Qs(),
				t = Ft(),
				n = jl(),
				i = d0(),
				s = Ai();
			r.EOF_FOLLOW_KEY = {}, r.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";

			function o(c) {
				this.name = r.IN_RULE_RECOVERY_EXCEPTION, this.message = c
			}
			r.InRuleRecoveryException = o, o.prototype = Error.prototype;
			var a = function() {
				function c() {}
				return c.prototype.initRecoverable = function(u) {
					this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = t.has(u, "recoveryEnabled") ? u.recoveryEnabled : s.DEFAULT_PARSER_CONFIG.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = l)
				}, c.prototype.getTokenToInsert = function(u) {
					var h = e.createTokenInstance(u, "", NaN, NaN, NaN, NaN, NaN, NaN);
					return h.isInsertedInRecovery = !0, h
				}, c.prototype.canTokenTypeBeInsertedInRecovery = function(u) {
					return !0
				}, c.prototype.tryInRepetitionRecovery = function(u, h, f, m) {
					for (var g = this, y = this.findReSyncTokenType(), d = this.exportLexerState(), p = [], _ = !1, v = this.LA(1), x = this.LA(1), M = function() {
							var I = g.LA(0),
								w = g.errorMessageProvider.buildMismatchTokenMessage({
									expected: m,
									actual: v,
									previous: I,
									ruleName: g.getCurrRuleFullName()
								}),
								L = new n.MismatchedTokenException(w, v, g.LA(0));
							L.resyncedTokens = t.dropRight(p), g.SAVE_ERROR(L)
						}; !_;)
						if (this.tokenMatcher(x, m)) {
							M();
							return
						} else if (f.call(this)) {
						M(), u.apply(this, h);
						return
					} else this.tokenMatcher(x, y) ? _ = !0 : (x = this.SKIP_TOKEN(), this.addToResyncTokens(x, p));
					this.importLexerState(d)
				}, c.prototype.shouldInRepetitionRecoveryBeTried = function(u, h, f) {
					return !(f === !1 || u === void 0 || h === void 0 || this.tokenMatcher(this.LA(1), u) || this.isBackTracking() || this.canPerformInRuleRecovery(u, this.getFollowsForInRuleRecovery(u, h)))
				}, c.prototype.getFollowsForInRuleRecovery = function(u, h) {
					var f = this.getCurrentGrammarPath(u, h),
						m = this.getNextPossibleTokenTypes(f);
					return m
				}, c.prototype.tryInRuleRecovery = function(u, h) {
					if (this.canRecoverWithSingleTokenInsertion(u, h)) {
						var f = this.getTokenToInsert(u);
						return f
					}
					if (this.canRecoverWithSingleTokenDeletion(u)) {
						var m = this.SKIP_TOKEN();
						return this.consumeToken(), m
					}
					throw new o("sad sad panda")
				}, c.prototype.canPerformInRuleRecovery = function(u, h) {
					return this.canRecoverWithSingleTokenInsertion(u, h) || this.canRecoverWithSingleTokenDeletion(u)
				}, c.prototype.canRecoverWithSingleTokenInsertion = function(u, h) {
					var f = this;
					if (!this.canTokenTypeBeInsertedInRecovery(u) || t.isEmpty(h)) return !1;
					var m = this.LA(1),
						g = t.find(h, function(y) {
							return f.tokenMatcher(m, y)
						}) !== void 0;
					return g
				}, c.prototype.canRecoverWithSingleTokenDeletion = function(u) {
					var h = this.tokenMatcher(this.LA(2), u);
					return h
				}, c.prototype.isInCurrentRuleReSyncSet = function(u) {
					var h = this.getCurrFollowKey(),
						f = this.getFollowSetFromFollowKey(h);
					return t.contains(f, u)
				}, c.prototype.findReSyncTokenType = function() {
					for (var u = this.flattenFollowSet(), h = this.LA(1), f = 2;;) {
						var m = h.tokenType;
						if (t.contains(u, m)) return m;
						h = this.LA(f), f++
					}
				}, c.prototype.getCurrFollowKey = function() {
					if (this.RULE_STACK.length === 1) return r.EOF_FOLLOW_KEY;
					var u = this.getLastExplicitRuleShortName(),
						h = this.getLastExplicitRuleOccurrenceIndex(),
						f = this.getPreviousExplicitRuleShortName();
					return {
						ruleName: this.shortRuleNameToFullName(u),
						idxInCallingRule: h,
						inRule: this.shortRuleNameToFullName(f)
					}
				}, c.prototype.buildFullFollowKeyStack = function() {
					var u = this,
						h = this.RULE_STACK,
						f = this.RULE_OCCURRENCE_STACK;
					return t.map(h, function(m, g) {
						return g === 0 ? r.EOF_FOLLOW_KEY : {
							ruleName: u.shortRuleNameToFullName(m),
							idxInCallingRule: f[g],
							inRule: u.shortRuleNameToFullName(h[g - 1])
						}
					})
				}, c.prototype.flattenFollowSet = function() {
					var u = this,
						h = t.map(this.buildFullFollowKeyStack(), function(f) {
							return u.getFollowSetFromFollowKey(f)
						});
					return t.flatten(h)
				}, c.prototype.getFollowSetFromFollowKey = function(u) {
					if (u === r.EOF_FOLLOW_KEY) return [e.EOF];
					var h = u.ruleName + u.idxInCallingRule + i.IN + u.inRule;
					return this.resyncFollows[h]
				}, c.prototype.addToResyncTokens = function(u, h) {
					return this.tokenMatcher(u, e.EOF) || h.push(u), h
				}, c.prototype.reSyncTo = function(u) {
					for (var h = [], f = this.LA(1); this.tokenMatcher(f, u) === !1;) f = this.SKIP_TOKEN(), this.addToResyncTokens(f, h);
					return t.dropRight(h)
				}, c.prototype.attemptInRepetitionRecovery = function(u, h, f, m, g, y, d) {}, c.prototype.getCurrentGrammarPath = function(u, h) {
					var f = this.getHumanReadableRuleStack(),
						m = t.cloneArr(this.RULE_OCCURRENCE_STACK),
						g = {
							ruleStack: f,
							occurrenceStack: m,
							lastTok: u,
							lastTokOccurrence: h
						};
					return g
				}, c.prototype.getHumanReadableRuleStack = function() {
					var u = this;
					return t.map(this.RULE_STACK, function(h) {
						return u.shortRuleNameToFullName(h)
					})
				}, c
			}();
			r.Recoverable = a;

			function l(c, u, h, f, m, g, y) {
				var d = this.getKeyForAutomaticLookahead(f, m),
					p = this.firstAfterRepMap[d];
				if (p === void 0) {
					var _ = this.getCurrRuleFullName(),
						v = this.getGAstProductions()[_],
						x = new g(v, m);
					p = x.startWalking(), this.firstAfterRepMap[d] = p
				}
				var M = p.token,
					I = p.occurrence,
					w = p.isEndOfRule;
				this.RULE_STACK.length === 1 && w && M === void 0 && (M = e.EOF, I = 1), this.shouldInRepetitionRecoveryBeTried(M, I, y) && this.tryInRepetitionRecovery(c, u, h, M)
			}
			r.attemptInRepetitionRecovery = l
		}),
		Pd = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.getKeyForAutomaticLookahead = r.AT_LEAST_ONE_SEP_IDX = r.MANY_SEP_IDX = r.AT_LEAST_ONE_IDX = r.MANY_IDX = r.OPTION_IDX = r.OR_IDX = r.BITS_FOR_ALT_IDX = r.BITS_FOR_RULE_IDX = r.BITS_FOR_OCCURRENCE_IDX = r.BITS_FOR_METHOD_TYPE = void 0, r.BITS_FOR_METHOD_TYPE = 4, r.BITS_FOR_OCCURRENCE_IDX = 8, r.BITS_FOR_RULE_IDX = 12, r.BITS_FOR_ALT_IDX = 8, r.OR_IDX = 1 << r.BITS_FOR_OCCURRENCE_IDX, r.OPTION_IDX = 2 << r.BITS_FOR_OCCURRENCE_IDX, r.MANY_IDX = 3 << r.BITS_FOR_OCCURRENCE_IDX, r.AT_LEAST_ONE_IDX = 4 << r.BITS_FOR_OCCURRENCE_IDX, r.MANY_SEP_IDX = 5 << r.BITS_FOR_OCCURRENCE_IDX, r.AT_LEAST_ONE_SEP_IDX = 6 << r.BITS_FOR_OCCURRENCE_IDX;

			function e(n, i, s) {
				return s | i | n
			}
			r.getKeyForAutomaticLookahead = e;
			var t = 32 - r.BITS_FOR_ALT_IDX
		}),
		Mb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.LooksAhead = void 0;
			var e = sh(),
				t = Ft(),
				n = Ai(),
				i = Pd(),
				s = nh(),
				o = function() {
					function a() {}
					return a.prototype.initLooksAhead = function(l) {
						this.dynamicTokensEnabled = t.has(l, "dynamicTokensEnabled") ? l.dynamicTokensEnabled : n.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled, this.maxLookahead = t.has(l, "maxLookahead") ? l.maxLookahead : n.DEFAULT_PARSER_CONFIG.maxLookahead, this.lookAheadFuncsCache = t.isES2015MapSupported() ? new Map : [], t.isES2015MapSupported() ? (this.getLaFuncFromCache = this.getLaFuncFromMap, this.setLaFuncCache = this.setLaFuncCacheUsingMap) : (this.getLaFuncFromCache = this.getLaFuncFromObj, this.setLaFuncCache = this.setLaFuncUsingObj)
					}, a.prototype.preComputeLookaheadFunctions = function(l) {
						var c = this;
						t.forEach(l, function(u) {
							c.TRACE_INIT(u.name + " Rule Lookahead", function() {
								var h = s.collectMethods(u),
									f = h.alternation,
									m = h.repetition,
									g = h.option,
									y = h.repetitionMandatory,
									d = h.repetitionMandatoryWithSeparator,
									p = h.repetitionWithSeparator;
								t.forEach(f, function(_) {
									var v = _.idx === 0 ? "" : _.idx;
									c.TRACE_INIT("" + s.getProductionDslName(_) + v, function() {
										var x = e.buildLookaheadFuncForOr(_.idx, u, _.maxLookahead || c.maxLookahead, _.hasPredicates, c.dynamicTokensEnabled, c.lookAheadBuilderForAlternatives),
											M = i.getKeyForAutomaticLookahead(c.fullRuleNameToShort[u.name], i.OR_IDX, _.idx);
										c.setLaFuncCache(M, x)
									})
								}), t.forEach(m, function(_) {
									c.computeLookaheadFunc(u, _.idx, i.MANY_IDX, e.PROD_TYPE.REPETITION, _.maxLookahead, s.getProductionDslName(_))
								}), t.forEach(g, function(_) {
									c.computeLookaheadFunc(u, _.idx, i.OPTION_IDX, e.PROD_TYPE.OPTION, _.maxLookahead, s.getProductionDslName(_))
								}), t.forEach(y, function(_) {
									c.computeLookaheadFunc(u, _.idx, i.AT_LEAST_ONE_IDX, e.PROD_TYPE.REPETITION_MANDATORY, _.maxLookahead, s.getProductionDslName(_))
								}), t.forEach(d, function(_) {
									c.computeLookaheadFunc(u, _.idx, i.AT_LEAST_ONE_SEP_IDX, e.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, _.maxLookahead, s.getProductionDslName(_))
								}), t.forEach(p, function(_) {
									c.computeLookaheadFunc(u, _.idx, i.MANY_SEP_IDX, e.PROD_TYPE.REPETITION_WITH_SEPARATOR, _.maxLookahead, s.getProductionDslName(_))
								})
							})
						})
					}, a.prototype.computeLookaheadFunc = function(l, c, u, h, f, m) {
						var g = this;
						this.TRACE_INIT("" + m + (c === 0 ? "" : c), function() {
							var y = e.buildLookaheadFuncForOptionalProd(c, l, f || g.maxLookahead, g.dynamicTokensEnabled, h, g.lookAheadBuilderForOptional),
								d = i.getKeyForAutomaticLookahead(g.fullRuleNameToShort[l.name], u, c);
							g.setLaFuncCache(d, y)
						})
					}, a.prototype.lookAheadBuilderForOptional = function(l, c, u) {
						return e.buildSingleAlternativeLookaheadFunction(l, c, u)
					}, a.prototype.lookAheadBuilderForAlternatives = function(l, c, u, h) {
						return e.buildAlternativesLookAheadFunc(l, c, u, h)
					}, a.prototype.getKeyForAutomaticLookahead = function(l, c) {
						var u = this.getLastExplicitRuleShortName();
						return i.getKeyForAutomaticLookahead(u, l, c)
					}, a.prototype.getLaFuncFromCache = function(l) {}, a.prototype.getLaFuncFromMap = function(l) {
						return this.lookAheadFuncsCache.get(l)
					}, a.prototype.getLaFuncFromObj = function(l) {
						return this.lookAheadFuncsCache[l]
					}, a.prototype.setLaFuncCache = function(l, c) {}, a.prototype.setLaFuncCacheUsingMap = function(l, c) {
						this.lookAheadFuncsCache.set(l, c)
					}, a.prototype.setLaFuncUsingObj = function(l, c) {
						this.lookAheadFuncsCache[l] = c
					}, a
				}();
			r.LooksAhead = o
		}),
		bb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.addNoneTerminalToCst = r.addTerminalToCst = r.setNodeLocationFull = r.setNodeLocationOnlyOffset = void 0;

			function e(s, o) {
				isNaN(s.startOffset) === !0 ? (s.startOffset = o.startOffset, s.endOffset = o.endOffset) : s.endOffset < o.endOffset && (s.endOffset = o.endOffset)
			}
			r.setNodeLocationOnlyOffset = e;

			function t(s, o) {
				isNaN(s.startOffset) === !0 ? (s.startOffset = o.startOffset, s.startColumn = o.startColumn, s.startLine = o.startLine, s.endOffset = o.endOffset, s.endColumn = o.endColumn, s.endLine = o.endLine) : s.endOffset < o.endOffset && (s.endOffset = o.endOffset, s.endColumn = o.endColumn, s.endLine = o.endLine)
			}
			r.setNodeLocationFull = t;

			function n(s, o, a) {
				s.children[a] === void 0 ? s.children[a] = [o] : s.children[a].push(o)
			}
			r.addTerminalToCst = n;

			function i(s, o, a) {
				s.children[o] === void 0 ? s.children[o] = [a] : s.children[o].push(a)
			}
			r.addNoneTerminalToCst = i
		}),
		g0 = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.defineNameProp = r.functionName = r.classNameFromInstance = void 0;
			var e = Ft();

			function t(o) {
				return i(o.constructor)
			}
			r.classNameFromInstance = t;
			var n = "name";

			function i(o) {
				var a = o.name;
				return a || "anonymous"
			}
			r.functionName = i;

			function s(o, a) {
				var l = Object.getOwnPropertyDescriptor(o, n);
				return e.isUndefined(l) || l.configurable ? (Object.defineProperty(o, n, {
					enumerable: !1,
					configurable: !0,
					writable: !1,
					value: a
				}), !0) : !1
			}
			r.defineNameProp = s
		}),
		Sb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.validateRedundantMethods = r.validateMissingCstMethods = r.validateVisitor = r.CstVisitorDefinitionError = r.createBaseVisitorConstructorWithDefaults = r.createBaseSemanticVisitorConstructor = r.defaultVisit = void 0;
			var e = Ft(),
				t = g0();

			function n(h, f) {
				for (var m = e.keys(h), g = m.length, y = 0; y < g; y++)
					for (var d = m[y], p = h[d], _ = p.length, v = 0; v < _; v++) {
						var x = p[v];
						x.tokenTypeIdx === void 0 && this[x.name](x.children, f)
					}
			}
			r.defaultVisit = n;

			function i(h, f) {
				var m = function() {};
				t.defineNameProp(m, h + "BaseSemantics");
				var g = {
					visit: function(y, d) {
						if (e.isArray(y) && (y = y[0]), !e.isUndefined(y)) return this[y.name](y.children, d)
					},
					validateVisitor: function() {
						var y = a(this, f);
						if (!e.isEmpty(y)) {
							var d = e.map(y, function(p) {
								return p.msg
							});
							throw Error("Errors Detected in CST Visitor <" + t.functionName(this.constructor) + `>:
	` + ("" + d.join(`

`).replace(/\n/g, `
	`)))
						}
					}
				};
				return m.prototype = g, m.prototype.constructor = m, m._RULE_NAMES = f, m
			}
			r.createBaseSemanticVisitorConstructor = i;

			function s(h, f, m) {
				var g = function() {};
				t.defineNameProp(g, h + "BaseSemanticsWithDefaults");
				var y = Object.create(m.prototype);
				return e.forEach(f, function(d) {
					y[d] = n
				}), g.prototype = y, g.prototype.constructor = g, g
			}
			r.createBaseVisitorConstructorWithDefaults = s;
			var o;
			(function(h) {
				h[h.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", h[h.MISSING_METHOD = 1] = "MISSING_METHOD"
			})(o = r.CstVisitorDefinitionError || (r.CstVisitorDefinitionError = {}));

			function a(h, f) {
				var m = l(h, f),
					g = u(h, f);
				return m.concat(g)
			}
			r.validateVisitor = a;

			function l(h, f) {
				var m = e.map(f, function(g) {
					if (!e.isFunction(h[g])) return {
						msg: "Missing visitor method: <" + g + "> on " + t.functionName(h.constructor) + " CST Visitor.",
						type: o.MISSING_METHOD,
						methodName: g
					}
				});
				return e.compact(m)
			}
			r.validateMissingCstMethods = l;
			var c = ["constructor", "visit", "validateVisitor"];

			function u(h, f) {
				var m = [];
				for (var g in h) e.isFunction(h[g]) && !e.contains(c, g) && !e.contains(f, g) && m.push({
					msg: "Redundant visitor method: <" + g + "> on " + t.functionName(h.constructor) + ` CST Visitor
There is no Grammar Rule corresponding to this method's name.
`,
					type: o.REDUNDANT_METHOD,
					methodName: g
				});
				return m
			}
			r.validateRedundantMethods = u
		}),
		Ab = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.TreeBuilder = void 0;
			var e = bb(),
				t = Ft(),
				n = Sb(),
				i = Ai(),
				s = function() {
					function o() {}
					return o.prototype.initTreeBuilder = function(a) {
						if (this.CST_STACK = [], this.outputCst = a.outputCst, this.nodeLocationTracking = t.has(a, "nodeLocationTracking") ? a.nodeLocationTracking : i.DEFAULT_PARSER_CONFIG.nodeLocationTracking, !this.outputCst) this.cstInvocationStateUpdate = t.NOOP, this.cstFinallyStateUpdate = t.NOOP, this.cstPostTerminal = t.NOOP, this.cstPostNonTerminal = t.NOOP, this.cstPostRule = t.NOOP;
						else if (/full/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = e.setNodeLocationFull, this.setNodeLocationFromNode = e.setNodeLocationFull, this.cstPostRule = t.NOOP, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = t.NOOP, this.setNodeLocationFromNode = t.NOOP, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
						else if (/onlyOffset/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = e.setNodeLocationOnlyOffset, this.setNodeLocationFromNode = e.setNodeLocationOnlyOffset, this.cstPostRule = t.NOOP, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = t.NOOP, this.setNodeLocationFromNode = t.NOOP, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
						else if (/none/i.test(this.nodeLocationTracking)) this.setNodeLocationFromToken = t.NOOP, this.setNodeLocationFromNode = t.NOOP, this.cstPostRule = t.NOOP, this.setInitialNodeLocation = t.NOOP;
						else throw Error('Invalid <nodeLocationTracking> config option: "' + a.nodeLocationTracking + '"')
					}, o.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(a) {
						a.location = {
							startOffset: NaN,
							endOffset: NaN
						}
					}, o.prototype.setInitialNodeLocationOnlyOffsetRegular = function(a) {
						a.location = {
							startOffset: this.LA(1).startOffset,
							endOffset: NaN
						}
					}, o.prototype.setInitialNodeLocationFullRecovery = function(a) {
						a.location = {
							startOffset: NaN,
							startLine: NaN,
							startColumn: NaN,
							endOffset: NaN,
							endLine: NaN,
							endColumn: NaN
						}
					}, o.prototype.setInitialNodeLocationFullRegular = function(a) {
						var l = this.LA(1);
						a.location = {
							startOffset: l.startOffset,
							startLine: l.startLine,
							startColumn: l.startColumn,
							endOffset: NaN,
							endLine: NaN,
							endColumn: NaN
						}
					}, o.prototype.cstInvocationStateUpdate = function(a, l) {
						var c = {
							name: a,
							children: {}
						};
						this.setInitialNodeLocation(c), this.CST_STACK.push(c)
					}, o.prototype.cstFinallyStateUpdate = function() {
						this.CST_STACK.pop()
					}, o.prototype.cstPostRuleFull = function(a) {
						var l = this.LA(0),
							c = a.location;
						c.startOffset <= l.startOffset ? (c.endOffset = l.endOffset, c.endLine = l.endLine, c.endColumn = l.endColumn) : (c.startOffset = NaN, c.startLine = NaN, c.startColumn = NaN)
					}, o.prototype.cstPostRuleOnlyOffset = function(a) {
						var l = this.LA(0),
							c = a.location;
						c.startOffset <= l.startOffset ? c.endOffset = l.endOffset : c.startOffset = NaN
					}, o.prototype.cstPostTerminal = function(a, l) {
						var c = this.CST_STACK[this.CST_STACK.length - 1];
						e.addTerminalToCst(c, l, a), this.setNodeLocationFromToken(c.location, l)
					}, o.prototype.cstPostNonTerminal = function(a, l) {
						var c = this.CST_STACK[this.CST_STACK.length - 1];
						e.addNoneTerminalToCst(c, l, a), this.setNodeLocationFromNode(c.location, a.location)
					}, o.prototype.getBaseCstVisitorConstructor = function() {
						if (t.isUndefined(this.baseCstVisitorConstructor)) {
							var a = n.createBaseSemanticVisitorConstructor(this.className, t.keys(this.gastProductionsCache));
							return this.baseCstVisitorConstructor = a, a
						}
						return this.baseCstVisitorConstructor
					}, o.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
						if (t.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {
							var a = n.createBaseVisitorConstructorWithDefaults(this.className, t.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
							return this.baseCstVisitorWithDefaultsConstructor = a, a
						}
						return this.baseCstVisitorWithDefaultsConstructor
					}, o.prototype.getLastExplicitRuleShortName = function() {
						var a = this.RULE_STACK;
						return a[a.length - 1]
					}, o.prototype.getPreviousExplicitRuleShortName = function() {
						var a = this.RULE_STACK;
						return a[a.length - 2]
					}, o.prototype.getLastExplicitRuleOccurrenceIndex = function() {
						var a = this.RULE_OCCURRENCE_STACK;
						return a[a.length - 1]
					}, o
				}();
			r.TreeBuilder = s
		}),
		wb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.LexerAdapter = void 0;
			var e = Ai(),
				t = function() {
					function n() {}
					return n.prototype.initLexerAdapter = function() {
						this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1
					}, Object.defineProperty(n.prototype, "input", {
						get: function() {
							return this.tokVector
						},
						set: function(i) {
							if (this.selfAnalysisDone !== !0) throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
							this.reset(), this.tokVector = i, this.tokVectorLength = i.length
						},
						enumerable: !1,
						configurable: !0
					}), n.prototype.SKIP_TOKEN = function() {
						return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : e.END_OF_FILE
					}, n.prototype.LA = function(i) {
						var s = this.currIdx + i;
						return s < 0 || this.tokVectorLength <= s ? e.END_OF_FILE : this.tokVector[s]
					}, n.prototype.consumeToken = function() {
						this.currIdx++
					}, n.prototype.exportLexerState = function() {
						return this.currIdx
					}, n.prototype.importLexerState = function(i) {
						this.currIdx = i
					}, n.prototype.resetLexerState = function() {
						this.currIdx = -1
					}, n.prototype.moveToTerminatedState = function() {
						this.currIdx = this.tokVector.length - 1
					}, n.prototype.getLexerPosition = function() {
						return this.exportLexerState()
					}, n
				}();
			r.LexerAdapter = t
		}),
		Cb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.RecognizerApi = void 0;
			var e = Ft(),
				t = jl(),
				n = Ai(),
				i = ih(),
				s = p0(),
				o = pi(),
				a = function() {
					function l() {}
					return l.prototype.ACTION = function(c) {
						return c.call(this)
					}, l.prototype.consume = function(c, u, h) {
						return this.consumeInternal(u, c, h)
					}, l.prototype.subrule = function(c, u, h) {
						return this.subruleInternal(u, c, h)
					}, l.prototype.option = function(c, u) {
						return this.optionInternal(u, c)
					}, l.prototype.or = function(c, u) {
						return this.orInternal(u, c)
					}, l.prototype.many = function(c, u) {
						return this.manyInternal(c, u)
					}, l.prototype.atLeastOne = function(c, u) {
						return this.atLeastOneInternal(c, u)
					}, l.prototype.CONSUME = function(c, u) {
						return this.consumeInternal(c, 0, u)
					}, l.prototype.CONSUME1 = function(c, u) {
						return this.consumeInternal(c, 1, u)
					}, l.prototype.CONSUME2 = function(c, u) {
						return this.consumeInternal(c, 2, u)
					}, l.prototype.CONSUME3 = function(c, u) {
						return this.consumeInternal(c, 3, u)
					}, l.prototype.CONSUME4 = function(c, u) {
						return this.consumeInternal(c, 4, u)
					}, l.prototype.CONSUME5 = function(c, u) {
						return this.consumeInternal(c, 5, u)
					}, l.prototype.CONSUME6 = function(c, u) {
						return this.consumeInternal(c, 6, u)
					}, l.prototype.CONSUME7 = function(c, u) {
						return this.consumeInternal(c, 7, u)
					}, l.prototype.CONSUME8 = function(c, u) {
						return this.consumeInternal(c, 8, u)
					}, l.prototype.CONSUME9 = function(c, u) {
						return this.consumeInternal(c, 9, u)
					}, l.prototype.SUBRULE = function(c, u) {
						return this.subruleInternal(c, 0, u)
					}, l.prototype.SUBRULE1 = function(c, u) {
						return this.subruleInternal(c, 1, u)
					}, l.prototype.SUBRULE2 = function(c, u) {
						return this.subruleInternal(c, 2, u)
					}, l.prototype.SUBRULE3 = function(c, u) {
						return this.subruleInternal(c, 3, u)
					}, l.prototype.SUBRULE4 = function(c, u) {
						return this.subruleInternal(c, 4, u)
					}, l.prototype.SUBRULE5 = function(c, u) {
						return this.subruleInternal(c, 5, u)
					}, l.prototype.SUBRULE6 = function(c, u) {
						return this.subruleInternal(c, 6, u)
					}, l.prototype.SUBRULE7 = function(c, u) {
						return this.subruleInternal(c, 7, u)
					}, l.prototype.SUBRULE8 = function(c, u) {
						return this.subruleInternal(c, 8, u)
					}, l.prototype.SUBRULE9 = function(c, u) {
						return this.subruleInternal(c, 9, u)
					}, l.prototype.OPTION = function(c) {
						return this.optionInternal(c, 0)
					}, l.prototype.OPTION1 = function(c) {
						return this.optionInternal(c, 1)
					}, l.prototype.OPTION2 = function(c) {
						return this.optionInternal(c, 2)
					}, l.prototype.OPTION3 = function(c) {
						return this.optionInternal(c, 3)
					}, l.prototype.OPTION4 = function(c) {
						return this.optionInternal(c, 4)
					}, l.prototype.OPTION5 = function(c) {
						return this.optionInternal(c, 5)
					}, l.prototype.OPTION6 = function(c) {
						return this.optionInternal(c, 6)
					}, l.prototype.OPTION7 = function(c) {
						return this.optionInternal(c, 7)
					}, l.prototype.OPTION8 = function(c) {
						return this.optionInternal(c, 8)
					}, l.prototype.OPTION9 = function(c) {
						return this.optionInternal(c, 9)
					}, l.prototype.OR = function(c) {
						return this.orInternal(c, 0)
					}, l.prototype.OR1 = function(c) {
						return this.orInternal(c, 1)
					}, l.prototype.OR2 = function(c) {
						return this.orInternal(c, 2)
					}, l.prototype.OR3 = function(c) {
						return this.orInternal(c, 3)
					}, l.prototype.OR4 = function(c) {
						return this.orInternal(c, 4)
					}, l.prototype.OR5 = function(c) {
						return this.orInternal(c, 5)
					}, l.prototype.OR6 = function(c) {
						return this.orInternal(c, 6)
					}, l.prototype.OR7 = function(c) {
						return this.orInternal(c, 7)
					}, l.prototype.OR8 = function(c) {
						return this.orInternal(c, 8)
					}, l.prototype.OR9 = function(c) {
						return this.orInternal(c, 9)
					}, l.prototype.MANY = function(c) {
						this.manyInternal(0, c)
					}, l.prototype.MANY1 = function(c) {
						this.manyInternal(1, c)
					}, l.prototype.MANY2 = function(c) {
						this.manyInternal(2, c)
					}, l.prototype.MANY3 = function(c) {
						this.manyInternal(3, c)
					}, l.prototype.MANY4 = function(c) {
						this.manyInternal(4, c)
					}, l.prototype.MANY5 = function(c) {
						this.manyInternal(5, c)
					}, l.prototype.MANY6 = function(c) {
						this.manyInternal(6, c)
					}, l.prototype.MANY7 = function(c) {
						this.manyInternal(7, c)
					}, l.prototype.MANY8 = function(c) {
						this.manyInternal(8, c)
					}, l.prototype.MANY9 = function(c) {
						this.manyInternal(9, c)
					}, l.prototype.MANY_SEP = function(c) {
						this.manySepFirstInternal(0, c)
					}, l.prototype.MANY_SEP1 = function(c) {
						this.manySepFirstInternal(1, c)
					}, l.prototype.MANY_SEP2 = function(c) {
						this.manySepFirstInternal(2, c)
					}, l.prototype.MANY_SEP3 = function(c) {
						this.manySepFirstInternal(3, c)
					}, l.prototype.MANY_SEP4 = function(c) {
						this.manySepFirstInternal(4, c)
					}, l.prototype.MANY_SEP5 = function(c) {
						this.manySepFirstInternal(5, c)
					}, l.prototype.MANY_SEP6 = function(c) {
						this.manySepFirstInternal(6, c)
					}, l.prototype.MANY_SEP7 = function(c) {
						this.manySepFirstInternal(7, c)
					}, l.prototype.MANY_SEP8 = function(c) {
						this.manySepFirstInternal(8, c)
					}, l.prototype.MANY_SEP9 = function(c) {
						this.manySepFirstInternal(9, c)
					}, l.prototype.AT_LEAST_ONE = function(c) {
						this.atLeastOneInternal(0, c)
					}, l.prototype.AT_LEAST_ONE1 = function(c) {
						return this.atLeastOneInternal(1, c)
					}, l.prototype.AT_LEAST_ONE2 = function(c) {
						this.atLeastOneInternal(2, c)
					}, l.prototype.AT_LEAST_ONE3 = function(c) {
						this.atLeastOneInternal(3, c)
					}, l.prototype.AT_LEAST_ONE4 = function(c) {
						this.atLeastOneInternal(4, c)
					}, l.prototype.AT_LEAST_ONE5 = function(c) {
						this.atLeastOneInternal(5, c)
					}, l.prototype.AT_LEAST_ONE6 = function(c) {
						this.atLeastOneInternal(6, c)
					}, l.prototype.AT_LEAST_ONE7 = function(c) {
						this.atLeastOneInternal(7, c)
					}, l.prototype.AT_LEAST_ONE8 = function(c) {
						this.atLeastOneInternal(8, c)
					}, l.prototype.AT_LEAST_ONE9 = function(c) {
						this.atLeastOneInternal(9, c)
					}, l.prototype.AT_LEAST_ONE_SEP = function(c) {
						this.atLeastOneSepFirstInternal(0, c)
					}, l.prototype.AT_LEAST_ONE_SEP1 = function(c) {
						this.atLeastOneSepFirstInternal(1, c)
					}, l.prototype.AT_LEAST_ONE_SEP2 = function(c) {
						this.atLeastOneSepFirstInternal(2, c)
					}, l.prototype.AT_LEAST_ONE_SEP3 = function(c) {
						this.atLeastOneSepFirstInternal(3, c)
					}, l.prototype.AT_LEAST_ONE_SEP4 = function(c) {
						this.atLeastOneSepFirstInternal(4, c)
					}, l.prototype.AT_LEAST_ONE_SEP5 = function(c) {
						this.atLeastOneSepFirstInternal(5, c)
					}, l.prototype.AT_LEAST_ONE_SEP6 = function(c) {
						this.atLeastOneSepFirstInternal(6, c)
					}, l.prototype.AT_LEAST_ONE_SEP7 = function(c) {
						this.atLeastOneSepFirstInternal(7, c)
					}, l.prototype.AT_LEAST_ONE_SEP8 = function(c) {
						this.atLeastOneSepFirstInternal(8, c)
					}, l.prototype.AT_LEAST_ONE_SEP9 = function(c) {
						this.atLeastOneSepFirstInternal(9, c)
					}, l.prototype.RULE = function(c, u, h) {
						if (h === void 0 && (h = n.DEFAULT_RULE_CONFIG), e.contains(this.definedRulesNames, c)) {
							var f = i.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
									topLevelRule: c,
									grammarName: this.className
								}),
								m = {
									message: f,
									type: n.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
									ruleName: c
								};
							this.definitionErrors.push(m)
						}
						this.definedRulesNames.push(c);
						var g = this.defineRule(c, u, h);
						return this[c] = g, g
					}, l.prototype.OVERRIDE_RULE = function(c, u, h) {
						h === void 0 && (h = n.DEFAULT_RULE_CONFIG);
						var f = [];
						f = f.concat(s.validateRuleIsOverridden(c, this.definedRulesNames, this.className)), this.definitionErrors = this.definitionErrors.concat(f);
						var m = this.defineRule(c, u, h);
						return this[c] = m, m
					}, l.prototype.BACKTRACK = function(c, u) {
						return function() {
							this.isBackTrackingStack.push(1);
							var h = this.saveRecogState();
							try {
								return c.apply(this, u), !0
							} catch (f) {
								if (t.isRecognitionException(f)) return !1;
								throw f
							} finally {
								this.reloadRecogState(h), this.isBackTrackingStack.pop()
							}
						}
					}, l.prototype.getGAstProductions = function() {
						return this.gastProductionsCache
					}, l.prototype.getSerializedGastProductions = function() {
						return o.serializeGrammar(e.values(this.gastProductionsCache))
					}, l
				}();
			r.RecognizerApi = a
		}),
		Rb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.RecognizerEngine = void 0;
			var e = Ft(),
				t = Pd(),
				n = jl(),
				i = sh(),
				s = rh(),
				o = Ai(),
				a = m0(),
				l = Qs(),
				c = Xl(),
				u = g0(),
				h = function() {
					function f() {}
					return f.prototype.initRecognizerEngine = function(m, g) {
						if (this.className = u.classNameFromInstance(this), this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = c.tokenStructuredMatcherNoCategories, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, e.has(g, "serializedGrammar")) throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
						if (e.isArray(m)) {
							if (e.isEmpty(m)) throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
							if (typeof m[0].startOffset == "number") throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`)
						}
						if (e.isArray(m)) this.tokensMap = e.reduce(m, function(_, v) {
							return _[v.name] = v, _
						}, {});
						else if (e.has(m, "modes") && e.every(e.flatten(e.values(m.modes)), c.isTokenType)) {
							var y = e.flatten(e.values(m.modes)),
								d = e.uniq(y);
							this.tokensMap = e.reduce(d, function(_, v) {
								return _[v.name] = v, _
							}, {})
						} else if (e.isObject(m)) this.tokensMap = e.cloneObj(m);
						else throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
						this.tokensMap.EOF = l.EOF;
						var p = e.every(e.values(m), function(_) {
							return e.isEmpty(_.categoryMatches)
						});
						this.tokenMatcher = p ? c.tokenStructuredMatcherNoCategories : c.tokenStructuredMatcher, c.augmentTokenTypes(e.values(this.tokensMap))
					}, f.prototype.defineRule = function(m, g, y) {
						if (this.selfAnalysisDone) throw Error("Grammar rule <" + m + `> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
						var d = e.has(y, "resyncEnabled") ? y.resyncEnabled : o.DEFAULT_RULE_CONFIG.resyncEnabled,
							p = e.has(y, "recoveryValueFunc") ? y.recoveryValueFunc : o.DEFAULT_RULE_CONFIG.recoveryValueFunc,
							_ = this.ruleShortNameIdx << t.BITS_FOR_METHOD_TYPE + t.BITS_FOR_OCCURRENCE_IDX;
						this.ruleShortNameIdx++, this.shortRuleNameToFull[_] = m, this.fullRuleNameToShort[m] = _;

						function v(I) {
							try {
								if (this.outputCst === !0) {
									g.apply(this, I);
									var w = this.CST_STACK[this.CST_STACK.length - 1];
									return this.cstPostRule(w), w
								} else return g.apply(this, I)
							} catch (L) {
								return this.invokeRuleCatch(L, d, p)
							} finally {
								this.ruleFinallyStateUpdate()
							}
						}
						var x = function(I, w) {
								return I === void 0 && (I = 0), this.ruleInvocationStateUpdate(_, m, I), v.call(this, w)
							},
							M = "ruleName";
						return x[M] = m, x.originalGrammarAction = g, x
					}, f.prototype.invokeRuleCatch = function(m, g, y) {
						var d = this.RULE_STACK.length === 1,
							p = g && !this.isBackTracking() && this.recoveryEnabled;
						if (n.isRecognitionException(m)) {
							var _ = m;
							if (p) {
								var v = this.findReSyncTokenType();
								if (this.isInCurrentRuleReSyncSet(v))
									if (_.resyncedTokens = this.reSyncTo(v), this.outputCst) {
										var x = this.CST_STACK[this.CST_STACK.length - 1];
										return x.recoveredNode = !0, x
									} else return y();
								else {
									if (this.outputCst) {
										var x = this.CST_STACK[this.CST_STACK.length - 1];
										x.recoveredNode = !0, _.partialCstResult = x
									}
									throw _
								}
							} else {
								if (d) return this.moveToTerminatedState(), y();
								throw _
							}
						} else throw m
					}, f.prototype.optionInternal = function(m, g) {
						var y = this.getKeyForAutomaticLookahead(t.OPTION_IDX, g);
						return this.optionInternalLogic(m, g, y)
					}, f.prototype.optionInternalLogic = function(m, g, y) {
						var d = this,
							p = this.getLaFuncFromCache(y),
							_, v;
						if (m.DEF !== void 0) {
							if (_ = m.DEF, v = m.GATE, v !== void 0) {
								var x = p;
								p = function() {
									return v.call(d) && x.call(d)
								}
							}
						} else _ = m;
						if (p.call(this) === !0) return _.call(this)
					}, f.prototype.atLeastOneInternal = function(m, g) {
						var y = this.getKeyForAutomaticLookahead(t.AT_LEAST_ONE_IDX, m);
						return this.atLeastOneInternalLogic(m, g, y)
					}, f.prototype.atLeastOneInternalLogic = function(m, g, y) {
						var d = this,
							p = this.getLaFuncFromCache(y),
							_, v;
						if (g.DEF !== void 0) {
							if (_ = g.DEF, v = g.GATE, v !== void 0) {
								var x = p;
								p = function() {
									return v.call(d) && x.call(d)
								}
							}
						} else _ = g;
						if (p.call(this) === !0)
							for (var M = this.doSingleRepetition(_); p.call(this) === !0 && M === !0;) M = this.doSingleRepetition(_);
						else throw this.raiseEarlyExitException(m, i.PROD_TYPE.REPETITION_MANDATORY, g.ERR_MSG);
						this.attemptInRepetitionRecovery(this.atLeastOneInternal, [m, g], p, t.AT_LEAST_ONE_IDX, m, s.NextTerminalAfterAtLeastOneWalker)
					}, f.prototype.atLeastOneSepFirstInternal = function(m, g) {
						var y = this.getKeyForAutomaticLookahead(t.AT_LEAST_ONE_SEP_IDX, m);
						this.atLeastOneSepFirstInternalLogic(m, g, y)
					}, f.prototype.atLeastOneSepFirstInternalLogic = function(m, g, y) {
						var d = this,
							p = g.DEF,
							_ = g.SEP,
							v = this.getLaFuncFromCache(y);
						if (v.call(this) === !0) {
							p.call(this);
							for (var x = function() {
									return d.tokenMatcher(d.LA(1), _)
								}; this.tokenMatcher(this.LA(1), _) === !0;) this.CONSUME(_), p.call(this);
							this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [m, _, x, p, s.NextTerminalAfterAtLeastOneSepWalker], x, t.AT_LEAST_ONE_SEP_IDX, m, s.NextTerminalAfterAtLeastOneSepWalker)
						} else throw this.raiseEarlyExitException(m, i.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, g.ERR_MSG)
					}, f.prototype.manyInternal = function(m, g) {
						var y = this.getKeyForAutomaticLookahead(t.MANY_IDX, m);
						return this.manyInternalLogic(m, g, y)
					}, f.prototype.manyInternalLogic = function(m, g, y) {
						var d = this,
							p = this.getLaFuncFromCache(y),
							_, v;
						if (g.DEF !== void 0) {
							if (_ = g.DEF, v = g.GATE, v !== void 0) {
								var x = p;
								p = function() {
									return v.call(d) && x.call(d)
								}
							}
						} else _ = g;
						for (var M = !0; p.call(this) === !0 && M === !0;) M = this.doSingleRepetition(_);
						this.attemptInRepetitionRecovery(this.manyInternal, [m, g], p, t.MANY_IDX, m, s.NextTerminalAfterManyWalker, M)
					}, f.prototype.manySepFirstInternal = function(m, g) {
						var y = this.getKeyForAutomaticLookahead(t.MANY_SEP_IDX, m);
						this.manySepFirstInternalLogic(m, g, y)
					}, f.prototype.manySepFirstInternalLogic = function(m, g, y) {
						var d = this,
							p = g.DEF,
							_ = g.SEP,
							v = this.getLaFuncFromCache(y);
						if (v.call(this) === !0) {
							p.call(this);
							for (var x = function() {
									return d.tokenMatcher(d.LA(1), _)
								}; this.tokenMatcher(this.LA(1), _) === !0;) this.CONSUME(_), p.call(this);
							this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [m, _, x, p, s.NextTerminalAfterManySepWalker], x, t.MANY_SEP_IDX, m, s.NextTerminalAfterManySepWalker)
						}
					}, f.prototype.repetitionSepSecondInternal = function(m, g, y, d, p) {
						for (; y();) this.CONSUME(g), d.call(this);
						this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [m, g, y, d, p], y, t.AT_LEAST_ONE_SEP_IDX, m, p)
					}, f.prototype.doSingleRepetition = function(m) {
						var g = this.getLexerPosition();
						m.call(this);
						var y = this.getLexerPosition();
						return y > g
					}, f.prototype.orInternal = function(m, g) {
						var y = this.getKeyForAutomaticLookahead(t.OR_IDX, g),
							d = e.isArray(m) ? m : m.DEF,
							p = this.getLaFuncFromCache(y),
							_ = p.call(this, d);
						if (_ !== void 0) {
							var v = d[_];
							return v.ALT.call(this)
						}
						this.raiseNoAltException(g, m.ERR_MSG)
					}, f.prototype.ruleFinallyStateUpdate = function() {
						if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) {
							var m = this.LA(1),
								g = this.errorMessageProvider.buildNotAllInputParsedMessage({
									firstRedundant: m,
									ruleName: this.getCurrRuleFullName()
								});
							this.SAVE_ERROR(new n.NotAllInputParsedException(g, m))
						}
					}, f.prototype.subruleInternal = function(m, g, y) {
						var d;
						try {
							var p = y !== void 0 ? y.ARGS : void 0;
							return d = m.call(this, g, p), this.cstPostNonTerminal(d, y !== void 0 && y.LABEL !== void 0 ? y.LABEL : m.ruleName), d
						} catch (_) {
							this.subruleInternalError(_, y, m.ruleName)
						}
					}, f.prototype.subruleInternalError = function(m, g, y) {
						throw n.isRecognitionException(m) && m.partialCstResult !== void 0 && (this.cstPostNonTerminal(m.partialCstResult, g !== void 0 && g.LABEL !== void 0 ? g.LABEL : y), delete m.partialCstResult), m
					}, f.prototype.consumeInternal = function(m, g, y) {
						var d;
						try {
							var p = this.LA(1);
							this.tokenMatcher(p, m) === !0 ? (this.consumeToken(), d = p) : this.consumeInternalError(m, p, y)
						} catch (_) {
							d = this.consumeInternalRecovery(m, g, _)
						}
						return this.cstPostTerminal(y !== void 0 && y.LABEL !== void 0 ? y.LABEL : m.name, d), d
					}, f.prototype.consumeInternalError = function(m, g, y) {
						var d, p = this.LA(0);
						throw y !== void 0 && y.ERR_MSG ? d = y.ERR_MSG : d = this.errorMessageProvider.buildMismatchTokenMessage({
							expected: m,
							actual: g,
							previous: p,
							ruleName: this.getCurrRuleFullName()
						}), this.SAVE_ERROR(new n.MismatchedTokenException(d, g, p))
					}, f.prototype.consumeInternalRecovery = function(m, g, y) {
						if (this.recoveryEnabled && y.name === "MismatchedTokenException" && !this.isBackTracking()) {
							var d = this.getFollowsForInRuleRecovery(m, g);
							try {
								return this.tryInRuleRecovery(m, d)
							} catch (p) {
								throw p.name === a.IN_RULE_RECOVERY_EXCEPTION ? y : p
							}
						} else throw y
					}, f.prototype.saveRecogState = function() {
						var m = this.errors,
							g = e.cloneArr(this.RULE_STACK);
						return {
							errors: m,
							lexerState: this.exportLexerState(),
							RULE_STACK: g,
							CST_STACK: this.CST_STACK
						}
					}, f.prototype.reloadRecogState = function(m) {
						this.errors = m.errors, this.importLexerState(m.lexerState), this.RULE_STACK = m.RULE_STACK
					}, f.prototype.ruleInvocationStateUpdate = function(m, g, y) {
						this.RULE_OCCURRENCE_STACK.push(y), this.RULE_STACK.push(m), this.cstInvocationStateUpdate(g, m)
					}, f.prototype.isBackTracking = function() {
						return this.isBackTrackingStack.length !== 0
					}, f.prototype.getCurrRuleFullName = function() {
						var m = this.getLastExplicitRuleShortName();
						return this.shortRuleNameToFull[m]
					}, f.prototype.shortRuleNameToFullName = function(m) {
						return this.shortRuleNameToFull[m]
					}, f.prototype.isAtEndOfInput = function() {
						return this.tokenMatcher(this.LA(1), l.EOF)
					}, f.prototype.reset = function() {
						this.resetLexerState(), this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = []
					}, f
				}();
			r.RecognizerEngine = h
		}),
		Ib = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.ErrorHandler = void 0;
			var e = jl(),
				t = Ft(),
				n = sh(),
				i = Ai(),
				s = function() {
					function o() {}
					return o.prototype.initErrorHandler = function(a) {
						this._errors = [], this.errorMessageProvider = t.has(a, "errorMessageProvider") ? a.errorMessageProvider : i.DEFAULT_PARSER_CONFIG.errorMessageProvider
					}, o.prototype.SAVE_ERROR = function(a) {
						if (e.isRecognitionException(a)) return a.context = {
							ruleStack: this.getHumanReadableRuleStack(),
							ruleOccurrenceStack: t.cloneArr(this.RULE_OCCURRENCE_STACK)
						}, this._errors.push(a), a;
						throw Error("Trying to save an Error which is not a RecognitionException")
					}, Object.defineProperty(o.prototype, "errors", {
						get: function() {
							return t.cloneArr(this._errors)
						},
						set: function(a) {
							this._errors = a
						},
						enumerable: !1,
						configurable: !0
					}), o.prototype.raiseEarlyExitException = function(a, l, c) {
						for (var u = this.getCurrRuleFullName(), h = this.getGAstProductions()[u], f = n.getLookaheadPathsForOptionalProd(a, h, l, this.maxLookahead), m = f[0], g = [], y = 1; y <= this.maxLookahead; y++) g.push(this.LA(y));
						var d = this.errorMessageProvider.buildEarlyExitMessage({
							expectedIterationPaths: m,
							actual: g,
							previous: this.LA(0),
							customUserDescription: c,
							ruleName: u
						});
						throw this.SAVE_ERROR(new e.EarlyExitException(d, this.LA(1), this.LA(0)))
					}, o.prototype.raiseNoAltException = function(a, l) {
						for (var c = this.getCurrRuleFullName(), u = this.getGAstProductions()[c], h = n.getLookaheadPathsForOr(a, u, this.maxLookahead), f = [], m = 1; m <= this.maxLookahead; m++) f.push(this.LA(m));
						var g = this.LA(0),
							y = this.errorMessageProvider.buildNoViableAltMessage({
								expectedPathsPerAlt: h,
								actual: f,
								previous: g,
								customUserDescription: l,
								ruleName: this.getCurrRuleFullName()
							});
						throw this.SAVE_ERROR(new e.NoViableAltException(y, this.LA(1), g))
					}, o
				}();
			r.ErrorHandler = s
		}),
		Pb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.ContentAssist = void 0;
			var e = rh(),
				t = Ft(),
				n = function() {
					function i() {}
					return i.prototype.initContentAssist = function() {}, i.prototype.computeContentAssist = function(s, o) {
						var a = this.gastProductionsCache[s];
						if (t.isUndefined(a)) throw Error("Rule ->" + s + "<- does not exist in this grammar.");
						return e.nextPossibleTokensAfter([a], o, this.tokenMatcher, this.maxLookahead)
					}, i.prototype.getNextPossibleTokenTypes = function(s) {
						var o = t.first(s.ruleStack),
							a = this.getGAstProductions(),
							l = a[o],
							c = new e.NextAfterTokenWalker(l, s).startWalking();
						return c
					}, i
				}();
			r.ContentAssist = n
		}),
		Lb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.GastRecorder = void 0;
			var e = Ft(),
				t = pi(),
				n = th(),
				i = Xl(),
				s = Qs(),
				o = Ai(),
				a = Pd(),
				l = {
					description: "This Object indicates the Parser is during Recording Phase"
				};
			Object.freeze(l);
			var c = !0,
				u = Math.pow(2, a.BITS_FOR_OCCURRENCE_IDX) - 1,
				h = s.createToken({
					name: "RECORDING_PHASE_TOKEN",
					pattern: n.Lexer.NA
				});
			i.augmentTokenTypes([h]);
			var f = s.createTokenInstance(h, `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, -1, -1, -1, -1, -1, -1);
			Object.freeze(f);
			var m = {
					name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
					children: {}
				},
				g = function() {
					function v() {}
					return v.prototype.initGastRecorder = function(x) {
						this.recordingProdStack = [], this.RECORDING_PHASE = !1
					}, v.prototype.enableRecording = function() {
						var x = this;
						this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", function() {
							for (var M = function(w) {
									var L = w > 0 ? w : "";
									x["CONSUME" + L] = function(T, C) {
										return this.consumeInternalRecord(T, w, C)
									}, x["SUBRULE" + L] = function(T, C) {
										return this.subruleInternalRecord(T, w, C)
									}, x["OPTION" + L] = function(T) {
										return this.optionInternalRecord(T, w)
									}, x["OR" + L] = function(T) {
										return this.orInternalRecord(T, w)
									}, x["MANY" + L] = function(T) {
										this.manyInternalRecord(w, T)
									}, x["MANY_SEP" + L] = function(T) {
										this.manySepFirstInternalRecord(w, T)
									}, x["AT_LEAST_ONE" + L] = function(T) {
										this.atLeastOneInternalRecord(w, T)
									}, x["AT_LEAST_ONE_SEP" + L] = function(T) {
										this.atLeastOneSepFirstInternalRecord(w, T)
									}
								}, I = 0; I < 10; I++) M(I);
							x.consume = function(w, L, T) {
								return this.consumeInternalRecord(L, w, T)
							}, x.subrule = function(w, L, T) {
								return this.subruleInternalRecord(L, w, T)
							}, x.option = function(w, L) {
								return this.optionInternalRecord(L, w)
							}, x.or = function(w, L) {
								return this.orInternalRecord(L, w)
							}, x.many = function(w, L) {
								this.manyInternalRecord(w, L)
							}, x.atLeastOne = function(w, L) {
								this.atLeastOneInternalRecord(w, L)
							}, x.ACTION = x.ACTION_RECORD, x.BACKTRACK = x.BACKTRACK_RECORD, x.LA = x.LA_RECORD
						})
					}, v.prototype.disableRecording = function() {
						var x = this;
						this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", function() {
							for (var M = 0; M < 10; M++) {
								var I = M > 0 ? M : "";
								delete x["CONSUME" + I], delete x["SUBRULE" + I], delete x["OPTION" + I], delete x["OR" + I], delete x["MANY" + I], delete x["MANY_SEP" + I], delete x["AT_LEAST_ONE" + I], delete x["AT_LEAST_ONE_SEP" + I]
							}
							delete x.consume, delete x.subrule, delete x.option, delete x.or, delete x.many, delete x.atLeastOne, delete x.ACTION, delete x.BACKTRACK, delete x.LA
						})
					}, v.prototype.ACTION_RECORD = function(x) {}, v.prototype.BACKTRACK_RECORD = function(x, M) {
						return function() {
							return !0
						}
					}, v.prototype.LA_RECORD = function(x) {
						return o.END_OF_FILE
					}, v.prototype.topLevelRuleRecord = function(x, M) {
						try {
							var I = new t.Rule({
								definition: [],
								name: x
							});
							return I.name = x, this.recordingProdStack.push(I), M.call(this), this.recordingProdStack.pop(), I
						} catch (w) {
							if (w.KNOWN_RECORDER_ERROR !== !0) try {
								w.message = w.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`
							} catch {
								throw w
							}
							throw w
						}
					}, v.prototype.optionInternalRecord = function(x, M) {
						return y.call(this, t.Option, x, M)
					}, v.prototype.atLeastOneInternalRecord = function(x, M) {
						y.call(this, t.RepetitionMandatory, M, x)
					}, v.prototype.atLeastOneSepFirstInternalRecord = function(x, M) {
						y.call(this, t.RepetitionMandatoryWithSeparator, M, x, c)
					}, v.prototype.manyInternalRecord = function(x, M) {
						y.call(this, t.Repetition, M, x)
					}, v.prototype.manySepFirstInternalRecord = function(x, M) {
						y.call(this, t.RepetitionWithSeparator, M, x, c)
					}, v.prototype.orInternalRecord = function(x, M) {
						return d.call(this, x, M)
					}, v.prototype.subruleInternalRecord = function(x, M, I) {
						if (_(M), !x || e.has(x, "ruleName") === !1) {
							var w = new Error("<SUBRULE" + p(M) + "> argument is invalid" + (" expecting a Parser method reference but got: <" + JSON.stringify(x) + ">") + (`
 inside top level rule: <` + this.recordingProdStack[0].name + ">"));
							throw w.KNOWN_RECORDER_ERROR = !0, w
						}
						var L = e.peek(this.recordingProdStack),
							T = x.ruleName,
							C = new t.NonTerminal({
								idx: M,
								nonTerminalName: T,
								referencedRule: void 0
							});
						return L.definition.push(C), this.outputCst ? m : l
					}, v.prototype.consumeInternalRecord = function(x, M, I) {
						if (_(M), !i.hasShortKeyProperty(x)) {
							var w = new Error("<CONSUME" + p(M) + "> argument is invalid" + (" expecting a TokenType reference but got: <" + JSON.stringify(x) + ">") + (`
 inside top level rule: <` + this.recordingProdStack[0].name + ">"));
							throw w.KNOWN_RECORDER_ERROR = !0, w
						}
						var L = e.peek(this.recordingProdStack),
							T = new t.Terminal({
								idx: M,
								terminalType: x
							});
						return L.definition.push(T), f
					}, v
				}();
			r.GastRecorder = g;

			function y(v, x, M, I) {
				I === void 0 && (I = !1), _(M);
				var w = e.peek(this.recordingProdStack),
					L = e.isFunction(x) ? x : x.DEF,
					T = new v({
						definition: [],
						idx: M
					});
				return I && (T.separator = x.SEP), e.has(x, "MAX_LOOKAHEAD") && (T.maxLookahead = x.MAX_LOOKAHEAD), this.recordingProdStack.push(T), L.call(this), w.definition.push(T), this.recordingProdStack.pop(), l
			}

			function d(v, x) {
				var M = this;
				_(x);
				var I = e.peek(this.recordingProdStack),
					w = e.isArray(v) === !1,
					L = w === !1 ? v : v.DEF,
					T = new t.Alternation({
						definition: [],
						idx: x,
						ignoreAmbiguities: w && v.IGNORE_AMBIGUITIES === !0
					});
				e.has(v, "MAX_LOOKAHEAD") && (T.maxLookahead = v.MAX_LOOKAHEAD);
				var C = e.some(L, function(V) {
					return e.isFunction(V.GATE)
				});
				return T.hasPredicates = C, I.definition.push(T), e.forEach(L, function(V) {
					var k = new t.Alternative({
						definition: []
					});
					T.definition.push(k), e.has(V, "IGNORE_AMBIGUITIES") ? k.ignoreAmbiguities = V.IGNORE_AMBIGUITIES : e.has(V, "GATE") && (k.ignoreAmbiguities = !0), M.recordingProdStack.push(k), V.ALT.call(M), M.recordingProdStack.pop()
				}), l
			}

			function p(v) {
				return v === 0 ? "" : "" + v
			}

			function _(v) {
				if (v < 0 || v > u) {
					var x = new Error("Invalid DSL Method idx value: <" + v + `>
	` + ("Idx value must be a none negative value smaller than " + (u + 1)));
					throw x.KNOWN_RECORDER_ERROR = !0, x
				}
			}
		}),
		Nb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.PerformanceTracer = void 0;
			var e = Ft(),
				t = Ai(),
				n = function() {
					function i() {}
					return i.prototype.initPerformanceTracer = function(s) {
						if (e.has(s, "traceInitPerf")) {
							var o = s.traceInitPerf,
								a = typeof o == "number";
							this.traceInitMaxIdent = a ? o : 1 / 0, this.traceInitPerf = a ? o > 0 : o
						} else this.traceInitMaxIdent = 0, this.traceInitPerf = t.DEFAULT_PARSER_CONFIG.traceInitPerf;
						this.traceInitIndent = -1
					}, i.prototype.TRACE_INIT = function(s, o) {
						if (this.traceInitPerf === !0) {
							this.traceInitIndent++;
							var a = new Array(this.traceInitIndent + 1).join("	");
							this.traceInitIndent < this.traceInitMaxIdent && console.log(a + "--> <" + s + ">");
							var l = e.timer(o),
								c = l.time,
								u = l.value,
								h = c > 10 ? console.warn : console.log;
							return this.traceInitIndent < this.traceInitMaxIdent && h(a + "<-- <" + s + "> time: " + c + "ms"), this.traceInitIndent--, u
						} else return o()
					}, i
				}();
			r.PerformanceTracer = n
		}),
		Ob = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.applyMixins = void 0;

			function e(t, n) {
				n.forEach(function(i) {
					var s = i.prototype;
					Object.getOwnPropertyNames(s).forEach(function(o) {
						if (o !== "constructor") {
							var a = Object.getOwnPropertyDescriptor(s, o);
							a && (a.get || a.set) ? Object.defineProperty(t.prototype, o, a) : t.prototype[o] = i.prototype[o]
						}
					})
				})
			}
			r.applyMixins = e
		}),
		Ai = _t(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var w = function(L, T) {
					return w = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(C, V) {
						C.__proto__ = V
					} || function(C, V) {
						for (var k in V) Object.prototype.hasOwnProperty.call(V, k) && (C[k] = V[k])
					}, w(L, T)
				};
				return function(L, T) {
					if (typeof T != "function" && T !== null) throw new TypeError("Class extends value " + String(T) + " is not a constructor or null");
					w(L, T);

					function C() {
						this.constructor = L
					}
					L.prototype = T === null ? Object.create(T) : (C.prototype = T.prototype, new C)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.EmbeddedActionsParser = r.CstParser = r.Parser = r.EMPTY_ALT = r.ParserDefinitionErrorType = r.DEFAULT_RULE_CONFIG = r.DEFAULT_PARSER_CONFIG = r.END_OF_FILE = void 0;
			var t = Ft(),
				n = _b(),
				i = Qs(),
				s = ih(),
				o = Eb(),
				a = m0(),
				l = Mb(),
				c = Ab(),
				u = wb(),
				h = Cb(),
				f = Rb(),
				m = Ib(),
				g = Pb(),
				y = Lb(),
				d = Nb(),
				p = Ob();
			r.END_OF_FILE = i.createTokenInstance(i.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN), Object.freeze(r.END_OF_FILE), r.DEFAULT_PARSER_CONFIG = Object.freeze({
				recoveryEnabled: !1,
				maxLookahead: 3,
				dynamicTokensEnabled: !1,
				outputCst: !0,
				errorMessageProvider: s.defaultParserErrorProvider,
				nodeLocationTracking: "none",
				traceInitPerf: !1,
				skipValidations: !1
			}), r.DEFAULT_RULE_CONFIG = Object.freeze({
				recoveryValueFunc: function() {},
				resyncEnabled: !0
			});
			var _;
			(function(w) {
				w[w.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", w[w.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", w[w.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", w[w.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", w[w.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", w[w.LEFT_RECURSION = 5] = "LEFT_RECURSION", w[w.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", w[w.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", w[w.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", w[w.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", w[w.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", w[w.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", w[w.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS"
			})(_ = r.ParserDefinitionErrorType || (r.ParserDefinitionErrorType = {}));

			function v(w) {
				return w === void 0 && (w = void 0),
					function() {
						return w
					}
			}
			r.EMPTY_ALT = v;
			var x = function() {
				function w(L, T) {
					this.definitionErrors = [], this.selfAnalysisDone = !1;
					var C = this;
					if (C.initErrorHandler(T), C.initLexerAdapter(), C.initLooksAhead(T), C.initRecognizerEngine(L, T), C.initRecoverable(T), C.initTreeBuilder(T), C.initContentAssist(), C.initGastRecorder(T), C.initPerformanceTracer(T), t.has(T, "ignoredIssues")) throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
					this.skipValidations = t.has(T, "skipValidations") ? T.skipValidations : r.DEFAULT_PARSER_CONFIG.skipValidations
				}
				return w.performSelfAnalysis = function(L) {
					throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.")
				}, w.prototype.performSelfAnalysis = function() {
					var L = this;
					this.TRACE_INIT("performSelfAnalysis", function() {
						var T;
						L.selfAnalysisDone = !0;
						var C = L.className;
						L.TRACE_INIT("toFastProps", function() {
							t.toFastProperties(L)
						}), L.TRACE_INIT("Grammar Recording", function() {
							try {
								L.enableRecording(), t.forEach(L.definedRulesNames, function(k) {
									var F = L[k],
										U = F.originalGrammarAction,
										K = void 0;
									L.TRACE_INIT(k + " Rule", function() {
										K = L.topLevelRuleRecord(k, U)
									}), L.gastProductionsCache[k] = K
								})
							} finally {
								L.disableRecording()
							}
						});
						var V = [];
						if (L.TRACE_INIT("Grammar Resolving", function() {
								V = o.resolveGrammar({
									rules: t.values(L.gastProductionsCache)
								}), L.definitionErrors = L.definitionErrors.concat(V)
							}), L.TRACE_INIT("Grammar Validations", function() {
								if (t.isEmpty(V) && L.skipValidations === !1) {
									var k = o.validateGrammar({
										rules: t.values(L.gastProductionsCache),
										maxLookahead: L.maxLookahead,
										tokenTypes: t.values(L.tokensMap),
										errMsgProvider: s.defaultGrammarValidatorErrorProvider,
										grammarName: C
									});
									L.definitionErrors = L.definitionErrors.concat(k)
								}
							}), t.isEmpty(L.definitionErrors) && (L.recoveryEnabled && L.TRACE_INIT("computeAllProdsFollows", function() {
								var k = n.computeAllProdsFollows(t.values(L.gastProductionsCache));
								L.resyncFollows = k
							}), L.TRACE_INIT("ComputeLookaheadFunctions", function() {
								L.preComputeLookaheadFunctions(t.values(L.gastProductionsCache))
							})), !w.DEFER_DEFINITION_ERRORS_HANDLING && !t.isEmpty(L.definitionErrors)) throw T = t.map(L.definitionErrors, function(k) {
							return k.message
						}), new Error(`Parser Definition Errors detected:
 ` + T.join(`
-------------------------------
`))
					})
				}, w.DEFER_DEFINITION_ERRORS_HANDLING = !1, w
			}();
			r.Parser = x, p.applyMixins(x, [a.Recoverable, l.LooksAhead, c.TreeBuilder, u.LexerAdapter, f.RecognizerEngine, h.RecognizerApi, m.ErrorHandler, g.ContentAssist, y.GastRecorder, d.PerformanceTracer]);
			var M = function(w) {
				e(L, w);

				function L(T, C) {
					C === void 0 && (C = r.DEFAULT_PARSER_CONFIG);
					var V = this,
						k = t.cloneObj(C);
					return k.outputCst = !0, V = w.call(this, T, k) || this, V
				}
				return L
			}(x);
			r.CstParser = M;
			var I = function(w) {
				e(L, w);

				function L(T, C) {
					C === void 0 && (C = r.DEFAULT_PARSER_CONFIG);
					var V = this,
						k = t.cloneObj(C);
					return k.outputCst = !1, V = w.call(this, T, k) || this, V
				}
				return L
			}(x);
			r.EmbeddedActionsParser = I
		}),
		Db = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.createSyntaxDiagramsCode = void 0;
			var e = c0();

			function t(n, i) {
				var s = i === void 0 ? {} : i,
					o = s.resourceBase,
					a = o === void 0 ? "https://unpkg.com/chevrotain@" + e.VERSION + "/diagrams/" : o,
					l = s.css,
					c = l === void 0 ? "https://unpkg.com/chevrotain@" + e.VERSION + "/diagrams/diagrams.css" : l,
					u = `
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>

`,
					h = `
<link rel='stylesheet' href='` + c + `'>
`,
					f = `
<script src='` + a + `vendor/railroad-diagrams.js'><\/script>
<script src='` + a + `src/diagrams_builder.js'><\/script>
<script src='` + a + `src/diagrams_behavior.js'><\/script>
<script src='` + a + `src/main.js'><\/script>
`,
					m = `
<div id="diagrams" align="center"></div>
`,
					g = `
<script>
    window.serializedGrammar = ` + JSON.stringify(n, null, "  ") + `;
<\/script>
`,
					y = `
<script>
    var diagramsDiv = document.getElementById("diagrams");
    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);
<\/script>
`;
				return u + h + f + m + g + y
			}
			r.createSyntaxDiagramsCode = t
		}),
		Fb = _t(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.Parser = r.createSyntaxDiagramsCode = r.clearCache = r.GAstVisitor = r.serializeProduction = r.serializeGrammar = r.Terminal = r.Rule = r.RepetitionWithSeparator = r.RepetitionMandatoryWithSeparator = r.RepetitionMandatory = r.Repetition = r.Option = r.NonTerminal = r.Alternative = r.Alternation = r.defaultLexerErrorProvider = r.NoViableAltException = r.NotAllInputParsedException = r.MismatchedTokenException = r.isRecognitionException = r.EarlyExitException = r.defaultParserErrorProvider = r.tokenName = r.tokenMatcher = r.tokenLabel = r.EOF = r.createTokenInstance = r.createToken = r.LexerDefinitionErrorType = r.Lexer = r.EMPTY_ALT = r.ParserDefinitionErrorType = r.EmbeddedActionsParser = r.CstParser = r.VERSION = void 0;
			var e = c0();
			Object.defineProperty(r, "VERSION", {
				enumerable: !0,
				get: function() {
					return e.VERSION
				}
			});
			var t = Ai();
			Object.defineProperty(r, "CstParser", {
				enumerable: !0,
				get: function() {
					return t.CstParser
				}
			}), Object.defineProperty(r, "EmbeddedActionsParser", {
				enumerable: !0,
				get: function() {
					return t.EmbeddedActionsParser
				}
			}), Object.defineProperty(r, "ParserDefinitionErrorType", {
				enumerable: !0,
				get: function() {
					return t.ParserDefinitionErrorType
				}
			}), Object.defineProperty(r, "EMPTY_ALT", {
				enumerable: !0,
				get: function() {
					return t.EMPTY_ALT
				}
			});
			var n = th();
			Object.defineProperty(r, "Lexer", {
				enumerable: !0,
				get: function() {
					return n.Lexer
				}
			}), Object.defineProperty(r, "LexerDefinitionErrorType", {
				enumerable: !0,
				get: function() {
					return n.LexerDefinitionErrorType
				}
			});
			var i = Qs();
			Object.defineProperty(r, "createToken", {
				enumerable: !0,
				get: function() {
					return i.createToken
				}
			}), Object.defineProperty(r, "createTokenInstance", {
				enumerable: !0,
				get: function() {
					return i.createTokenInstance
				}
			}), Object.defineProperty(r, "EOF", {
				enumerable: !0,
				get: function() {
					return i.EOF
				}
			}), Object.defineProperty(r, "tokenLabel", {
				enumerable: !0,
				get: function() {
					return i.tokenLabel
				}
			}), Object.defineProperty(r, "tokenMatcher", {
				enumerable: !0,
				get: function() {
					return i.tokenMatcher
				}
			}), Object.defineProperty(r, "tokenName", {
				enumerable: !0,
				get: function() {
					return i.tokenName
				}
			});
			var s = ih();
			Object.defineProperty(r, "defaultParserErrorProvider", {
				enumerable: !0,
				get: function() {
					return s.defaultParserErrorProvider
				}
			});
			var o = jl();
			Object.defineProperty(r, "EarlyExitException", {
				enumerable: !0,
				get: function() {
					return o.EarlyExitException
				}
			}), Object.defineProperty(r, "isRecognitionException", {
				enumerable: !0,
				get: function() {
					return o.isRecognitionException
				}
			}), Object.defineProperty(r, "MismatchedTokenException", {
				enumerable: !0,
				get: function() {
					return o.MismatchedTokenException
				}
			}), Object.defineProperty(r, "NotAllInputParsedException", {
				enumerable: !0,
				get: function() {
					return o.NotAllInputParsedException
				}
			}), Object.defineProperty(r, "NoViableAltException", {
				enumerable: !0,
				get: function() {
					return o.NoViableAltException
				}
			});
			var a = h0();
			Object.defineProperty(r, "defaultLexerErrorProvider", {
				enumerable: !0,
				get: function() {
					return a.defaultLexerErrorProvider
				}
			});
			var l = pi();
			Object.defineProperty(r, "Alternation", {
				enumerable: !0,
				get: function() {
					return l.Alternation
				}
			}), Object.defineProperty(r, "Alternative", {
				enumerable: !0,
				get: function() {
					return l.Alternative
				}
			}), Object.defineProperty(r, "NonTerminal", {
				enumerable: !0,
				get: function() {
					return l.NonTerminal
				}
			}), Object.defineProperty(r, "Option", {
				enumerable: !0,
				get: function() {
					return l.Option
				}
			}), Object.defineProperty(r, "Repetition", {
				enumerable: !0,
				get: function() {
					return l.Repetition
				}
			}), Object.defineProperty(r, "RepetitionMandatory", {
				enumerable: !0,
				get: function() {
					return l.RepetitionMandatory
				}
			}), Object.defineProperty(r, "RepetitionMandatoryWithSeparator", {
				enumerable: !0,
				get: function() {
					return l.RepetitionMandatoryWithSeparator
				}
			}), Object.defineProperty(r, "RepetitionWithSeparator", {
				enumerable: !0,
				get: function() {
					return l.RepetitionWithSeparator
				}
			}), Object.defineProperty(r, "Rule", {
				enumerable: !0,
				get: function() {
					return l.Rule
				}
			}), Object.defineProperty(r, "Terminal", {
				enumerable: !0,
				get: function() {
					return l.Terminal
				}
			});
			var c = pi();
			Object.defineProperty(r, "serializeGrammar", {
				enumerable: !0,
				get: function() {
					return c.serializeGrammar
				}
			}), Object.defineProperty(r, "serializeProduction", {
				enumerable: !0,
				get: function() {
					return c.serializeProduction
				}
			});
			var u = ql();
			Object.defineProperty(r, "GAstVisitor", {
				enumerable: !0,
				get: function() {
					return u.GAstVisitor
				}
			});

			function h() {
				console.warn(`The clearCache function was 'soft' removed from the Chevrotain API.
	 It performs no action other than printing this message.
	 Please avoid using it as it will be completely removed in the future`)
			}
			r.clearCache = h;
			var f = Db();
			Object.defineProperty(r, "createSyntaxDiagramsCode", {
				enumerable: !0,
				get: function() {
					return f.createSyntaxDiagramsCode
				}
			});
			var m = function() {
				function g() {
					throw new Error(`The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.
See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0`)
				}
				return g
			}();
			r.Parser = m
		}),
		Ia = Fb();
	var oh = class extends Ot {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = this,
					o = s.path === "" ? ds.extractUrlBase(e) : s.path,
					a = new jn(s.manager);
				a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
					try {
						t(s.parse(l, o))
					} catch (c) {
						i ? i(c) : console.error(c), s.manager.itemError(e)
					}
				}, n, i)
			}
			parse(e, t) {
				let n = {};

				function i(R) {
					let E = s(),
						B = new Ld(E.tokens),
						ne = new Nd(E.tokenVocabulary),
						X = o(ne.getBaseCstVisitorConstructor()),
						ae = B.lex(R);
					ne.input = ae.tokens;
					let ge = ne.vrml();
					if (ne.errors.length > 0) throw console.error(ne.errors), Error("THREE.VRMLLoader: Parsing errors detected.");
					return X.visit(ge)
				}

				function s() {
					let R = Ia.createToken,
						E = R({
							name: "RouteIdentifier",
							pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*[\.][^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/
						}),
						B = R({
							name: "Identifier",
							pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/,
							longer_alt: E
						}),
						ne = ["Anchor", "Billboard", "Collision", "Group", "Transform", "Inline", "LOD", "Switch", "AudioClip", "DirectionalLight", "PointLight", "Script", "Shape", "Sound", "SpotLight", "WorldInfo", "CylinderSensor", "PlaneSensor", "ProximitySensor", "SphereSensor", "TimeSensor", "TouchSensor", "VisibilitySensor", "Box", "Cone", "Cylinder", "ElevationGrid", "Extrusion", "IndexedFaceSet", "IndexedLineSet", "PointSet", "Sphere", "Color", "Coordinate", "Normal", "TextureCoordinate", "Appearance", "FontStyle", "ImageTexture", "Material", "MovieTexture", "PixelTexture", "TextureTransform", "ColorInterpolator", "CoordinateInterpolator", "NormalInterpolator", "OrientationInterpolator", "PositionInterpolator", "ScalarInterpolator", "Background", "Fog", "NavigationInfo", "Viewpoint", "Text"],
						X = R({
							name: "Version",
							pattern: /#VRML.*/,
							longer_alt: B
						}),
						ae = R({
							name: "NodeName",
							pattern: new RegExp(ne.join("|")),
							longer_alt: B
						}),
						ge = R({
							name: "DEF",
							pattern: /DEF/,
							longer_alt: B
						}),
						ue = R({
							name: "USE",
							pattern: /USE/,
							longer_alt: B
						}),
						se = R({
							name: "ROUTE",
							pattern: /ROUTE/,
							longer_alt: B
						}),
						_e = R({
							name: "TO",
							pattern: /TO/,
							longer_alt: B
						}),
						Se = R({
							name: "StringLiteral",
							pattern: /"(?:[^\\"\n\r]|\\[bfnrtv"\\/]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*"/
						}),
						Ne = R({
							name: "HexLiteral",
							pattern: /0[xX][0-9a-fA-F]+/
						}),
						Fe = R({
							name: "NumberLiteral",
							pattern: /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/
						}),
						ke = R({
							name: "TrueLiteral",
							pattern: /TRUE/
						}),
						je = R({
							name: "FalseLiteral",
							pattern: /FALSE/
						}),
						We = R({
							name: "NullLiteral",
							pattern: /NULL/
						}),
						ce = R({
							name: "LSquare",
							pattern: /\[/
						}),
						Le = R({
							name: "RSquare",
							pattern: /]/
						}),
						ve = R({
							name: "LCurly",
							pattern: /{/
						}),
						Ie = R({
							name: "RCurly",
							pattern: /}/
						}),
						De = R({
							name: "Comment",
							pattern: /#.*/,
							group: Ia.Lexer.SKIPPED
						}),
						vt = [R({
							name: "WhiteSpace",
							pattern: /[ ,\s]/,
							group: Ia.Lexer.SKIPPED
						}), ae, ge, ue, se, _e, ke, je, We, X, B, E, Se, Ne, Fe, ce, Le, ve, Ie, De],
						Mt = {};
					for (let ft = 0, Ue = vt.length; ft < Ue; ft++) {
						let Ye = vt[ft];
						Mt[Ye.name] = Ye
					}
					return {
						tokens: vt,
						tokenVocabulary: Mt
					}
				}

				function o(R) {
					class E extends R {
						constructor() {
							super(), this.validateVisitor()
						}
						vrml(X) {
							let ae = {
								version: this.visit(X.version),
								nodes: [],
								routes: []
							};
							for (let ge = 0, ue = X.node.length; ge < ue; ge++) {
								let se = X.node[ge];
								ae.nodes.push(this.visit(se))
							}
							if (X.route)
								for (let ge = 0, ue = X.route.length; ge < ue; ge++) {
									let se = X.route[ge];
									ae.routes.push(this.visit(se))
								}
							return ae
						}
						version(X) {
							return X.Version[0].image
						}
						node(X) {
							let ae = {
								name: X.NodeName[0].image,
								fields: []
							};
							if (X.field)
								for (let ge = 0, ue = X.field.length; ge < ue; ge++) {
									let se = X.field[ge];
									ae.fields.push(this.visit(se))
								}
							return X.def && (ae.DEF = this.visit(X.def[0])), ae
						}
						field(X) {
							let ae = {
									name: X.Identifier[0].image,
									type: null,
									values: null
								},
								ge;
							return X.singleFieldValue && (ge = this.visit(X.singleFieldValue[0])), X.multiFieldValue && (ge = this.visit(X.multiFieldValue[0])), ae.type = ge.type, ae.values = ge.values, ae
						}
						def(X) {
							return (X.Identifier || X.NodeName)[0].image
						}
						use(X) {
							return {
								USE: (X.Identifier || X.NodeName)[0].image
							}
						}
						singleFieldValue(X) {
							return B(this, X)
						}
						multiFieldValue(X) {
							return B(this, X)
						}
						route(X) {
							return {
								FROM: X.RouteIdentifier[0].image,
								TO: X.RouteIdentifier[1].image
							}
						}
					}

					function B(ne, X) {
						let ae = {
							type: null,
							values: []
						};
						if (X.node) {
							ae.type = "node";
							for (let ge = 0, ue = X.node.length; ge < ue; ge++) {
								let se = X.node[ge];
								ae.values.push(ne.visit(se))
							}
						}
						if (X.use) {
							ae.type = "use";
							for (let ge = 0, ue = X.use.length; ge < ue; ge++) {
								let se = X.use[ge];
								ae.values.push(ne.visit(se))
							}
						}
						if (X.StringLiteral) {
							ae.type = "string";
							for (let ge = 0, ue = X.StringLiteral.length; ge < ue; ge++) {
								let se = X.StringLiteral[ge];
								ae.values.push(se.image.replace(/'|"/g, ""))
							}
						}
						if (X.NumberLiteral) {
							ae.type = "number";
							for (let ge = 0, ue = X.NumberLiteral.length; ge < ue; ge++) {
								let se = X.NumberLiteral[ge];
								ae.values.push(parseFloat(se.image))
							}
						}
						if (X.HexLiteral) {
							ae.type = "hex";
							for (let ge = 0, ue = X.HexLiteral.length; ge < ue; ge++) {
								let se = X.HexLiteral[ge];
								ae.values.push(se.image)
							}
						}
						if (X.TrueLiteral) {
							ae.type = "boolean";
							for (let ge = 0, ue = X.TrueLiteral.length; ge < ue; ge++) X.TrueLiteral[ge].image === "TRUE" && ae.values.push(!0)
						}
						if (X.FalseLiteral) {
							ae.type = "boolean";
							for (let ge = 0, ue = X.FalseLiteral.length; ge < ue; ge++) X.FalseLiteral[ge].image === "FALSE" && ae.values.push(!1)
						}
						return X.NullLiteral && (ae.type = "null", X.NullLiteral.forEach(function() {
							ae.values.push(null)
						})), ae
					}
					return new E
				}

				function a(R) {
					let E = R.nodes,
						B = new ur;
					for (let ne = 0, X = E.length; ne < X; ne++) {
						let ae = E[ne];
						l(ae)
					}
					for (let ne = 0, X = E.length; ne < X; ne++) {
						let ae = E[ne],
							ge = c(ae);
						ge instanceof Rt && B.add(ge), ae.name === "WorldInfo" && (B.userData.worldInfo = ge)
					}
					return B
				}

				function l(R) {
					R.DEF && (n[R.DEF] = R);
					let E = R.fields;
					for (let B = 0, ne = E.length; B < ne; B++) {
						let X = E[B];
						if (X.type === "node") {
							let ae = X.values;
							for (let ge = 0, ue = ae.length; ge < ue; ge++) l(ae[ge])
						}
					}
				}

				function c(R) {
					return R.USE ? Z(R.USE) : (R.build !== void 0 || (R.build = u(R)), R.build)
				}

				function u(R) {
					let E = R.name,
						B;
					switch (E) {
						case "Anchor":
						case "Group":
						case "Transform":
						case "Collision":
							B = h(R);
							break;
						case "Background":
							B = f(R);
							break;
						case "Shape":
							B = m(R);
							break;
						case "Appearance":
							B = g(R);
							break;
						case "Material":
							B = y(R);
							break;
						case "ImageTexture":
							B = v(R);
							break;
						case "PixelTexture":
							B = _(R);
							break;
						case "TextureTransform":
							B = x(R);
							break;
						case "IndexedFaceSet":
							B = w(R);
							break;
						case "IndexedLineSet":
							B = L(R);
							break;
						case "PointSet":
							B = T(R);
							break;
						case "Box":
							B = C(R);
							break;
						case "Cone":
							B = V(R);
							break;
						case "Cylinder":
							B = k(R);
							break;
						case "Sphere":
							B = F(R);
							break;
						case "ElevationGrid":
							B = U(R);
							break;
						case "Extrusion":
							B = K(R);
							break;
						case "Color":
						case "Coordinate":
						case "Normal":
						case "TextureCoordinate":
							B = M(R);
							break;
						case "WorldInfo":
							B = I(R);
							break;
						case "Billboard":
						case "Inline":
						case "LOD":
						case "Switch":
						case "AudioClip":
						case "DirectionalLight":
						case "PointLight":
						case "Script":
						case "Sound":
						case "SpotLight":
						case "CylinderSensor":
						case "PlaneSensor":
						case "ProximitySensor":
						case "SphereSensor":
						case "TimeSensor":
						case "TouchSensor":
						case "VisibilitySensor":
						case "Text":
						case "FontStyle":
						case "MovieTexture":
						case "ColorInterpolator":
						case "CoordinateInterpolator":
						case "NormalInterpolator":
						case "OrientationInterpolator":
						case "PositionInterpolator":
						case "ScalarInterpolator":
						case "Fog":
						case "NavigationInfo":
						case "Viewpoint":
							break;
						default:
							console.warn("THREE.VRMLLoader: Unknown node:", E);
							break
					}
					return B !== void 0 && R.DEF !== void 0 && B.hasOwnProperty("name") === !0 && (B.name = R.DEF), B
				}

				function h(R) {
					let E = new cn,
						B = R.fields;
					for (let ne = 0, X = B.length; ne < X; ne++) {
						let ae = B[ne],
							ge = ae.name,
							ue = ae.values;
						switch (ge) {
							case "bboxCenter":
								break;
							case "bboxSize":
								break;
							case "center":
								break;
							case "children":
								Y(ue, E);
								break;
							case "description":
								break;
							case "collide":
								break;
							case "parameter":
								break;
							case "rotation":
								let se = new re(ue[0], ue[1], ue[2]),
									_e = ue[3];
								E.quaternion.setFromAxisAngle(se, _e);
								break;
							case "scale":
								E.scale.set(ue[0], ue[1], ue[2]);
								break;
							case "scaleOrientation":
								break;
							case "translation":
								E.position.set(ue[0], ue[1], ue[2]);
								break;
							case "proxy":
								break;
							case "url":
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ge);
								break
						}
					}
					return E
				}

				function f(R) {
					let E = new cn,
						B, ne, X, ae, ge = R.fields;
					for (let se = 0, _e = ge.length; se < _e; se++) {
						let Se = ge[se],
							Ne = Se.name,
							Fe = Se.values;
						switch (Ne) {
							case "groundAngle":
								B = Fe;
								break;
							case "groundColor":
								ne = Fe;
								break;
							case "backUrl":
								break;
							case "bottomUrl":
								break;
							case "frontUrl":
								break;
							case "leftUrl":
								break;
							case "rightUrl":
								break;
							case "topUrl":
								break;
							case "skyAngle":
								X = Fe;
								break;
							case "skyColor":
								ae = Fe;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", Ne);
								break
						}
					}
					let ue = 1e4;
					if (ae) {
						let se = new ha(ue, 32, 16),
							_e = new Ti({
								fog: !1,
								side: gn,
								depthWrite: !1,
								depthTest: !1
							});
						ae.length > 3 ? (q(se, ue, X, Ee(ae), !0), _e.vertexColors = !0) : (_e.color.setRGB(ae[0], ae[1], ae[2]), _e.color.convertSRGBToLinear());
						let Se = new Nt(se, _e);
						E.add(Se)
					}
					if (ne && ne.length > 0) {
						let se = new ha(ue, 32, 16, 0, 2 * Math.PI, .5 * Math.PI, 1.5 * Math.PI),
							_e = new Ti({
								fog: !1,
								side: gn,
								vertexColors: !0,
								depthWrite: !1,
								depthTest: !1
							});
						q(se, ue, B, Ee(ne), !1);
						let Se = new Nt(se, _e);
						E.add(Se)
					}
					return E.renderOrder = -1 / 0, E
				}

				function m(R) {
					let E = R.fields,
						B = new Ti({
							name: Ot.DEFAULT_MATERIAL_NAME,
							color: 0
						}),
						ne;
					for (let ae = 0, ge = E.length; ae < ge; ae++) {
						let ue = E[ae],
							se = ue.name,
							_e = ue.values;
						switch (se) {
							case "appearance":
								_e[0] !== null && (B = c(_e[0]));
								break;
							case "geometry":
								_e[0] !== null && (ne = c(_e[0]));
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", se);
								break
						}
					}
					let X;
					if (ne && ne.attributes.position) {
						let ae = ne._type;
						if (ae === "points") {
							let ge = new Ll({
								name: Ot.DEFAULT_MATERIAL_NAME,
								color: 16777215
							});
							ne.attributes.color !== void 0 ? ge.vertexColors = !0 : B.isMeshPhongMaterial && ge.color.copy(B.emissive), X = new bu(ne, ge)
						} else if (ae === "line") {
							let ge = new Ei({
								name: Ot.DEFAULT_MATERIAL_NAME,
								color: 16777215
							});
							ne.attributes.color !== void 0 ? ge.vertexColors = !0 : B.isMeshPhongMaterial && ge.color.copy(B.emissive), X = new ls(ne, ge)
						} else ne._solid !== void 0 && (B.side = ne._solid ? _i : wn), ne.attributes.color !== void 0 && (B.vertexColors = !0), X = new Nt(ne, B)
					} else X = new Rt, X.visible = !1;
					return X
				}

				function g(R) {
					let E = new Xt,
						B, ne = R.fields;
					for (let X = 0, ae = ne.length; X < ae; X++) {
						let ge = ne[X],
							ue = ge.name,
							se = ge.values;
						switch (ue) {
							case "material":
								if (se[0] !== null) {
									let Se = c(se[0]);
									Se.diffuseColor && E.color.copy(Se.diffuseColor), Se.emissiveColor && E.emissive.copy(Se.emissiveColor), Se.shininess && (E.shininess = Se.shininess), Se.specularColor && E.specular.copy(Se.specularColor), Se.transparency && (E.opacity = 1 - Se.transparency), Se.transparency > 0 && (E.transparent = !0)
								} else E = new Ti({
									name: Ot.DEFAULT_MATERIAL_NAME,
									color: 0
								});
								break;
							case "texture":
								let _e = se[0];
								_e !== null && (_e.name === "ImageTexture" || _e.name === "PixelTexture") && (E.map = c(_e));
								break;
							case "textureTransform":
								se[0] !== null && (B = c(se[0]));
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ue);
								break
						}
					}
					if (E.map) {
						if (E.map.__type) {
							switch (E.map.__type) {
								case Ki.INTENSITY_ALPHA:
									E.opacity = 1;
									break;
								case Ki.RGB:
									E.color.set(16777215);
									break;
								case Ki.RGBA:
									E.color.set(16777215), E.opacity = 1;
									break;
								default:
							}
							delete E.map.__type
						}
						B && (E.map.center.copy(B.center), E.map.rotation = B.rotation, E.map.repeat.copy(B.scale), E.map.offset.copy(B.translation))
					}
					return E
				}

				function y(R) {
					let E = {},
						B = R.fields;
					for (let ne = 0, X = B.length; ne < X; ne++) {
						let ae = B[ne],
							ge = ae.name,
							ue = ae.values;
						switch (ge) {
							case "ambientIntensity":
								break;
							case "diffuseColor":
								E.diffuseColor = new qe(ue[0], ue[1], ue[2]), E.diffuseColor.convertSRGBToLinear();
								break;
							case "emissiveColor":
								E.emissiveColor = new qe(ue[0], ue[1], ue[2]), E.emissiveColor.convertSRGBToLinear();
								break;
							case "shininess":
								E.shininess = ue[0];
								break;
							case "specularColor":
								E.specularColor = new qe(ue[0], ue[1], ue[2]), E.specularColor.convertSRGBToLinear();
								break;
							case "transparency":
								E.transparency = ue[0];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ge);
								break
						}
					}
					return E
				}

				function d(R, E, B) {
					let ne;
					switch (E) {
						case Ki.INTENSITY:
							ne = parseInt(R), B.r = ne, B.g = ne, B.b = ne, B.a = 1;
							break;
						case Ki.INTENSITY_ALPHA:
							ne = parseInt("0x" + R.substring(2, 4)), B.r = ne, B.g = ne, B.b = ne, B.a = parseInt("0x" + R.substring(4, 6));
							break;
						case Ki.RGB:
							B.r = parseInt("0x" + R.substring(2, 4)), B.g = parseInt("0x" + R.substring(4, 6)), B.b = parseInt("0x" + R.substring(6, 8)), B.a = 1;
							break;
						case Ki.RGBA:
							B.r = parseInt("0x" + R.substring(2, 4)), B.g = parseInt("0x" + R.substring(4, 6)), B.b = parseInt("0x" + R.substring(6, 8)), B.a = parseInt("0x" + R.substring(8, 10));
							break;
						default:
					}
				}

				function p(R) {
					let E;
					switch (R) {
						case 1:
							E = Ki.INTENSITY;
							break;
						case 2:
							E = Ki.INTENSITY_ALPHA;
							break;
						case 3:
							E = Ki.RGB;
							break;
						case 4:
							E = Ki.RGBA;
							break;
						default:
					}
					return E
				}

				function _(R) {
					let E, B = Qt,
						ne = Qt,
						X = R.fields;
					for (let ae = 0, ge = X.length; ae < ge; ae++) {
						let ue = X[ae],
							se = ue.name,
							_e = ue.values;
						switch (se) {
							case "image":
								let Se = _e[0],
									Ne = _e[1],
									Fe = _e[2],
									ke = p(Fe),
									je = new Uint8Array(4 * Se * Ne),
									We = {
										r: 0,
										g: 0,
										b: 0,
										a: 0
									};
								for (let ce = 3, Le = 0, ve = _e.length; ce < ve; ce++, Le++) {
									d(_e[ce], ke, We);
									let Ie = Le * 4;
									je[Ie + 0] = We.r, je[Ie + 1] = We.g, je[Ie + 2] = We.b, je[Ie + 3] = We.a
								}
								E = new ca(je, Se, Ne), E.colorSpace = ot, E.needsUpdate = !0, E.__type = ke;
								break;
							case "repeatS":
								_e[0] === !1 && (B = Wt);
								break;
							case "repeatT":
								_e[0] === !1 && (ne = Wt);
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", se);
								break
						}
					}
					return E && (E.wrapS = B, E.wrapT = ne), E
				}

				function v(R) {
					let E, B = Qt,
						ne = Qt,
						X = R.fields;
					for (let ae = 0, ge = X.length; ae < ge; ae++) {
						let ue = X[ae],
							se = ue.name,
							_e = ue.values;
						switch (se) {
							case "url":
								let Se = _e[0];
								Se && (E = Me.load(Se));
								break;
							case "repeatS":
								_e[0] === !1 && (B = Wt);
								break;
							case "repeatT":
								_e[0] === !1 && (ne = Wt);
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", se);
								break
						}
					}
					return E && (E.wrapS = B, E.wrapT = ne, E.colorSpace = ot), E
				}

				function x(R) {
					let E = {
							center: new Ce,
							rotation: new Ce,
							scale: new Ce,
							translation: new Ce
						},
						B = R.fields;
					for (let ne = 0, X = B.length; ne < X; ne++) {
						let ae = B[ne],
							ge = ae.name,
							ue = ae.values;
						switch (ge) {
							case "center":
								E.center.set(ue[0], ue[1]);
								break;
							case "rotation":
								E.rotation = ue[0];
								break;
							case "scale":
								E.scale.set(ue[0], ue[1]);
								break;
							case "translation":
								E.translation.set(ue[0], ue[1]);
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ge);
								break
						}
					}
					return E
				}

				function M(R) {
					return R.fields[0].values
				}

				function I(R) {
					let E = {},
						B = R.fields;
					for (let ne = 0, X = B.length; ne < X; ne++) {
						let ae = B[ne],
							ge = ae.name,
							ue = ae.values;
						switch (ge) {
							case "title":
								E.title = ue[0];
								break;
							case "info":
								E.info = ue;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ge);
								break
						}
					}
					return E
				}

				function w(R) {
					let E, B, ne, X, ae = !0,
						ge = !0,
						ue = 0,
						se, _e, Se, Ne, Fe = !0,
						ke = !0,
						je = R.fields;
					for (let et = 0, vt = je.length; et < vt; et++) {
						let Mt = je[et],
							ft = Mt.name,
							Ue = Mt.values;
						switch (ft) {
							case "color":
								let Ye = Ue[0];
								Ye !== null && (E = c(Ye));
								break;
							case "coord":
								let Be = Ue[0];
								Be !== null && (B = c(Be));
								break;
							case "normal":
								let tt = Ue[0];
								tt !== null && (ne = c(tt));
								break;
							case "texCoord":
								let st = Ue[0];
								st !== null && (X = c(st));
								break;
							case "ccw":
								ae = Ue[0];
								break;
							case "colorIndex":
								se = Ue;
								break;
							case "colorPerVertex":
								Fe = Ue[0];
								break;
							case "convex":
								break;
							case "coordIndex":
								_e = Ue;
								break;
							case "creaseAngle":
								ue = Ue[0];
								break;
							case "normalIndex":
								Se = Ue;
								break;
							case "normalPerVertex":
								ke = Ue[0];
								break;
							case "solid":
								ge = Ue[0];
								break;
							case "texCoordIndex":
								Ne = Ue;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ft);
								break
						}
					}
					if (_e === void 0) return console.warn("THREE.VRMLLoader: Missing coordIndex."), new St;
					let We = H(_e, ae),
						ce, Le, ve;
					if (E) {
						if (Fe === !0)
							if (se && se.length > 0) {
								let et = H(se, ae);
								ce = J(We, et, E, 3)
							} else ce = N(We, new ze(E, 3));
						else if (se && se.length > 0) {
							let et = de(E, se),
								vt = oe(et, _e);
							ce = $(We, vt)
						} else {
							let et = oe(E, _e);
							ce = $(We, et)
						}
						ie(ce)
					}
					if (ne)
						if (ke === !0)
							if (Se && Se.length > 0) {
								let et = H(Se, ae);
								Le = J(We, et, ne, 3)
							} else Le = N(We, new ze(ne, 3));
					else if (Se && Se.length > 0) {
						let et = de(ne, Se),
							vt = oe(et, _e);
						Le = $(We, vt)
					} else {
						let et = oe(ne, _e);
						Le = $(We, et)
					} else Le = he(We, B, ue);
					if (X)
						if (Ne && Ne.length > 0) {
							let et = H(Ne, ae);
							ve = J(We, et, X, 2)
						} else ve = N(We, new ze(X, 2));
					let Ie = new St,
						De = N(We, new ze(B, 3));
					return Ie.setAttribute("position", De), Ie.setAttribute("normal", Le), ce && Ie.setAttribute("color", ce), ve && Ie.setAttribute("uv", ve), Ie._solid = ge, Ie._type = "mesh", Ie
				}

				function L(R) {
					let E, B, ne, X, ae = !0,
						ge = R.fields;
					for (let Ne = 0, Fe = ge.length; Ne < Fe; Ne++) {
						let ke = ge[Ne],
							je = ke.name,
							We = ke.values;
						switch (je) {
							case "color":
								let ce = We[0];
								ce !== null && (E = c(ce));
								break;
							case "coord":
								let Le = We[0];
								Le !== null && (B = c(Le));
								break;
							case "colorIndex":
								ne = We;
								break;
							case "colorPerVertex":
								ae = We[0];
								break;
							case "coordIndex":
								X = We;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", je);
								break
						}
					}
					let ue, se = te(X);
					if (E) {
						if (ae === !0)
							if (ne.length > 0) {
								let Ne = te(ne);
								ue = J(se, Ne, E, 3)
							} else ue = N(se, new ze(E, 3));
						else if (ne.length > 0) {
							let Ne = de(E, ne),
								Fe = fe(Ne, X);
							ue = le(se, Fe)
						} else {
							let Ne = fe(E, X);
							ue = le(se, Ne)
						}
						ie(ue)
					}
					let _e = new St,
						Se = N(se, new ze(B, 3));
					return _e.setAttribute("position", Se), ue && _e.setAttribute("color", ue), _e._type = "line", _e
				}

				function T(R) {
					let E, B, ne = R.fields;
					for (let ae = 0, ge = ne.length; ae < ge; ae++) {
						let ue = ne[ae],
							se = ue.name,
							_e = ue.values;
						switch (se) {
							case "color":
								let Se = _e[0];
								Se !== null && (E = c(Se));
								break;
							case "coord":
								let Ne = _e[0];
								Ne !== null && (B = c(Ne));
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", se);
								break
						}
					}
					let X = new St;
					if (X.setAttribute("position", new ze(B, 3)), E) {
						let ae = new ze(E, 3);
						ie(ae), X.setAttribute("color", ae)
					}
					return X._type = "points", X
				}

				function C(R) {
					let E = new re(2, 2, 2),
						B = R.fields;
					for (let X = 0, ae = B.length; X < ae; X++) {
						let ge = B[X],
							ue = ge.name,
							se = ge.values;
						switch (ue) {
							case "size":
								E.x = se[0], E.y = se[1], E.z = se[2];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ue);
								break
						}
					}
					return new Xs(E.x, E.y, E.z)
				}

				function V(R) {
					let E = 1,
						B = 2,
						ne = !1,
						X = R.fields;
					for (let ge = 0, ue = X.length; ge < ue; ge++) {
						let se = X[ge],
							_e = se.name,
							Se = se.values;
						switch (_e) {
							case "bottom":
								ne = !Se[0];
								break;
							case "bottomRadius":
								E = Se[0];
								break;
							case "height":
								B = Se[0];
								break;
							case "side":
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", _e);
								break
						}
					}
					return new Cu(E, B, 16, 1, ne)
				}

				function k(R) {
					let E = 1,
						B = 2,
						ne = R.fields;
					for (let ae = 0, ge = ne.length; ae < ge; ae++) {
						let ue = ne[ae],
							se = ue.name,
							_e = ue.values;
						switch (se) {
							case "bottom":
								break;
							case "radius":
								E = _e[0];
								break;
							case "height":
								B = _e[0];
								break;
							case "side":
								break;
							case "top":
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", se);
								break
						}
					}
					return new Dl(E, E, B, 16, 1)
				}

				function F(R) {
					let E = 1,
						B = R.fields;
					for (let X = 0, ae = B.length; X < ae; X++) {
						let ge = B[X],
							ue = ge.name,
							se = ge.values;
						switch (ue) {
							case "radius":
								E = se[0];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ue);
								break
						}
					}
					return new ha(E, 16, 16)
				}

				function U(R) {
					let E, B, ne, X, ae = !0,
						ge = !0,
						ue = !0,
						se = !0,
						_e = 0,
						Se = 2,
						Ne = 2,
						Fe = 1,
						ke = 1,
						je = R.fields;
					for (let Ue = 0, Ye = je.length; Ue < Ye; Ue++) {
						let Be = je[Ue],
							tt = Be.name,
							st = Be.values;
						switch (tt) {
							case "color":
								let zt = st[0];
								zt !== null && (E = c(zt));
								break;
							case "normal":
								let Hn = st[0];
								Hn !== null && (B = c(Hn));
								break;
							case "texCoord":
								let si = st[0];
								si !== null && (ne = c(si));
								break;
							case "height":
								X = st;
								break;
							case "ccw":
								se = st[0];
								break;
							case "colorPerVertex":
								ae = st[0];
								break;
							case "creaseAngle":
								_e = st[0];
								break;
							case "normalPerVertex":
								ge = st[0];
								break;
							case "solid":
								ue = st[0];
								break;
							case "xDimension":
								Se = st[0];
								break;
							case "xSpacing":
								Fe = st[0];
								break;
							case "zDimension":
								Ne = st[0];
								break;
							case "zSpacing":
								ke = st[0];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", tt);
								break
						}
					}
					let We = [],
						ce = [],
						Le = [],
						ve = [];
					for (let Ue = 0; Ue < Ne; Ue++)
						for (let Ye = 0; Ye < Se; Ye++) {
							let Be = Ue * Se + Ye,
								tt = Fe * Ue,
								st = X[Be],
								zt = ke * Ye;
							if (We.push(tt, st, zt), E && ae === !0) {
								let Hn = E[Be * 3 + 0],
									si = E[Be * 3 + 1],
									Ci = E[Be * 3 + 2];
								Le.push(Hn, si, Ci)
							}
							if (B && ge === !0) {
								let Hn = B[Be * 3 + 0],
									si = B[Be * 3 + 1],
									Ci = B[Be * 3 + 2];
								ce.push(Hn, si, Ci)
							}
							if (ne) {
								let Hn = ne[Be * 2 + 0],
									si = ne[Be * 2 + 1];
								ve.push(Hn, si)
							} else ve.push(Ue / (Se - 1), Ye / (Ne - 1))
						}
					let Ie = [];
					for (let Ue = 0; Ue < Se - 1; Ue++)
						for (let Ye = 0; Ye < Ne - 1; Ye++) {
							let Be = Ue + Ye * Se,
								tt = Ue + (Ye + 1) * Se,
								st = Ue + 1 + (Ye + 1) * Se,
								zt = Ue + 1 + Ye * Se;
							se === !0 ? (Ie.push(Be, st, tt), Ie.push(st, Be, zt)) : (Ie.push(Be, tt, st), Ie.push(st, zt, Be))
						}
					let De = N(Ie, new ze(We, 3)),
						et = N(Ie, new ze(ve, 2)),
						vt, Mt;
					if (E) {
						if (ae === !1) {
							for (let Ue = 0; Ue < Se - 1; Ue++)
								for (let Ye = 0; Ye < Ne - 1; Ye++) {
									let Be = Ue + Ye * (Se - 1),
										tt = E[Be * 3 + 0],
										st = E[Be * 3 + 1],
										zt = E[Be * 3 + 2];
									Le.push(tt, st, zt), Le.push(tt, st, zt), Le.push(tt, st, zt), Le.push(tt, st, zt), Le.push(tt, st, zt), Le.push(tt, st, zt)
								}
							vt = new ze(Le, 3)
						} else vt = N(Ie, new ze(Le, 3));
						ie(vt)
					}
					if (B)
						if (ge === !1) {
							for (let Ue = 0; Ue < Se - 1; Ue++)
								for (let Ye = 0; Ye < Ne - 1; Ye++) {
									let Be = Ue + Ye * (Se - 1),
										tt = B[Be * 3 + 0],
										st = B[Be * 3 + 1],
										zt = B[Be * 3 + 2];
									ce.push(tt, st, zt), ce.push(tt, st, zt), ce.push(tt, st, zt), ce.push(tt, st, zt), ce.push(tt, st, zt), ce.push(tt, st, zt)
								}
							Mt = new ze(ce, 3)
						} else Mt = N(Ie, new ze(ce, 3));
					else Mt = he(Ie, We, _e);
					let ft = new St;
					return ft.setAttribute("position", De), ft.setAttribute("normal", Mt), ft.setAttribute("uv", et), vt && ft.setAttribute("color", vt), ft._solid = ue, ft._type = "mesh", ft
				}

				function K(R) {
					let E = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
						B = [0, 0, 0, 0, 1, 0],
						ne, X, ae = !0,
						ge = !0,
						ue = 0,
						se = !0,
						_e = !0,
						Se = R.fields;
					for (let ft = 0, Ue = Se.length; ft < Ue; ft++) {
						let Ye = Se[ft],
							Be = Ye.name,
							tt = Ye.values;
						switch (Be) {
							case "beginCap":
								ae = tt[0];
								break;
							case "ccw":
								ge = tt[0];
								break;
							case "convex":
								break;
							case "creaseAngle":
								ue = tt[0];
								break;
							case "crossSection":
								E = tt;
								break;
							case "endCap":
								se = tt[0];
								break;
							case "orientation":
								X = tt;
								break;
							case "scale":
								ne = tt;
								break;
							case "solid":
								_e = tt[0];
								break;
							case "spine":
								B = tt;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", Be);
								break
						}
					}
					let Ne = E[0] === E[E.length - 2] && E[1] === E[E.length - 1],
						Fe = [],
						ke = new re,
						je = new re,
						We = new re,
						ce = new re,
						Le = new yn;
					for (let ft = 0, Ue = 0, Ye = 0, Be = B.length; ft < Be; ft += 3, Ue += 2, Ye += 4) {
						ke.fromArray(B, ft), je.x = ne ? ne[Ue + 0] : 1, je.y = 1, je.z = ne ? ne[Ue + 1] : 1, We.x = X ? X[Ye + 0] : 0, We.y = X ? X[Ye + 1] : 0, We.z = X ? X[Ye + 2] : 1;
						let tt = X ? X[Ye + 3] : 0;
						for (let st = 0, zt = E.length; st < zt; st += 2) ce.x = E[st + 0], ce.y = 0, ce.z = E[st + 1], ce.multiply(je), Le.setFromAxisAngle(We, tt), ce.applyQuaternion(Le), ce.add(ke), Fe.push(ce.x, ce.y, ce.z)
					}
					let ve = [],
						Ie = B.length / 3,
						De = E.length / 2;
					for (let ft = 0; ft < Ie - 1; ft++)
						for (let Ue = 0; Ue < De - 1; Ue++) {
							let Ye = Ue + ft * De,
								Be = Ue + 1 + ft * De,
								tt = Ue + (ft + 1) * De,
								st = Ue + 1 + (ft + 1) * De;
							Ue === De - 2 && Ne === !0 && (Be = ft * De, st = (ft + 1) * De), ge === !0 ? (ve.push(Ye, Be, tt), ve.push(tt, Be, st)) : (ve.push(Ye, tt, Be), ve.push(tt, st, Be))
						}
					if (ae === !0 || se === !0) {
						let ft = [];
						for (let Be = 0, tt = E.length; Be < tt; Be += 2) ft.push(new Ce(E[Be], E[Be + 1]));
						let Ue = lr.triangulateShape(ft, []),
							Ye = [];
						for (let Be = 0, tt = Ue.length; Be < tt; Be++) {
							let st = Ue[Be];
							Ye.push(st[0], st[1], st[2])
						}
						if (ae === !0)
							for (let Be = 0, tt = Ye.length; Be < tt; Be += 3) ge === !0 ? ve.push(Ye[Be + 0], Ye[Be + 1], Ye[Be + 2]) : ve.push(Ye[Be + 0], Ye[Be + 2], Ye[Be + 1]);
						if (se === !0) {
							let Be = De * (Ie - 1);
							for (let tt = 0, st = Ye.length; tt < st; tt += 3) ge === !0 ? ve.push(Be + Ye[tt + 0], Be + Ye[tt + 2], Be + Ye[tt + 1]) : ve.push(Be + Ye[tt + 0], Be + Ye[tt + 1], Be + Ye[tt + 2])
						}
					}
					let et = N(ve, new ze(Fe, 3)),
						vt = he(ve, Fe, ue),
						Mt = new St;
					return Mt.setAttribute("position", et), Mt.setAttribute("normal", vt), Mt._solid = _e, Mt._type = "mesh", Mt
				}

				function Z(R) {
					let E = n[R],
						B = c(E);
					return B.isObject3D || B.isMaterial ? B.clone() : B
				}

				function Y(R, E) {
					for (let B = 0, ne = R.length; B < ne; B++) {
						let X = c(R[B]);
						X instanceof Rt && E.add(X)
					}
				}

				function H(R, E) {
					let B = [],
						ne = 0;
					for (let X = 0, ae = R.length; X < ae; X++) {
						let ge = R[ne],
							ue = R[X + (E ? 1 : 2)],
							se = R[X + (E ? 2 : 1)];
						B.push(ge, ue, se), (R[X + 3] === -1 || X + 3 >= ae) && (X += 3, ne = X + 1)
					}
					return B
				}

				function oe(R, E) {
					let B = [],
						ne = 0;
					for (let X = 0, ae = E.length; X < ae; X++) {
						let ge = ne * 3,
							ue = R[ge],
							se = R[ge + 1],
							_e = R[ge + 2];
						B.push(ue, se, _e), (E[X + 3] === -1 || X + 3 >= ae) && (X += 3, ne++)
					}
					return B
				}

				function de(R, E) {
					let B = [];
					for (let ne = 0, X = E.length; ne < X; ne++) {
						let ge = E[ne] * 3,
							ue = R[ge],
							se = R[ge + 1],
							_e = R[ge + 2];
						B.push(ue, se, _e)
					}
					return B
				}

				function te(R) {
					let E = [];
					for (let B = 0, ne = R.length; B < ne; B++) {
						let X = R[B],
							ae = R[B + 1];
						E.push(X, ae), (R[B + 2] === -1 || B + 2 >= ne) && (B += 2)
					}
					return E
				}

				function fe(R, E) {
					let B = [],
						ne = 0;
					for (let X = 0, ae = E.length; X < ae; X++) {
						let ge = ne * 3,
							ue = R[ge],
							se = R[ge + 1],
							_e = R[ge + 2];
						B.push(ue, se, _e), (E[X + 2] === -1 || X + 2 >= ae) && (X += 2, ne++)
					}
					return B
				}
				let me = new re,
					P = new re,
					b = new re,
					S = new Ce,
					A = new Ce,
					G = new Ce;

				function J(R, E, B, ne) {
					let X = [];
					for (let ae = 0, ge = R.length; ae < ge; ae += 3) {
						let ue = E[ae],
							se = E[ae + 1],
							_e = E[ae + 2];
						ne === 2 ? (S.fromArray(B, ue * ne), A.fromArray(B, se * ne), G.fromArray(B, _e * ne), X.push(S.x, S.y), X.push(A.x, A.y), X.push(G.x, G.y)) : (me.fromArray(B, ue * ne), P.fromArray(B, se * ne), b.fromArray(B, _e * ne), X.push(me.x, me.y, me.z), X.push(P.x, P.y, P.z), X.push(b.x, b.y, b.z))
					}
					return new ze(X, ne)
				}

				function $(R, E) {
					let B = [];
					for (let ne = 0, X = 0, ae = R.length; ne < ae; ne += 3, X++) me.fromArray(E, X * 3), B.push(me.x, me.y, me.z), B.push(me.x, me.y, me.z), B.push(me.x, me.y, me.z);
					return new ze(B, 3)
				}

				function le(R, E) {
					let B = [];
					for (let ne = 0, X = 0, ae = R.length; ne < ae; ne += 2, X++) me.fromArray(E, X * 3), B.push(me.x, me.y, me.z), B.push(me.x, me.y, me.z);
					return new ze(B, 3)
				}

				function N(R, E) {
					let B = E.array,
						ne = E.itemSize,
						X = new B.constructor(R.length * ne),
						ae = 0,
						ge = 0;
					for (let ue = 0, se = R.length; ue < se; ue++) {
						ae = R[ue] * ne;
						for (let _e = 0; _e < ne; _e++) X[ge++] = B[ae++]
					}
					return new ze(X, ne)
				}
				let pe = new re,
					Q = new re;

				function he(R, E, B) {
					let ne = [],
						X = {};
					for (let ge = 0, ue = R.length; ge < ue; ge += 3) {
						let se = R[ge],
							_e = R[ge + 1],
							Se = R[ge + 2],
							Ne = new Od(se, _e, Se);
						me.fromArray(E, se * 3), P.fromArray(E, _e * 3), b.fromArray(E, Se * 3), Q.subVectors(b, P), pe.subVectors(me, P), Q.cross(pe), Q.normalize(), Ne.normal.copy(Q), X[se] === void 0 && (X[se] = []), X[_e] === void 0 && (X[_e] = []), X[Se] === void 0 && (X[Se] = []), X[se].push(Ne.normal), X[_e].push(Ne.normal), X[Se].push(Ne.normal), ne.push(Ne)
					}
					let ae = [];
					for (let ge = 0, ue = ne.length; ge < ue; ge++) {
						let se = ne[ge],
							_e = ye(X[se.a], se.normal, B),
							Se = ye(X[se.b], se.normal, B),
							Ne = ye(X[se.c], se.normal, B);
						me.fromArray(E, se.a * 3), P.fromArray(E, se.b * 3), b.fromArray(E, se.c * 3), ae.push(_e.x, _e.y, _e.z), ae.push(Se.x, Se.y, Se.z), ae.push(Ne.x, Ne.y, Ne.z)
					}
					return new ze(ae, 3)
				}

				function ye(R, E, B) {
					let ne = new re;
					if (B === 0) ne.copy(E);
					else
						for (let X = 0, ae = R.length; X < ae; X++) R[X].angleTo(E) < B && ne.add(R[X]);
					return ne.normalize()
				}

				function Ee(R) {
					let E = [];
					for (let B = 0, ne = R.length; B < ne; B += 3) E.push(new qe(R[B], R[B + 1], R[B + 2]));
					return E
				}

				function ie(R) {
					let E = new qe;
					for (let B = 0; B < R.count; B++) E.fromBufferAttribute(R, B), E.convertSRGBToLinear(), R.setXYZ(B, E.r, E.g, E.b)
				}

				function q(R, E, B, ne, X) {
					let ae = [],
						ge = X === !0 ? 0 : Math.PI;
					for (let Fe = 0, ke = ne.length; Fe < ke; Fe++) {
						let je = Fe === 0 ? 0 : B[Fe - 1];
						je = X === !0 ? je : ge - je;
						let We = new re;
						We.setFromSphericalCoords(E, je, 0), ae.push(We)
					}
					let ue = R.index,
						se = R.attributes.position,
						_e = new Ln(new Float32Array(R.attributes.position.count * 3), 3),
						Se = new re,
						Ne = new qe;
					for (let Fe = 0; Fe < ue.count; Fe++) {
						let ke = ue.getX(Fe);
						Se.fromBufferAttribute(se, ke);
						let je, We, ce = 1;
						for (let Ie = 1; Ie < ae.length; Ie++) {
							je = Ie - 1, We = Ie;
							let De = ae[je],
								et = ae[We];
							if (X === !0) {
								if (Se.y <= De.y && Se.y > et.y) {
									ce = Math.abs(De.y - Se.y) / Math.abs(De.y - et.y);
									break
								}
							} else if (Se.y >= De.y && Se.y < et.y) {
								ce = Math.abs(De.y - Se.y) / Math.abs(De.y - et.y);
								break
							}
						}
						let Le = ne[je],
							ve = ne[We];
						Ne.copy(Le).lerp(ve, ce).convertSRGBToLinear(), _e.setXYZ(ke, Ne.r, Ne.g, Ne.b)
					}
					R.setAttribute("color", _e)
				}
				let Me = new bi(this.manager);
				if (Me.setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin), e.indexOf("#VRML V2.0") === -1) throw Error("THREE.VRMLLexer: Version of VRML asset not supported.");
				let Pe = i(e);
				return a(Pe)
			}
		},
		Ld = class {
			constructor(e) {
				this.lexer = new Ia.Lexer(e)
			}
			lex(e) {
				let t = this.lexer.tokenize(e);
				if (t.errors.length > 0) throw console.error(t.errors), Error("THREE.VRMLLexer: Lexing errors detected.");
				return t
			}
		},
		Ub = Ia.CstParser,
		Nd = class extends Ub {
			constructor(e) {
				super(e);
				let t = this,
					n = e.Version,
					i = e.LCurly,
					s = e.RCurly,
					o = e.LSquare,
					a = e.RSquare,
					l = e.Identifier,
					c = e.RouteIdentifier,
					u = e.StringLiteral,
					h = e.HexLiteral,
					f = e.NumberLiteral,
					m = e.TrueLiteral,
					g = e.FalseLiteral,
					y = e.NullLiteral,
					d = e.DEF,
					p = e.USE,
					_ = e.ROUTE,
					v = e.TO,
					x = e.NodeName;
				t.RULE("vrml", function() {
					t.SUBRULE(t.version), t.AT_LEAST_ONE(function() {
						t.SUBRULE(t.node)
					}), t.MANY(function() {
						t.SUBRULE(t.route)
					})
				}), t.RULE("version", function() {
					t.CONSUME(n)
				}), t.RULE("node", function() {
					t.OPTION(function() {
						t.SUBRULE(t.def)
					}), t.CONSUME(x), t.CONSUME(i), t.MANY(function() {
						t.SUBRULE(t.field)
					}), t.CONSUME(s)
				}), t.RULE("field", function() {
					t.CONSUME(l), t.OR2([{
						ALT: function() {
							t.SUBRULE(t.singleFieldValue)
						}
					}, {
						ALT: function() {
							t.SUBRULE(t.multiFieldValue)
						}
					}])
				}), t.RULE("def", function() {
					t.CONSUME(d), t.OR([{
						ALT: function() {
							t.CONSUME(l)
						}
					}, {
						ALT: function() {
							t.CONSUME(x)
						}
					}])
				}), t.RULE("use", function() {
					t.CONSUME(p), t.OR([{
						ALT: function() {
							t.CONSUME(l)
						}
					}, {
						ALT: function() {
							t.CONSUME(x)
						}
					}])
				}), t.RULE("singleFieldValue", function() {
					t.AT_LEAST_ONE(function() {
						t.OR([{
							ALT: function() {
								t.SUBRULE(t.node)
							}
						}, {
							ALT: function() {
								t.SUBRULE(t.use)
							}
						}, {
							ALT: function() {
								t.CONSUME(u)
							}
						}, {
							ALT: function() {
								t.CONSUME(h)
							}
						}, {
							ALT: function() {
								t.CONSUME(f)
							}
						}, {
							ALT: function() {
								t.CONSUME(m)
							}
						}, {
							ALT: function() {
								t.CONSUME(g)
							}
						}, {
							ALT: function() {
								t.CONSUME(y)
							}
						}])
					})
				}), t.RULE("multiFieldValue", function() {
					t.CONSUME(o), t.MANY(function() {
						t.OR([{
							ALT: function() {
								t.SUBRULE(t.node)
							}
						}, {
							ALT: function() {
								t.SUBRULE(t.use)
							}
						}, {
							ALT: function() {
								t.CONSUME(u)
							}
						}, {
							ALT: function() {
								t.CONSUME(h)
							}
						}, {
							ALT: function() {
								t.CONSUME(f)
							}
						}, {
							ALT: function() {
								t.CONSUME(y)
							}
						}])
					}), t.CONSUME(a)
				}), t.RULE("route", function() {
					t.CONSUME(_), t.CONSUME(c), t.CONSUME(v), t.CONSUME2(c)
				}), this.performSelfAnalysis()
			}
		},
		Od = class {
			constructor(e, t, n) {
				this.a = e, this.b = t, this.c = n, this.normal = new re
			}
		},
		Ki = {
			INTENSITY: 1,
			INTENSITY_ALPHA: 2,
			RGB: 3,
			RGBA: 4
		};
	var Dd = ot,
		ah = class extends Ot {
			constructor(e) {
				super(e), this.availableExtensions = []
			}
			load(e, t, n, i) {
				let s = this,
					o = new jn(s.manager);
				o.setPath(s.path), o.setResponseType("arraybuffer"), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
					try {
						t(s.parse(a))
					} catch (l) {
						i ? i(l) : console.error(l), s.manager.itemError(e)
					}
				}, n, i)
			}
			parse(e) {
				let t = this,
					n = new bi(this.manager);

				function i(P) {
					let b = null,
						S = null,
						A, G, J = [],
						$ = [],
						le, N = {},
						pe = {},
						Q = {},
						he = new TextDecoder;
					try {
						b = Yu(new Uint8Array(P))
					} catch (q) {
						if (q instanceof ReferenceError) return console.error("THREE.3MFLoader: fflate missing and file is compressed."), null
					}
					for (S in b) S.match(/\_rels\/.rels$/) ? A = S : S.match(/3D\/_rels\/.*\.model\.rels$/) ? G = S : S.match(/^3D\/.*\.model$/) ? J.push(S) : S.match(/^3D\/Textures?\/.*/) && $.push(S);
					let ye = b[A],
						Ee = he.decode(ye),
						ie = s(Ee);
					if (G) {
						let q = b[G],
							Me = he.decode(q);
						le = s(Me)
					}
					for (let q = 0; q < J.length; q++) {
						let Me = J[q],
							Pe = b[Me],
							Ke = he.decode(Pe),
							R = new DOMParser().parseFromString(Ke, "application/xml");
						R.documentElement.nodeName.toLowerCase() !== "model" && console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ", Me);
						let E = R.querySelector("model"),
							B = {};
						for (let X = 0; X < E.attributes.length; X++) {
							let ae = E.attributes[X];
							ae.name.match(/^xmlns:(.+)$/) && (B[ae.value] = RegExp.$1)
						}
						let ne = x(E);
						ne.xml = E, 0 < Object.keys(B).length && (ne.extensions = B), N[Me] = ne
					}
					for (let q = 0; q < $.length; q++) {
						let Me = $[q];
						Q[Me] = b[Me].buffer
					}
					return {
						rels: ie,
						modelRels: le,
						model: N,
						printTicket: pe,
						texture: Q
					}
				}

				function s(P) {
					let b = [],
						A = new DOMParser().parseFromString(P, "application/xml").querySelectorAll("Relationship");
					for (let G = 0; G < A.length; G++) {
						let J = A[G],
							$ = {
								target: J.getAttribute("Target"),
								id: J.getAttribute("Id"),
								type: J.getAttribute("Type")
							};
						b.push($)
					}
					return b
				}

				function o(P) {
					let b = {};
					for (let S = 0; S < P.length; S++) {
						let A = P[S],
							G = A.getAttribute("name");
						0 <= ["Title", "Designer", "Description", "Copyright", "LicenseTerms", "Rating", "CreationDate", "ModificationDate"].indexOf(G) && (b[G] = A.textContent)
					}
					return b
				}

				function a(P) {
					let b = {
							id: P.getAttribute("id"),
							basematerials: []
						},
						S = P.querySelectorAll("base");
					for (let A = 0; A < S.length; A++) {
						let G = S[A],
							J = f(G);
						J.index = A, b.basematerials.push(J)
					}
					return b
				}

				function l(P) {
					return {
						id: P.getAttribute("id"),
						path: P.getAttribute("path"),
						contenttype: P.getAttribute("contenttype"),
						tilestyleu: P.getAttribute("tilestyleu"),
						tilestylev: P.getAttribute("tilestylev"),
						filter: P.getAttribute("filter")
					}
				}

				function c(P) {
					let b = {
							id: P.getAttribute("id"),
							texid: P.getAttribute("texid"),
							displaypropertiesid: P.getAttribute("displaypropertiesid")
						},
						S = P.querySelectorAll("tex2coord"),
						A = [];
					for (let G = 0; G < S.length; G++) {
						let J = S[G],
							$ = J.getAttribute("u"),
							le = J.getAttribute("v");
						A.push(parseFloat($), parseFloat(le))
					}
					return b.uvs = new Float32Array(A), b
				}

				function u(P) {
					let b = {
							id: P.getAttribute("id"),
							displaypropertiesid: P.getAttribute("displaypropertiesid")
						},
						S = P.querySelectorAll("color"),
						A = [],
						G = new qe;
					for (let J = 0; J < S.length; J++) {
						let le = S[J].getAttribute("color");
						G.setStyle(le.substring(0, 7), Dd), A.push(G.r, G.g, G.b)
					}
					return b.colors = new Float32Array(A), b
				}

				function h(P) {
					let b = {
							id: P.getAttribute("id")
						},
						S = P.querySelectorAll("pbmetallic"),
						A = [];
					for (let G = 0; G < S.length; G++) {
						let J = S[G];
						A.push({
							name: J.getAttribute("name"),
							metallicness: parseFloat(J.getAttribute("metallicness")),
							roughness: parseFloat(J.getAttribute("roughness"))
						})
					}
					return b.data = A, b
				}

				function f(P) {
					let b = {};
					return b.name = P.getAttribute("name"), b.displaycolor = P.getAttribute("displaycolor"), b.displaypropertiesid = P.getAttribute("displaypropertiesid"), b
				}

				function m(P) {
					let b = {},
						S = [],
						A = P.querySelectorAll("vertices vertex");
					for (let le = 0; le < A.length; le++) {
						let N = A[le],
							pe = N.getAttribute("x"),
							Q = N.getAttribute("y"),
							he = N.getAttribute("z");
						S.push(parseFloat(pe), parseFloat(Q), parseFloat(he))
					}
					b.vertices = new Float32Array(S);
					let G = [],
						J = [],
						$ = P.querySelectorAll("triangles triangle");
					for (let le = 0; le < $.length; le++) {
						let N = $[le],
							pe = N.getAttribute("v1"),
							Q = N.getAttribute("v2"),
							he = N.getAttribute("v3"),
							ye = N.getAttribute("p1"),
							Ee = N.getAttribute("p2"),
							ie = N.getAttribute("p3"),
							q = N.getAttribute("pid"),
							Me = {};
						Me.v1 = parseInt(pe, 10), Me.v2 = parseInt(Q, 10), Me.v3 = parseInt(he, 10), J.push(Me.v1, Me.v2, Me.v3), ye && (Me.p1 = parseInt(ye, 10)), Ee && (Me.p2 = parseInt(Ee, 10)), ie && (Me.p3 = parseInt(ie, 10)), q && (Me.pid = q), 0 < Object.keys(Me).length && G.push(Me)
					}
					return b.triangleProperties = G, b.triangles = new Uint32Array(J), b
				}

				function g(P) {
					let b = [],
						S = P.querySelectorAll("component");
					for (let A = 0; A < S.length; A++) {
						let G = S[A],
							J = y(G);
						b.push(J)
					}
					return b
				}

				function y(P) {
					let b = {};
					b.objectId = P.getAttribute("objectid");
					let S = P.getAttribute("transform");
					return S && (b.transform = d(S)), b
				}

				function d(P) {
					let b = [];
					P.split(" ").forEach(function(A) {
						b.push(parseFloat(A))
					});
					let S = new Je;
					return S.set(b[0], b[3], b[6], b[9], b[1], b[4], b[7], b[10], b[2], b[5], b[8], b[11], 0, 0, 0, 1), S
				}

				function p(P) {
					let b = {
							type: P.getAttribute("type")
						},
						S = P.getAttribute("id");
					S && (b.id = S);
					let A = P.getAttribute("pid");
					A && (b.pid = A);
					let G = P.getAttribute("pindex");
					G && (b.pindex = G);
					let J = P.getAttribute("thumbnail");
					J && (b.thumbnail = J);
					let $ = P.getAttribute("partnumber");
					$ && (b.partnumber = $);
					let le = P.getAttribute("name");
					le && (b.name = le);
					let N = P.querySelector("mesh");
					N && (b.mesh = m(N));
					let pe = P.querySelector("components");
					return pe && (b.components = g(pe)), b
				}

				function _(P) {
					let b = {};
					b.basematerials = {};
					let S = P.querySelectorAll("basematerials");
					for (let N = 0; N < S.length; N++) {
						let pe = S[N],
							Q = a(pe);
						b.basematerials[Q.id] = Q
					}
					b.texture2d = {};
					let A = P.querySelectorAll("texture2d");
					for (let N = 0; N < A.length; N++) {
						let pe = A[N],
							Q = l(pe);
						b.texture2d[Q.id] = Q
					}
					b.colorgroup = {};
					let G = P.querySelectorAll("colorgroup");
					for (let N = 0; N < G.length; N++) {
						let pe = G[N],
							Q = u(pe);
						b.colorgroup[Q.id] = Q
					}
					b.pbmetallicdisplayproperties = {};
					let J = P.querySelectorAll("pbmetallicdisplayproperties");
					for (let N = 0; N < J.length; N++) {
						let pe = J[N],
							Q = h(pe);
						b.pbmetallicdisplayproperties[Q.id] = Q
					}
					b.texture2dgroup = {};
					let $ = P.querySelectorAll("texture2dgroup");
					for (let N = 0; N < $.length; N++) {
						let pe = $[N],
							Q = c(pe);
						b.texture2dgroup[Q.id] = Q
					}
					b.object = {};
					let le = P.querySelectorAll("object");
					for (let N = 0; N < le.length; N++) {
						let pe = le[N],
							Q = p(pe);
						b.object[Q.id] = Q
					}
					return b
				}

				function v(P) {
					let b = [],
						S = P.querySelectorAll("item");
					for (let A = 0; A < S.length; A++) {
						let G = S[A],
							J = {
								objectId: G.getAttribute("objectid")
							},
							$ = G.getAttribute("transform");
						$ && (J.transform = d($)), b.push(J)
					}
					return b
				}

				function x(P) {
					let b = {
							unit: P.getAttribute("unit") || "millimeter"
						},
						S = P.querySelectorAll("metadata");
					S && (b.metadata = o(S));
					let A = P.querySelector("resources");
					A && (b.resources = _(A));
					let G = P.querySelector("build");
					return G && (b.build = v(G)), b
				}

				function M(P, b, S, A) {
					let G = P.texid,
						$ = S.resources.texture2d[G];
					if ($) {
						let le = A[$.path],
							N = $.contenttype,
							pe = new Blob([le], {
								type: N
							}),
							Q = URL.createObjectURL(pe),
							he = n.load(Q, function() {
								URL.revokeObjectURL(Q)
							});
						switch (he.colorSpace = Dd, $.tilestyleu) {
							case "wrap":
								he.wrapS = Qt;
								break;
							case "mirror":
								he.wrapS = ia;
								break;
							case "none":
							case "clamp":
								he.wrapS = Wt;
								break;
							default:
								he.wrapS = Qt
						}
						switch ($.tilestylev) {
							case "wrap":
								he.wrapT = Qt;
								break;
							case "mirror":
								he.wrapT = ia;
								break;
							case "none":
							case "clamp":
								he.wrapT = Wt;
								break;
							default:
								he.wrapT = Qt
						}
						switch ($.filter) {
							case "auto":
								he.magFilter = mn, he.minFilter = ki;
								break;
							case "linear":
								he.magFilter = mn, he.minFilter = mn;
								break;
							case "nearest":
								he.magFilter = pn, he.minFilter = pn;
								break;
							default:
								he.magFilter = mn, he.minFilter = ki
						}
						return he
					} else return null
				}

				function I(P, b, S, A, G, J, $) {
					let le = $.pindex,
						N = {};
					for (let he = 0, ye = b.length; he < ye; he++) {
						let Ee = b[he],
							ie = Ee.p1 !== void 0 ? Ee.p1 : le;
						N[ie] === void 0 && (N[ie] = []), N[ie].push(Ee)
					}
					let pe = Object.keys(N),
						Q = [];
					for (let he = 0, ye = pe.length; he < ye; he++) {
						let Ee = pe[he],
							ie = N[Ee],
							q = P.basematerials[Ee],
							Me = K(q, A, G, J, $, Z),
							Pe = new St,
							Ke = [],
							R = S.vertices;
						for (let B = 0, ne = ie.length; B < ne; B++) {
							let X = ie[B];
							Ke.push(R[X.v1 * 3 + 0]), Ke.push(R[X.v1 * 3 + 1]), Ke.push(R[X.v1 * 3 + 2]), Ke.push(R[X.v2 * 3 + 0]), Ke.push(R[X.v2 * 3 + 1]), Ke.push(R[X.v2 * 3 + 2]), Ke.push(R[X.v3 * 3 + 0]), Ke.push(R[X.v3 * 3 + 1]), Ke.push(R[X.v3 * 3 + 2])
						}
						Pe.setAttribute("position", new ze(Ke, 3));
						let E = new Nt(Pe, Me);
						Q.push(E)
					}
					return Q
				}

				function w(P, b, S, A, G, J, $) {
					let le = new St,
						N = [],
						pe = [],
						Q = S.vertices,
						he = P.uvs;
					for (let q = 0, Me = b.length; q < Me; q++) {
						let Pe = b[q];
						N.push(Q[Pe.v1 * 3 + 0]), N.push(Q[Pe.v1 * 3 + 1]), N.push(Q[Pe.v1 * 3 + 2]), N.push(Q[Pe.v2 * 3 + 0]), N.push(Q[Pe.v2 * 3 + 1]), N.push(Q[Pe.v2 * 3 + 2]), N.push(Q[Pe.v3 * 3 + 0]), N.push(Q[Pe.v3 * 3 + 1]), N.push(Q[Pe.v3 * 3 + 2]), pe.push(he[Pe.p1 * 2 + 0]), pe.push(he[Pe.p1 * 2 + 1]), pe.push(he[Pe.p2 * 2 + 0]), pe.push(he[Pe.p2 * 2 + 1]), pe.push(he[Pe.p3 * 2 + 0]), pe.push(he[Pe.p3 * 2 + 1])
					}
					le.setAttribute("position", new ze(N, 3)), le.setAttribute("uv", new ze(pe, 2));
					let ye = K(P, A, G, J, $, M),
						Ee = new Xt({
							map: ye,
							flatShading: !0
						});
					return new Nt(le, Ee)
				}

				function L(P, b, S, A) {
					let G = new St,
						J = [],
						$ = [],
						le = S.vertices,
						N = P.colors;
					for (let he = 0, ye = b.length; he < ye; he++) {
						let Ee = b[he],
							ie = Ee.v1,
							q = Ee.v2,
							Me = Ee.v3;
						J.push(le[ie * 3 + 0]), J.push(le[ie * 3 + 1]), J.push(le[ie * 3 + 2]), J.push(le[q * 3 + 0]), J.push(le[q * 3 + 1]), J.push(le[q * 3 + 2]), J.push(le[Me * 3 + 0]), J.push(le[Me * 3 + 1]), J.push(le[Me * 3 + 2]);
						let Pe = Ee.p1 !== void 0 ? Ee.p1 : A.pindex,
							Ke = Ee.p2 !== void 0 ? Ee.p2 : Pe,
							R = Ee.p3 !== void 0 ? Ee.p3 : Pe;
						$.push(N[Pe * 3 + 0]), $.push(N[Pe * 3 + 1]), $.push(N[Pe * 3 + 2]), $.push(N[Ke * 3 + 0]), $.push(N[Ke * 3 + 1]), $.push(N[Ke * 3 + 2]), $.push(N[R * 3 + 0]), $.push(N[R * 3 + 1]), $.push(N[R * 3 + 2])
					}
					G.setAttribute("position", new ze(J, 3)), G.setAttribute("color", new ze($, 3));
					let pe = new Xt({
						vertexColors: !0,
						flatShading: !0
					});
					return new Nt(G, pe)
				}

				function T(P) {
					let b = new St;
					b.setIndex(new Ln(P.triangles, 1)), b.setAttribute("position", new Ln(P.vertices, 3));
					let S = new Xt({
						name: Ot.DEFAULT_MATERIAL_NAME,
						color: 16777215,
						flatShading: !0
					});
					return new Nt(b, S)
				}

				function C(P, b, S, A, G, J) {
					let $ = Object.keys(P),
						le = [];
					for (let N = 0, pe = $.length; N < pe; N++) {
						let Q = $[N],
							he = P[Q];
						switch (V(Q, A)) {
							case "material":
								let Ee = A.resources.basematerials[Q],
									ie = I(Ee, he, b, S, A, G, J);
								for (let Pe = 0, Ke = ie.length; Pe < Ke; Pe++) le.push(ie[Pe]);
								break;
							case "texture":
								let q = A.resources.texture2dgroup[Q];
								le.push(w(q, he, b, S, A, G, J));
								break;
							case "vertexColors":
								let Me = A.resources.colorgroup[Q];
								le.push(L(Me, he, b, J));
								break;
							case "default":
								le.push(T(b));
								break;
							default:
								console.error("THREE.3MFLoader: Unsupported resource type.")
						}
					}
					if (J.name)
						for (let N = 0; N < le.length; N++) le[N].name = J.name;
					return le
				}

				function V(P, b) {
					return b.resources.texture2dgroup[P] !== void 0 ? "texture" : b.resources.basematerials[P] !== void 0 ? "material" : b.resources.colorgroup[P] !== void 0 ? "vertexColors" : P === "default" ? "default" : void 0
				}

				function k(P, b) {
					let S = {},
						A = P.triangleProperties,
						G = b.pid;
					for (let J = 0, $ = A.length; J < $; J++) {
						let le = A[J],
							N = le.pid !== void 0 ? le.pid : G;
						N === void 0 && (N = "default"), S[N] === void 0 && (S[N] = []), S[N].push(le)
					}
					return S
				}

				function F(P, b, S, A, G) {
					let J = new cn,
						$ = k(P, G),
						le = C($, P, b, S, A, G);
					for (let N = 0, pe = le.length; N < pe; N++) J.add(le[N]);
					return J
				}

				function U(P, b, S) {
					if (!P) return;
					let A = [],
						G = Object.keys(P);
					for (let J = 0; J < G.length; J++) {
						let $ = G[J];
						for (let le = 0; le < t.availableExtensions.length; le++) {
							let N = t.availableExtensions[le];
							N.ns === $ && A.push(N)
						}
					}
					for (let J = 0; J < A.length; J++) {
						let $ = A[J];
						$.apply(S, P[$.ns], b)
					}
				}

				function K(P, b, S, A, G, J) {
					return P.build !== void 0 || (P.build = J(P, b, S, A, G)), P.build
				}

				function Z(P, b, S) {
					let A, G = P.displaypropertiesid,
						J = S.resources.pbmetallicdisplayproperties;
					if (G !== null && J[G] !== void 0) {
						let pe = J[G].data[P.index];
						A = new cs({
							flatShading: !0,
							roughness: pe.roughness,
							metalness: pe.metallicness
						})
					} else A = new Xt({
						flatShading: !0
					});
					A.name = P.name;
					let $ = P.displaycolor,
						le = $.substring(0, 7);
					return A.color.setStyle(le, Dd), $.length === 9 && (A.opacity = parseInt($.charAt(7) + $.charAt(8), 16) / 255), A
				}

				function Y(P, b, S, A) {
					let G = new cn;
					for (let J = 0; J < P.length; J++) {
						let $ = P[J],
							le = b[$.objectId];
						le === void 0 && (H($.objectId, b, S, A), le = b[$.objectId]);
						let N = le.clone(),
							pe = $.transform;
						pe && N.applyMatrix4(pe), G.add(N)
					}
					return G
				}

				function H(P, b, S, A) {
					let G = S.resources.object[P];
					if (G.mesh) {
						let J = G.mesh,
							$ = S.extensions,
							le = S.xml;
						U($, J, le), b[G.id] = K(J, b, S, A, G, F)
					} else {
						let J = G.components;
						b[G.id] = K(J, b, S, A, G, Y)
					}
					G.name && (b[G.id].name = G.name)
				}

				function oe(P) {
					let b = P.model,
						S = P.modelRels,
						A = {},
						G = Object.keys(b),
						J = {};
					if (S)
						for (let $ = 0, le = S.length; $ < le; $++) {
							let N = S[$],
								pe = N.target.substring(1);
							P.texture[pe] && (J[N.target] = P.texture[pe])
						}
					for (let $ = 0; $ < G.length; $++) {
						let le = G[$],
							N = b[le],
							pe = Object.keys(N.resources.object);
						for (let Q = 0; Q < pe.length; Q++) {
							let he = pe[Q];
							H(he, A, N, J)
						}
					}
					return A
				}

				function de(P) {
					for (let b = 0; b < P.length; b++) {
						let S = P[b];
						if (S.target.split(".").pop().toLowerCase() === "model") return S
					}
				}

				function te(P, b) {
					let S = new cn,
						A = de(b.rels),
						G = b.model[A.target.substring(1)].build;
					for (let J = 0; J < G.length; J++) {
						let $ = G[J],
							le = P[$.objectId].clone(),
							N = $.transform;
						N && le.applyMatrix4(N), S.add(le)
					}
					return S
				}
				let fe = i(e),
					me = oe(fe);
				return te(me, fe)
			}
			addExtension(e) {
				this.availableExtensions.push(e)
			}
		};
	var lh = class extends Ot {
		constructor(e) {
			super(e)
		}
		load(e, t, n, i) {
			let s = this,
				o = new jn(s.manager);
			o.setPath(s.path), o.setResponseType("arraybuffer"), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
				try {
					t(s.parse(a))
				} catch (l) {
					i ? i(l) : console.error(l), s.manager.itemError(e)
				}
			}, n, i)
		}
		parse(e) {
			function t(x) {
				let M = new DataView(x);
				if (String.fromCharCode(M.getUint8(0), M.getUint8(1)) === "PK") {
					let T = null,
						C = null;
					console.log("THREE.AMFLoader: Loading Zip");
					try {
						T = Yu(new Uint8Array(x))
					} catch (V) {
						if (V instanceof ReferenceError) return console.log("THREE.AMFLoader: fflate missing and file is compressed."), null
					}
					for (C in T)
						if (C.toLowerCase().slice(-4) === ".amf") break;
					console.log("THREE.AMFLoader: Trying to load file asset: " + C), M = new DataView(T[C].buffer)
				}
				let w = new TextDecoder().decode(M),
					L = new DOMParser().parseFromString(w, "application/xml");
				return L.documentElement.nodeName.toLowerCase() !== "amf" ? (console.log("THREE.AMFLoader: Error loading AMF - no AMF document found."), null) : L
			}

			function n(x) {
				let M = 1,
					I = "millimeter";
				x.documentElement.attributes.unit !== void 0 && (I = x.documentElement.attributes.unit.value.toLowerCase());
				let w = {
					millimeter: 1,
					inch: 25.4,
					feet: 304.8,
					meter: 1e3,
					micron: .001
				};
				return w[I] !== void 0 && (M = w[I]), console.log("THREE.AMFLoader: Unit scale: " + M), M
			}

			function i(x) {
				let M = "AMF Material",
					I = x.attributes.id.textContent,
					w = {
						r: 1,
						g: 1,
						b: 1,
						a: 1
					},
					L = null;
				for (let T = 0; T < x.childNodes.length; T++) {
					let C = x.childNodes[T];
					C.nodeName === "metadata" && C.attributes.type !== void 0 ? C.attributes.type.value === "name" && (M = C.textContent) : C.nodeName === "color" && (w = s(C))
				}
				return L = new Xt({
					flatShading: !0,
					color: new qe(w.r, w.g, w.b),
					name: M
				}), w.a !== 1 && (L.transparent = !0, L.opacity = w.a), {
					id: I,
					material: L
				}
			}

			function s(x) {
				let M = {
					r: 1,
					g: 1,
					b: 1,
					a: 1
				};
				for (let I = 0; I < x.childNodes.length; I++) {
					let w = x.childNodes[I];
					w.nodeName === "r" ? M.r = w.textContent : w.nodeName === "g" ? M.g = w.textContent : w.nodeName === "b" ? M.b = w.textContent : w.nodeName === "a" && (M.a = w.textContent)
				}
				return M
			}

			function o(x) {
				let M = {
						name: "",
						triangles: [],
						materialid: null
					},
					I = x.firstElementChild;
				for (x.attributes.materialid !== void 0 && (M.materialId = x.attributes.materialid.nodeValue); I;) {
					if (I.nodeName === "metadata") I.attributes.type !== void 0 && I.attributes.type.value === "name" && (M.name = I.textContent);
					else if (I.nodeName === "triangle") {
						let w = I.getElementsByTagName("v1")[0].textContent,
							L = I.getElementsByTagName("v2")[0].textContent,
							T = I.getElementsByTagName("v3")[0].textContent;
						M.triangles.push(w, L, T)
					}
					I = I.nextElementSibling
				}
				return M
			}

			function a(x) {
				let M = [],
					I = [],
					w = x.firstElementChild;
				for (; w;) {
					if (w.nodeName === "vertex") {
						let L = w.firstElementChild;
						for (; L;) {
							if (L.nodeName === "coordinates") {
								let T = L.getElementsByTagName("x")[0].textContent,
									C = L.getElementsByTagName("y")[0].textContent,
									V = L.getElementsByTagName("z")[0].textContent;
								M.push(T, C, V)
							} else if (L.nodeName === "normal") {
								let T = L.getElementsByTagName("nx")[0].textContent,
									C = L.getElementsByTagName("ny")[0].textContent,
									V = L.getElementsByTagName("nz")[0].textContent;
								I.push(T, C, V)
							}
							L = L.nextElementSibling
						}
					}
					w = w.nextElementSibling
				}
				return {
					vertices: M,
					normals: I
				}
			}

			function l(x) {
				let M = x.attributes.id.textContent,
					I = {
						name: "amfobject",
						meshes: []
					},
					w = null,
					L = x.firstElementChild;
				for (; L;) {
					if (L.nodeName === "metadata") L.attributes.type !== void 0 && L.attributes.type.value === "name" && (I.name = L.textContent);
					else if (L.nodeName === "color") w = s(L);
					else if (L.nodeName === "mesh") {
						let T = L.firstElementChild,
							C = {
								vertices: [],
								normals: [],
								volumes: [],
								color: w
							};
						for (; T;) {
							if (T.nodeName === "vertices") {
								let V = a(T);
								C.normals = C.normals.concat(V.normals), C.vertices = C.vertices.concat(V.vertices)
							} else T.nodeName === "volume" && C.volumes.push(o(T));
							T = T.nextElementSibling
						}
						I.meshes.push(C)
					}
					L = L.nextElementSibling
				}
				return {
					id: M,
					obj: I
				}
			}
			let c = t(e),
				u = "",
				h = "",
				f = n(c),
				m = {},
				g = {},
				y = c.documentElement.childNodes,
				d, p;
			for (d = 0; d < y.length; d++) {
				let x = y[d];
				if (x.nodeName === "metadata") x.attributes.type !== void 0 && (x.attributes.type.value === "name" ? u = x.textContent : x.attributes.type.value === "author" && (h = x.textContent));
				else if (x.nodeName === "material") {
					let M = i(x);
					m[M.id] = M.material
				} else if (x.nodeName === "object") {
					let M = l(x);
					g[M.id] = M.obj
				}
			}
			let _ = new cn,
				v = new Xt({
					name: Ot.DEFAULT_MATERIAL_NAME,
					color: 11184895,
					flatShading: !0
				});
			_.name = u, _.userData.author = h, _.userData.loader = "AMF";
			for (let x in g) {
				let M = g[x],
					I = M.meshes,
					w = new cn;
				for (w.name = M.name || "", d = 0; d < I.length; d++) {
					let L = v,
						T = I[d],
						C = new ze(T.vertices, 3),
						V = null;
					if (T.normals.length && (V = new ze(T.normals, 3)), T.color) {
						let F = T.color;
						L = v.clone(), L.color = new qe(F.r, F.g, F.b), F.a !== 1 && (L.transparent = !0, L.opacity = F.a)
					}
					let k = T.volumes;
					for (p = 0; p < k.length; p++) {
						let F = k[p],
							U = new St,
							K = L;
						U.setIndex(F.triangles), U.setAttribute("position", C.clone()), V && U.setAttribute("normal", V.clone()), m[F.materialId] !== void 0 && (K = m[F.materialId]), U.scale(f, f, f), w.add(new Nt(U, K.clone()))
					}
				}
				_.add(w)
			}
			return _
		}
	};
	var Zi = class extends Vt {
			constructor() {
				super(), this.colorConverter = null
			}
			CreateLoader(e) {
				return null
			}
			GetMainObject(e) {
				return e
			}
			IsMeshVisible(e) {
				return !0
			}
			ClearContent() {
				this.loader = null, this.materialIdToIndex = null, this.objectUrlToFileName = null
			}
			ResetContent() {
				this.loader = null, this.materialIdToIndex = new Map, this.objectUrlToFileName = new Map
			}
			ImportContent(e, t) {
				this.LoadModel(e, t)
			}
			LoadModel(e, t) {
				let n = !1,
					i = new Bl(() => {
						n = !0
					}),
					s = ws(e);
				i.setURLModifier(a => {
					if (a === s) return a;
					let l = vn(a);
					if (er(a).length > 0) {
						let u = this.callbacks.getFileBuffer(a);
						if (u !== null) {
							let h = ws(u);
							return this.objectUrlToFileName.set(h, l), h
						}
					}
					return a
				});
				let o = this.CreateLoader(i);
				if (o === null) {
					t();
					return
				}
				o.load(s, a => {
					_c(() => n ? (this.OnThreeObjectsLoaded(a, t), !1) : !0)
				}, () => {}, a => {
					this.SetError(a), t()
				})
			}
			OnThreeObjectsLoaded(e, t) {
				function n(a) {
					let l = new ln().CreateIdentity();
					return a.updateMatrix(), a.matrix !== void 0 && a.matrix !== null && l.Set(a.matrix.elements), new rn(l)
				}

				function i(a, l, c, u) {
					let h = new Sn;
					c.name !== void 0 && h.SetName(c.name), h.SetTransformation(n(c)), u.AddChildNode(h);
					for (let f of c.children) i(a, l, f, h);
					if (c.isMesh && a.IsMeshVisible(c)) {
						let f = a.ConvertThreeMesh(c),
							m = l.AddMesh(f);
						h.AddMeshIndex(m)
					}
				}
				let s = this.GetMainObject(e),
					o = this.model.GetRootNode();
				o.SetTransformation(n(s));
				for (let a of s.children) i(this, this.model, a, o);
				t()
			}
			ConvertThreeMesh(e) {
				let t = null;
				if (Array.isArray(e.material)) {
					if (t = Wi(e.geometry, null, this.colorConverter), e.geometry.attributes.color === void 0 || e.geometry.attributes.color === null) {
						let n = [];
						for (let i = 0; i < e.material.length; i++) {
							let s = e.material[i],
								o = this.FindOrCreateMaterial(s);
							n.push(o)
						}
						for (let i = 0; i < e.geometry.groups.length; i++) {
							let s = e.geometry.groups[i],
								o = null;
							s.count === 1 / 0 ? o = t.TriangleCount() : o = s.start / 3 + s.count / 3;
							for (let a = s.start / 3; a < o; a++) t.GetTriangle(a).SetMaterial(n[s.materialIndex])
						}
					}
				} else {
					let n = this.FindOrCreateMaterial(e.material);
					t = Wi(e.geometry, n, this.colorConverter)
				}
				return e.name !== void 0 && e.name !== null && t.SetName(e.name), t
			}
			FindOrCreateMaterial(e) {
				if (this.materialIdToIndex.has(e.id)) return this.materialIdToIndex.get(e.id);
				let t = this.ConvertThreeMaterial(e),
					n = null;
				return t !== null && (n = this.model.AddMaterial(t)), this.materialIdToIndex.set(e.id, n), n
			}
			ConvertThreeMaterial(e) {
				function t(i, s) {
					function o(a) {
						if (a.data !== void 0 && a.data !== null) {
							let l = new ImageData(a.width, a.height),
								c = a.width * a.height * 4;
							for (let u = 0; u < c; u++) l.data[u] = a.data[u];
							return Hs.getDataURL(l)
						} else return Hs.getDataURL(a)
					}
					if (i == null || i.image === void 0 || i.image === null) return null;
					try {
						let a = o(i.image),
							l = As(a),
							c = new Jn,
							u = null;
						return s.has(i.image.src) ? u = s.get(i.image.src) : i.name !== void 0 && i.name !== null ? u = i.name + "." + Yr(l.mimeType) : u = "Embedded_" + i.id.toString() + "." + Yr(l.mimeType), c.name = u, c.mimeType = l.mimeType, c.buffer = l.buffer, c.rotation = i.rotation, c.offset.x = i.offset.x, c.offset.y = i.offset.y, c.scale.x = i.repeat.x, c.scale.y = i.repeat.y, c
					} catch {
						return null
					}
				}
				if (e.name === Ot.DEFAULT_MATERIAL_NAME) return null;
				let n = new hn;
				return n.name = e.name, n.color = this.ConvertThreeColor(e.color), n.opacity = e.opacity, n.transparent = e.transparent, n.alphaTest = e.alphaTest, e.type === "MeshPhongMaterial" && (n.specular = this.ConvertThreeColor(e.specular), n.shininess = e.shininess / 100), n.diffuseMap = t(e.map, this.objectUrlToFileName), n.normalMap = t(e.normalMap, this.objectUrlToFileName), n.bumpMap = t(e.bumpMap, this.objectUrlToFileName), n
			}
			ConvertThreeColor(e) {
				return this.colorConverter !== null && (e = this.colorConverter.Convert(e)), Vl(e)
			}
		},
		Pa = class extends Zi {
			constructor() {
				super(), this.colorConverter = new Js
			}
			CanImportExtension(e) {
				return e === "fbx"
			}
			GetUpDirection() {
				return ht.Y
			}
			CreateLoader(e) {
				return e.addHandler(/\.tga$/i, new gs(e)), new Ju(e)
			}
			GetMainObject(e) {
				return e
			}
		},
		La = class extends Zi {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "dae"
			}
			GetUpDirection() {
				return ht.Y
			}
			CreateLoader(e) {
				return e.addHandler(/\.tga$/i, new gs(e)), new eh(e)
			}
			GetMainObject(e) {
				return e.scene
			}
		},
		Na = class extends Zi {
			constructor() {
				super(), this.colorConverter = new Js
			}
			CanImportExtension(e) {
				return e === "wrl"
			}
			GetUpDirection() {
				return ht.Y
			}
			CreateLoader(e) {
				return new oh(e)
			}
			GetMainObject(e) {
				return e
			}
			IsMeshVisible(e) {
				let t = !0;
				if (Array.isArray(e.material)) {
					for (let n = 0; n < e.material.length; n++)
						if (e.material[n].side === gn) {
							t = !1;
							break
						}
				} else t = e.material.side !== gn;
				return t
			}
		},
		Oa = class extends Zi {
			constructor() {
				super(), this.colorConverter = new va
			}
			CanImportExtension(e) {
				return e === "3mf"
			}
			GetUpDirection() {
				return ht.Z
			}
			CreateLoader(e) {
				return new ah(e)
			}
			GetMainObject(e) {
				return e
			}
		},
		Da = class extends Zi {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "amf"
			}
			GetUpDirection() {
				return ht.Z
			}
			CreateLoader(e) {
				return new lh(e)
			}
			GetMainObject(e) {
				return e
			}
		};
	var mi = Uint8Array,
		Fa = Uint16Array,
		kb = Int32Array,
		y0 = new mi([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
		v0 = new mi([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
		Bb = new mi([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
		x0 = function(r, e) {
			for (var t = new Fa(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
			for (var i = new kb(t[30]), n = 1; n < 30; ++n)
				for (var s = t[n]; s < t[n + 1]; ++s) i[s] = s - t[n] << 5 | n;
			return {
				b: t,
				r: i
			}
		},
		_0 = x0(y0, 2),
		T0 = _0.b,
		Gb = _0.r;
	T0[28] = 258, Gb[258] = 28;
	var E0 = x0(v0, 0),
		Vb = E0.b,
		jR = E0.r,
		Bd = new Fa(32768);
	for (Ut = 0; Ut < 32768; ++Ut) Hr = (Ut & 43690) >> 1 | (Ut & 21845) << 1, Hr = (Hr & 52428) >> 2 | (Hr & 13107) << 2, Hr = (Hr & 61680) >> 4 | (Hr & 3855) << 4, Bd[Ut] = ((Hr & 65280) >> 8 | (Hr & 255) << 8) >> 1;
	var Hr, Ut, Yl = function(r, e, t) {
			for (var n = r.length, i = 0, s = new Fa(e); i < n; ++i) r[i] && ++s[r[i] - 1];
			var o = new Fa(e);
			for (i = 1; i < e; ++i) o[i] = o[i - 1] + s[i - 1] << 1;
			var a;
			if (t) {
				a = new Fa(1 << e);
				var l = 15 - e;
				for (i = 0; i < n; ++i)
					if (r[i])
						for (var c = i << 4 | r[i], u = e - r[i], h = o[r[i] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h) a[Bd[h] >> l] = c
			} else
				for (a = new Fa(n), i = 0; i < n; ++i) r[i] && (a[i] = Bd[o[r[i] - 1]++] >> 15 - r[i]);
			return a
		},
		Kl = new mi(288);
	for (Ut = 0; Ut < 144; ++Ut) Kl[Ut] = 8;
	var Ut;
	for (Ut = 144; Ut < 256; ++Ut) Kl[Ut] = 9;
	var Ut;
	for (Ut = 256; Ut < 280; ++Ut) Kl[Ut] = 7;
	var Ut;
	for (Ut = 280; Ut < 288; ++Ut) Kl[Ut] = 8;
	var Ut, M0 = new mi(32);
	for (Ut = 0; Ut < 32; ++Ut) M0[Ut] = 5;
	var Ut;
	var zb = Yl(Kl, 9, 1);
	var Hb = Yl(M0, 5, 1),
		Fd = function(r) {
			for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
			return e
		},
		Ji = function(r, e, t) {
			var n = e / 8 | 0;
			return (r[n] | r[n + 1] << 8) >> (e & 7) & t
		},
		Ud = function(r, e) {
			var t = e / 8 | 0;
			return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
		},
		Wb = function(r) {
			return (r + 7) / 8 | 0
		},
		Vd = function(r, e, t) {
			(e == null || e < 0) && (e = 0), (t == null || t > r.length) && (t = r.length);
			var n = new mi(t - e);
			return n.set(r.subarray(e, t)), n
		};
	var Xb = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
		wi = function(r, e, t) {
			var n = new Error(e || Xb[r]);
			if (n.code = r, Error.captureStackTrace && Error.captureStackTrace(n, wi), !t) throw n;
			return n
		},
		qb = function(r, e, t, n) {
			var i = r.length,
				s = n ? n.length : 0;
			if (!i || e.f && !e.l) return t || new mi(0);
			var o = !t || e.i != 2,
				a = e.i;
			t || (t = new mi(i * 3));
			var l = function($) {
					var le = t.length;
					if ($ > le) {
						var N = new mi(Math.max(le * 2, $));
						N.set(t), t = N
					}
				},
				c = e.f || 0,
				u = e.p || 0,
				h = e.b || 0,
				f = e.l,
				m = e.d,
				g = e.m,
				y = e.n,
				d = i * 8;
			do {
				if (!f) {
					c = Ji(r, u, 1);
					var p = Ji(r, u + 1, 3);
					if (u += 3, p)
						if (p == 1) f = zb, m = Hb, g = 9, y = 5;
						else if (p == 2) {
						var M = Ji(r, u, 31) + 257,
							I = Ji(r, u + 10, 15) + 4,
							w = M + Ji(r, u + 5, 31) + 1;
						u += 14;
						for (var L = new mi(w), T = new mi(19), C = 0; C < I; ++C) T[Bb[C]] = Ji(r, u + C * 3, 7);
						u += I * 3;
						for (var V = Fd(T), k = (1 << V) - 1, F = Yl(T, V, 1), C = 0; C < w;) {
							var U = F[Ji(r, u, k)];
							u += U & 15;
							var _ = U >> 4;
							if (_ < 16) L[C++] = _;
							else {
								var K = 0,
									Z = 0;
								for (_ == 16 ? (Z = 3 + Ji(r, u, 3), u += 2, K = L[C - 1]) : _ == 17 ? (Z = 3 + Ji(r, u, 7), u += 3) : _ == 18 && (Z = 11 + Ji(r, u, 127), u += 7); Z--;) L[C++] = K
							}
						}
						var Y = L.subarray(0, M),
							H = L.subarray(M);
						g = Fd(Y), y = Fd(H), f = Yl(Y, g, 1), m = Yl(H, y, 1)
					} else wi(1);
					else {
						var _ = Wb(u) + 4,
							v = r[_ - 4] | r[_ - 3] << 8,
							x = _ + v;
						if (x > i) {
							a && wi(0);
							break
						}
						o && l(h + v), t.set(r.subarray(_, x), h), e.b = h += v, e.p = u = x * 8, e.f = c;
						continue
					}
					if (u > d) {
						a && wi(0);
						break
					}
				}
				o && l(h + 131072);
				for (var oe = (1 << g) - 1, de = (1 << y) - 1, te = u;; te = u) {
					var K = f[Ud(r, u) & oe],
						fe = K >> 4;
					if (u += K & 15, u > d) {
						a && wi(0);
						break
					}
					if (K || wi(2), fe < 256) t[h++] = fe;
					else if (fe == 256) {
						te = u, f = null;
						break
					} else {
						var me = fe - 254;
						if (fe > 264) {
							var C = fe - 257,
								P = y0[C];
							me = Ji(r, u, (1 << P) - 1) + T0[C], u += P
						}
						var b = m[Ud(r, u) & de],
							S = b >> 4;
						b || wi(3), u += b & 15;
						var H = Vb[S];
						if (S > 3) {
							var P = v0[S];
							H += Ud(r, u) & (1 << P) - 1, u += P
						}
						if (u > d) {
							a && wi(0);
							break
						}
						o && l(h + 131072);
						var A = h + me;
						if (h < H) {
							var G = s - H,
								J = Math.min(H, A);
							for (G + h < 0 && wi(3); h < J; ++h) t[h] = n[G + h]
						}
						for (; h < A; h += 4) t[h] = t[h - H], t[h + 1] = t[h + 1 - H], t[h + 2] = t[h + 2 - H], t[h + 3] = t[h + 3 - H];
						h = A
					}
				}
				e.l = f, e.p = te, e.b = h, e.f = c, f && (c = 1, e.m = g, e.d = m, e.n = y)
			} while (!c);
			return h == t.length ? t : Vd(t, 0, h)
		};
	var jb = new mi(0);
	var mr = function(r, e) {
			return r[e] | r[e + 1] << 8
		},
		$i = function(r, e) {
			return (r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24) >>> 0
		},
		kd = function(r, e) {
			return $i(r, e) + $i(r, e + 4) * 4294967296
		};

	function Yb(r, e) {
		return qb(r, {
			i: 2
		}, e && e.out, e && e.dictionary)
	}
	var Gd = typeof TextDecoder < "u" && new TextDecoder,
		Kb = 0;
	try {
		Gd.decode(jb, {
			stream: !0
		}), Kb = 1
	} catch {}
	var Zb = function(r) {
		for (var e = "", t = 0;;) {
			var n = r[t++],
				i = (n > 127) + (n > 223) + (n > 239);
			if (t + i > r.length) return {
				s: e,
				r: Vd(r, t - 1)
			};
			i ? i == 3 ? (n = ((n & 15) << 18 | (r[t++] & 63) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) - 65536, e += String.fromCharCode(55296 | n >> 10, 56320 | n & 1023)) : i & 1 ? e += String.fromCharCode((n & 31) << 6 | r[t++] & 63) : e += String.fromCharCode((n & 15) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) : e += String.fromCharCode(n)
		}
	};

	function Jb(r, e) {
		if (e) {
			for (var t = "", n = 0; n < r.length; n += 16384) t += String.fromCharCode.apply(null, r.subarray(n, n + 16384));
			return t
		} else {
			if (Gd) return Gd.decode(r);
			var i = Zb(r),
				s = i.s,
				t = i.r;
			return t.length && wi(8), s
		}
	}
	var $b = function(r, e) {
			return e + 30 + mr(r, e + 26) + mr(r, e + 28)
		},
		Qb = function(r, e, t) {
			var n = mr(r, e + 28),
				i = Jb(r.subarray(e + 46, e + 46 + n), !(mr(r, e + 8) & 2048)),
				s = e + 46 + n,
				o = $i(r, e + 20),
				a = t && o == 4294967295 ? eS(r, s) : [o, $i(r, e + 24), $i(r, e + 42)],
				l = a[0],
				c = a[1],
				u = a[2];
			return [mr(r, e + 10), l, c, i, s + mr(r, e + 30) + mr(r, e + 32), u]
		},
		eS = function(r, e) {
			for (; mr(r, e) != 1; e += 4 + mr(r, e + 2));
			return [kd(r, e + 12), kd(r, e + 4), kd(r, e + 20)]
		};

	function ch(r, e) {
		for (var t = {}, n = r.length - 22; $i(r, n) != 101010256; --n)(!n || r.length - n > 65558) && wi(13);
		var i = mr(r, n + 8);
		if (!i) return {};
		var s = $i(r, n + 16),
			o = s == 4294967295 || i == 65535;
		if (o) {
			var a = $i(r, n - 12);
			o = $i(r, a) == 101075792, o && (i = $i(r, a + 32), s = $i(r, a + 48))
		}
		for (var l = e && e.filter, c = 0; c < i; ++c) {
			var u = Qb(r, s, o),
				h = u[0],
				f = u[1],
				m = u[2],
				g = u[3],
				y = u[4],
				d = u[5],
				p = $b(r, d);
			s = y, (!l || l({
				name: g,
				size: f,
				originalSize: m,
				compression: h
			})) && (h ? h == 8 ? t[g] = Yb(r.subarray(p, p + f), {
				out: new mi(m)
			}) : wi(14, "unknown compression type " + h) : t[g] = Vd(r, p, p + f))
		}
		return t
	}
	var zd = {
			Success: 0,
			NoDocumentXml: 1
		},
		Hd = class {
			constructor(e, t) {
				this.name = e, this.type = t, this.shapeName = null, this.isVisible = !1, this.color = null, this.fileName = null, this.fileContent = null, this.inLinkCount = 0, this.properties = null
			}
			IsConvertible() {
				return !(this.fileName === null || this.fileContent === null || !this.isVisible || this.inLinkCount > 0)
			}
		},
		Wd = class {
			constructor() {
				this.files = null, this.properties = null, this.objectNames = [], this.objectData = new Map
			}
			Init(e) {
				let t = new Uint8Array(e);
				return this.files = ch(t), this.LoadDocumentXml() ? (this.LoadGuiDocumentXml(), zd.Success) : zd.NoDocumentXml
			}
			GetObjectListToConvert() {
				let e = [];
				for (let t of this.objectNames) {
					let n = this.objectData.get(t);
					n.IsConvertible() && e.push(n)
				}
				return e
			}
			IsSupportedType(e) {
				return !(!e.startsWith("Part::") && !e.startsWith("PartDesign::") || e.indexOf("Part2D") !== -1)
			}
			HasFile(e) {
				return e in this.files
			}
			LoadDocumentXml() {
				let e = this.GetXMLContent("Document.xml");
				if (e === null) return !1;
				this.properties = new Fn("Properties");
				let t = e.getElementsByTagName("Document");
				for (let s of t)
					for (let o of s.childNodes) o.tagName === "Properties" && this.GetPropertiesFromElement(o, this.properties);
				let n = e.getElementsByTagName("Objects");
				for (let s of n) {
					let o = s.getElementsByTagName("Object");
					for (let a of o) {
						let l = a.getAttribute("name"),
							c = a.getAttribute("type");
						if (!this.IsSupportedType(c)) continue;
						let u = new Hd(l, c);
						this.objectNames.push(l), this.objectData.set(l, u)
					}
				}
				let i = e.getElementsByTagName("ObjectData");
				for (let s of i) {
					let o = s.getElementsByTagName("Object");
					for (let a of o) {
						let l = a.getAttribute("name");
						if (!this.objectData.has(l)) continue;
						let c = this.objectData.get(l);
						c.properties = new Fn("Properties");
						for (let f of a.childNodes) f.tagName === "Properties" && this.GetPropertiesFromElement(f, c.properties);
						let u = a.getElementsByTagName("Property");
						for (let f of u) {
							let m = f.getAttribute("name");
							if (m === "Label") c.shapeName = this.GetFirstChildValue(f, "String", "value");
							else if (m === "Visibility") {
								let g = this.GetFirstChildValue(f, "Bool", "value");
								c.isVisible = g === "true"
							} else if (m === "Visible") {
								let g = this.GetFirstChildValue(f, "Bool", "value");
								c.isVisible = g === "true"
							} else if (m === "Shape") {
								let g = this.GetFirstChildValue(f, "Part", "file");
								if (!this.HasFile(g)) continue;
								let y = er(g);
								if (y !== "brp" && y !== "brep") continue;
								c.fileName = g, c.fileContent = this.files[g]
							}
						}
						let h = a.getElementsByTagName("Link");
						for (let f of h) {
							let m = f.getAttribute("value");
							if (this.objectData.has(m)) {
								let g = this.objectData.get(m);
								g.inLinkCount += 1
							}
						}
					}
				}
				return !0
			}
			LoadGuiDocumentXml() {
				let e = this.GetXMLContent("GuiDocument.xml");
				if (e === null) return !1;
				let t = e.getElementsByTagName("ViewProvider");
				for (let n of t) {
					let i = n.getAttribute("name");
					if (!this.objectData.has(i)) continue;
					let s = this.objectData.get(i),
						o = n.getElementsByTagName("Property");
					for (let a of o) {
						let l = a.getAttribute("name");
						if (l === "Visibility") {
							let c = this.GetFirstChildValue(a, "Bool", "value");
							s.isVisible = c === "true"
						} else if (l === "ShapeColor") {
							let c = this.GetFirstChildValue(a, "PropertyColor", "value"),
								u = parseInt(c, 10);
							s.color = new Er(u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255)
						}
					}
				}
				return !0
			}
			GetPropertiesFromElement(e, t) {
				let n = e.getElementsByTagName("Property");
				for (let i of n) {
					let s = i.getAttribute("name"),
						o = i.getAttribute("type"),
						a = null;
					if (o === "App::PropertyBool") {
						let l = this.GetFirstChildValue(i, "String", "bool");
						l !== null && l.length > 0 && (a = new Jt(Bt.Boolean, s, l === "true"))
					} else if (o === "App::PropertyInteger") {
						let l = this.GetFirstChildValue(i, "Integer", "value");
						l !== null && l.length > 0 && (a = new Jt(Bt.Integer, s, parseInt(l)))
					} else if (o === "App::PropertyString") {
						let l = this.GetFirstChildValue(i, "String", "value");
						l !== null && l.length > 0 && (a = new Jt(Bt.Text, s, l))
					} else if (o === "App::PropertyUUID") {
						let l = this.GetFirstChildValue(i, "Uuid", "value");
						l !== null && l.length > 0 && (a = new Jt(Bt.Text, s, l))
					} else if (o === "App::PropertyFloat" || o === "App::PropertyLength" || o === "App::PropertyDistance" || o === "App::PropertyArea" || o === "App::PropertyVolume") {
						let l = this.GetFirstChildValue(i, "Float", "value");
						l !== null && l.length > 0 && (a = new Jt(Bt.Number, s, parseFloat(l)))
					}
					a !== null && t.AddProperty(a)
				}
			}
			GetXMLContent(e) {
				if (!this.HasFile(e)) return null;
				let t = new DOMParser,
					n = fn(this.files[e]);
				return t.parseFromString(n, "text/xml")
			}
			GetFirstChildValue(e, t, n) {
				let i = e.getElementsByTagName(t);
				return i.length === 0 ? null : i[0].getAttribute(n)
			}
		},
		Ua = class extends Vt {
			constructor() {
				super(), this.worker = null, this.document = null
			}
			CanImportExtension(e) {
				return e === "fcstd"
			}
			GetUpDirection() {
				return ht.Z
			}
			ClearContent() {
				this.worker !== null && (this.worker.terminate(), this.worker = null), this.document = null
			}
			ResetContent() {
				this.worker = null, this.document = new Wd
			}
			ImportContent(e, t) {
				if (this.document.Init(e) === zd.NoDocumentXml) {
					this.SetError("No Document.xml found."), t();
					return
				}
				this.document.properties !== null && this.document.properties.PropertyCount() > 0 && this.model.AddPropertyGroup(this.document.properties);
				let i = this.document.GetObjectListToConvert();
				if (i.length === 0) {
					this.SetError("No importable object found."), t();
					return
				}
				this.ConvertObjects(i, t)
			}
			ConvertObjects(e, t) {
				let n = Es("loaders/occt-import-js-worker.js");
				this.worker = new Worker(n);
				let i = 0,
					s = new ti(this.model),
					o = l => {
						if (l !== null) {
							let c = e[i];
							this.OnFileConverted(c, l, s)
						}
						if (i += 1, i === e.length) t();
						else {
							let c = e[i];
							this.worker.postMessage({
								format: "brep",
								buffer: c.fileContent
							})
						}
					};
				this.worker.addEventListener("message", l => {
					o(l.data)
				}), this.worker.addEventListener("error", l => {
					o(null)
				});
				let a = e[i];
				this.worker.postMessage({
					format: "brep",
					buffer: a.fileContent
				})
			}
			OnFileConverted(e, t, n) {
				if (!t.success || t.meshes.length === 0) return;
				let i = new Sn;
				e.shapeName !== null && i.SetName(e.shapeName);
				let s = 1;
				for (let a of t.meshes) {
					let l = null;
					e.color !== null && (l = n.GetMaterialIndex(e.color.r, e.color.g, e.color.b, e.color.a));
					let c = Wi(a, l, null);
					if (e.shapeName !== null) {
						let h = s.toString().padStart(3, "0");
						c.SetName(e.shapeName + " " + h)
					}
					e.properties !== null && e.properties.PropertyCount() > 0 && c.AddPropertyGroup(e.properties);
					let u = this.model.AddMesh(c);
					i.AddMeshIndex(u), s += 1
				}
				this.model.GetRootNode().AddChildNode(i)
			}
		};
	var ka = class {
			constructor() {
				this.defaultColor = new Et(200, 200, 200)
			}
		},
		gr = {
			NoImportableFile: 1,
			FailedToLoadFile: 2,
			ImportFailed: 3,
			UnknownError: 4
		},
		vs = class {
			constructor(e) {
				this.code = e, this.mainFile = null, this.message = null
			}
		},
		Zl = class {
			constructor() {
				this.model = null, this.mainFile = null, this.upVector = null, this.usedFiles = null, this.missingFiles = null
			}
		},
		Jl = class {
			constructor(e) {
				this.getBufferCallback = e, this.fileBuffers = new Map
			}
			GetFileBuffer(e) {
				let t = vn(e);
				if (this.fileBuffers.has(t)) return this.fileBuffers.get(t);
				let n = this.getBufferCallback(t);
				return this.fileBuffers.set(t, n), n
			}
		},
		Ba = class {
			constructor() {
				this.importers = [new Ma, new wa, new ba, new Sa, new _a, new Ta, new Ca, new xa, new Ea, new Aa, new Ua, new Pa, new La, new Na, new Oa, new Da], this.fileList = new Ps, this.model = null, this.usedFiles = [], this.missingFiles = []
			}
			AddImporter(e) {
				this.importers.push(e)
			}
			ImportFiles(e, t, n) {
				n.onLoadStart(), this.LoadFiles(e, {
					onReady: () => {
						n.onImportStart(), $a(() => {
							this.DecompressArchives(this.fileList, () => {
								this.ImportLoadedFiles(t, n)
							})
						})
					},
					onFileListProgress: n.onFileListProgress,
					onFileLoadProgress: n.onFileLoadProgress
				})
			}
			LoadFiles(e, t) {
				let n = new Ps;
				n.FillFromInputFiles(e);
				let i = !1;
				if (this.HasImportableFile(n)) i = !0;
				else {
					let s = !1;
					for (let o = 0; o < this.missingFiles.length; o++) {
						let a = this.missingFiles[o];
						n.ContainsFileByPath(a) && (s = !0)
					}
					s ? (this.fileList.ExtendFromFileList(n), i = !1) : i = !0
				}
				i && (this.fileList = n), this.fileList.GetContent({
					onReady: t.onReady,
					onFileListProgress: t.onFileListProgress,
					onFileLoadProgress: t.onFileLoadProgress
				})
			}
			ImportLoadedFiles(e, t) {
				let n = this.GetImportableFiles(this.fileList);
				if (n.length === 0) {
					t.onImportError(new vs(gr.NoImportableFile));
					return
				}
				if (n.length === 1 || !t.onSelectMainFile) {
					let i = n[0];
					this.ImportLoadedMainFile(i, e, t)
				} else {
					let i = n.map(s => s.file.name);
					t.onSelectMainFile(i, s => {
						if (s === null) {
							t.onImportError(new vs(gr.NoImportableFile));
							return
						}
						$a(() => {
							let o = n[s];
							this.ImportLoadedMainFile(o, e, t)
						})
					})
				}
			}
			ImportLoadedMainFile(e, t, n) {
				if (e === null || e.file === null || e.file.content === null) {
					let o = new vs(gr.FailedToLoadFile);
					e !== null && e.file !== null && (o.mainFile = e.file.name), n.onImportError(o);
					return
				}
				this.model = null, this.usedFiles = [], this.missingFiles = [], this.usedFiles.push(e.file.name);
				let i = e.importer,
					s = new Jl(o => {
						let a = null,
							l = this.fileList.FindFileByPath(o);
						return l === null || l.content === null ? (this.missingFiles.push(o), a = null) : (this.usedFiles.push(o), a = l.content), a
					});
				i.Import(e.file.name, e.file.extension, e.file.content, {
					getDefaultMaterialColor: () => t.defaultColor,
					getFileBuffer: o => s.GetFileBuffer(o),
					onSuccess: () => {
						this.model = i.GetModel();
						let o = new Zl;
						o.mainFile = e.file.name, o.model = this.model, o.usedFiles = this.usedFiles, o.missingFiles = this.missingFiles, o.upVector = i.GetUpDirection(), n.onImportSuccess(o)
					},
					onError: () => {
						let o = new vs(gr.ImportFailed);
						o.mainFile = e.file.name, o.message = i.GetErrorMessage(), n.onImportError(o)
					},
					onComplete: () => {
						i.Clear()
					}
				})
			}
			DecompressArchives(e, t) {
				let n = e.GetFiles(),
					i = [];
				for (let s of n) s.extension === "zip" && i.push(s);
				if (i.length === 0) {
					t();
					return
				}
				for (let s = 0; s < i.length; s++) {
					let o = i[s],
						a = new Uint8Array(o.content),
						l = ch(a);
					for (let c in l)
						if (Object.prototype.hasOwnProperty.call(l, c)) {
							let u = new Is(c, Ii.Decompressed, null);
							u.SetContent(l[c].buffer), e.AddFile(u)
						}
				}
				t()
			}
			GetFileList() {
				return this.fileList
			}
			HasImportableFile(e) {
				return this.GetImportableFiles(e).length > 0
			}
			GetImportableFiles(e) {
				function t(s, o) {
					for (let a = 0; a < o.length; a++) {
						let l = o[a];
						if (l.CanImportExtension(s.extension)) return l
					}
					return null
				}
				let n = [],
					i = e.GetFiles();
				for (let s = 0; s < i.length; s++) {
					let o = i[s],
						a = t(o, this.importers);
					a !== null && n.push({
						file: o,
						importer: a
					})
				}
				return n
			}
		};
	var tS = ot,
		$l = class r extends Ot {
			constructor(e) {
				super(e), this.defaultDPI = 90, this.defaultUnit = "px"
			}
			load(e, t, n, i) {
				let s = this,
					o = new jn(s.manager);
				o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
					try {
						t(s.parse(a))
					} catch (l) {
						i ? i(l) : console.error(l), s.manager.itemError(e)
					}
				}, n, i)
			}
			parse(e) {
				let t = this;

				function n(P, b) {
					if (P.nodeType !== 1) return;
					let S = x(P),
						A = !1,
						G = null;
					switch (P.nodeName) {
						case "svg":
							b = g(P, b);
							break;
						case "style":
							s(P);
							break;
						case "g":
							b = g(P, b);
							break;
						case "path":
							b = g(P, b), P.hasAttribute("d") && (G = i(P));
							break;
						case "rect":
							b = g(P, b), G = l(P);
							break;
						case "polygon":
							b = g(P, b), G = c(P);
							break;
						case "polyline":
							b = g(P, b), G = u(P);
							break;
						case "circle":
							b = g(P, b), G = h(P);
							break;
						case "ellipse":
							b = g(P, b), G = f(P);
							break;
						case "line":
							b = g(P, b), G = m(P);
							break;
						case "defs":
							A = !0;
							break;
						case "use":
							b = g(P, b);
							let le = (P.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1),
								N = P.viewportElement.getElementById(le);
							N ? n(N, b) : console.warn("SVGLoader: 'use node' references non-existent node id: " + le);
							break;
						default:
					}
					G && (b.fill !== void 0 && b.fill !== "none" && G.color.setStyle(b.fill, tS), I(G, te), k.push(G), G.userData = {
						node: P,
						style: b
					});
					let J = P.childNodes;
					for (let $ = 0; $ < J.length; $++) {
						let le = J[$];
						A && le.nodeName !== "style" && le.nodeName !== "defs" || n(le, b)
					}
					S && (U.pop(), U.length > 0 ? te.copy(U[U.length - 1]) : te.identity())
				}

				function i(P) {
					let b = new dr,
						S = new Ce,
						A = new Ce,
						G = new Ce,
						J = !0,
						$ = !1,
						le = P.getAttribute("d");
					if (le === "" || le === "none") return null;
					let N = le.match(/[a-df-z][^a-df-z]*/ig);
					for (let pe = 0, Q = N.length; pe < Q; pe++) {
						let he = N[pe],
							ye = he.charAt(0),
							Ee = he.slice(1).trim();
						J === !0 && ($ = !0, J = !1);
						let ie;
						switch (ye) {
							case "M":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 2) S.x = ie[q + 0], S.y = ie[q + 1], A.x = S.x, A.y = S.y, q === 0 ? b.moveTo(S.x, S.y) : b.lineTo(S.x, S.y), q === 0 && G.copy(S);
								break;
							case "H":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q++) S.x = ie[q], A.x = S.x, A.y = S.y, b.lineTo(S.x, S.y), q === 0 && $ === !0 && G.copy(S);
								break;
							case "V":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q++) S.y = ie[q], A.x = S.x, A.y = S.y, b.lineTo(S.x, S.y), q === 0 && $ === !0 && G.copy(S);
								break;
							case "L":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 2) S.x = ie[q + 0], S.y = ie[q + 1], A.x = S.x, A.y = S.y, b.lineTo(S.x, S.y), q === 0 && $ === !0 && G.copy(S);
								break;
							case "C":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 6) b.bezierCurveTo(ie[q + 0], ie[q + 1], ie[q + 2], ie[q + 3], ie[q + 4], ie[q + 5]), A.x = ie[q + 2], A.y = ie[q + 3], S.x = ie[q + 4], S.y = ie[q + 5], q === 0 && $ === !0 && G.copy(S);
								break;
							case "S":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 4) b.bezierCurveTo(y(S.x, A.x), y(S.y, A.y), ie[q + 0], ie[q + 1], ie[q + 2], ie[q + 3]), A.x = ie[q + 0], A.y = ie[q + 1], S.x = ie[q + 2], S.y = ie[q + 3], q === 0 && $ === !0 && G.copy(S);
								break;
							case "Q":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 4) b.quadraticCurveTo(ie[q + 0], ie[q + 1], ie[q + 2], ie[q + 3]), A.x = ie[q + 0], A.y = ie[q + 1], S.x = ie[q + 2], S.y = ie[q + 3], q === 0 && $ === !0 && G.copy(S);
								break;
							case "T":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 2) {
									let Pe = y(S.x, A.x),
										Ke = y(S.y, A.y);
									b.quadraticCurveTo(Pe, Ke, ie[q + 0], ie[q + 1]), A.x = Pe, A.y = Ke, S.x = ie[q + 0], S.y = ie[q + 1], q === 0 && $ === !0 && G.copy(S)
								}
								break;
							case "A":
								ie = d(Ee, [3, 4], 7);
								for (let q = 0, Me = ie.length; q < Me; q += 7) {
									if (ie[q + 5] == S.x && ie[q + 6] == S.y) continue;
									let Pe = S.clone();
									S.x = ie[q + 5], S.y = ie[q + 6], A.x = S.x, A.y = S.y, o(b, ie[q], ie[q + 1], ie[q + 2], ie[q + 3], ie[q + 4], Pe, S), q === 0 && $ === !0 && G.copy(S)
								}
								break;
							case "m":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 2) S.x += ie[q + 0], S.y += ie[q + 1], A.x = S.x, A.y = S.y, q === 0 ? b.moveTo(S.x, S.y) : b.lineTo(S.x, S.y), q === 0 && G.copy(S);
								break;
							case "h":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q++) S.x += ie[q], A.x = S.x, A.y = S.y, b.lineTo(S.x, S.y), q === 0 && $ === !0 && G.copy(S);
								break;
							case "v":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q++) S.y += ie[q], A.x = S.x, A.y = S.y, b.lineTo(S.x, S.y), q === 0 && $ === !0 && G.copy(S);
								break;
							case "l":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 2) S.x += ie[q + 0], S.y += ie[q + 1], A.x = S.x, A.y = S.y, b.lineTo(S.x, S.y), q === 0 && $ === !0 && G.copy(S);
								break;
							case "c":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 6) b.bezierCurveTo(S.x + ie[q + 0], S.y + ie[q + 1], S.x + ie[q + 2], S.y + ie[q + 3], S.x + ie[q + 4], S.y + ie[q + 5]), A.x = S.x + ie[q + 2], A.y = S.y + ie[q + 3], S.x += ie[q + 4], S.y += ie[q + 5], q === 0 && $ === !0 && G.copy(S);
								break;
							case "s":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 4) b.bezierCurveTo(y(S.x, A.x), y(S.y, A.y), S.x + ie[q + 0], S.y + ie[q + 1], S.x + ie[q + 2], S.y + ie[q + 3]), A.x = S.x + ie[q + 0], A.y = S.y + ie[q + 1], S.x += ie[q + 2], S.y += ie[q + 3], q === 0 && $ === !0 && G.copy(S);
								break;
							case "q":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 4) b.quadraticCurveTo(S.x + ie[q + 0], S.y + ie[q + 1], S.x + ie[q + 2], S.y + ie[q + 3]), A.x = S.x + ie[q + 0], A.y = S.y + ie[q + 1], S.x += ie[q + 2], S.y += ie[q + 3], q === 0 && $ === !0 && G.copy(S);
								break;
							case "t":
								ie = d(Ee);
								for (let q = 0, Me = ie.length; q < Me; q += 2) {
									let Pe = y(S.x, A.x),
										Ke = y(S.y, A.y);
									b.quadraticCurveTo(Pe, Ke, S.x + ie[q + 0], S.y + ie[q + 1]), A.x = Pe, A.y = Ke, S.x = S.x + ie[q + 0], S.y = S.y + ie[q + 1], q === 0 && $ === !0 && G.copy(S)
								}
								break;
							case "a":
								ie = d(Ee, [3, 4], 7);
								for (let q = 0, Me = ie.length; q < Me; q += 7) {
									if (ie[q + 5] == 0 && ie[q + 6] == 0) continue;
									let Pe = S.clone();
									S.x += ie[q + 5], S.y += ie[q + 6], A.x = S.x, A.y = S.y, o(b, ie[q], ie[q + 1], ie[q + 2], ie[q + 3], ie[q + 4], Pe, S), q === 0 && $ === !0 && G.copy(S)
								}
								break;
							case "Z":
							case "z":
								b.currentPath.autoClose = !0, b.currentPath.curves.length > 0 && (S.copy(G), b.currentPath.currentPoint.copy(S), J = !0);
								break;
							default:
								console.warn(he)
						}
						$ = !1
					}
					return b
				}

				function s(P) {
					if (!(!P.sheet || !P.sheet.cssRules || !P.sheet.cssRules.length))
						for (let b = 0; b < P.sheet.cssRules.length; b++) {
							let S = P.sheet.cssRules[b];
							if (S.type !== 1) continue;
							let A = S.selectorText.split(/,/gm).filter(Boolean).map(G => G.trim());
							for (let G = 0; G < A.length; G++) {
								let J = Object.fromEntries(Object.entries(S.style).filter(([, $]) => $ !== ""));
								F[A[G]] = Object.assign(F[A[G]] || {}, J)
							}
						}
				}

				function o(P, b, S, A, G, J, $, le) {
					if (b == 0 || S == 0) {
						P.lineTo(le.x, le.y);
						return
					}
					A = A * Math.PI / 180, b = Math.abs(b), S = Math.abs(S);
					let N = ($.x - le.x) / 2,
						pe = ($.y - le.y) / 2,
						Q = Math.cos(A) * N + Math.sin(A) * pe,
						he = -Math.sin(A) * N + Math.cos(A) * pe,
						ye = b * b,
						Ee = S * S,
						ie = Q * Q,
						q = he * he,
						Me = ie / ye + q / Ee;
					if (Me > 1) {
						let ue = Math.sqrt(Me);
						b = ue * b, S = ue * S, ye = b * b, Ee = S * S
					}
					let Pe = ye * q + Ee * ie,
						Ke = (ye * Ee - Pe) / Pe,
						R = Math.sqrt(Math.max(0, Ke));
					G === J && (R = -R);
					let E = R * b * he / S,
						B = -R * S * Q / b,
						ne = Math.cos(A) * E - Math.sin(A) * B + ($.x + le.x) / 2,
						X = Math.sin(A) * E + Math.cos(A) * B + ($.y + le.y) / 2,
						ae = a(1, 0, (Q - E) / b, (he - B) / S),
						ge = a((Q - E) / b, (he - B) / S, (-Q - E) / b, (-he - B) / S) % (Math.PI * 2);
					P.currentPath.absellipse(ne, X, b, S, ae, ae + ge, J === 0, A)
				}

				function a(P, b, S, A) {
					let G = P * S + b * A,
						J = Math.sqrt(P * P + b * b) * Math.sqrt(S * S + A * A),
						$ = Math.acos(Math.max(-1, Math.min(1, G / J)));
					return P * A - b * S < 0 && ($ = -$), $
				}

				function l(P) {
					let b = v(P.getAttribute("x") || 0),
						S = v(P.getAttribute("y") || 0),
						A = v(P.getAttribute("rx") || P.getAttribute("ry") || 0),
						G = v(P.getAttribute("ry") || P.getAttribute("rx") || 0),
						J = v(P.getAttribute("width")),
						$ = v(P.getAttribute("height")),
						le = 1 - .551915024494,
						N = new dr;
					return N.moveTo(b + A, S), N.lineTo(b + J - A, S), (A !== 0 || G !== 0) && N.bezierCurveTo(b + J - A * le, S, b + J, S + G * le, b + J, S + G), N.lineTo(b + J, S + $ - G), (A !== 0 || G !== 0) && N.bezierCurveTo(b + J, S + $ - G * le, b + J - A * le, S + $, b + J - A, S + $), N.lineTo(b + A, S + $), (A !== 0 || G !== 0) && N.bezierCurveTo(b + A * le, S + $, b, S + $ - G * le, b, S + $ - G), N.lineTo(b, S + G), (A !== 0 || G !== 0) && N.bezierCurveTo(b, S + G * le, b + A * le, S, b + A, S), N
				}

				function c(P) {
					function b(J, $, le) {
						let N = v($),
							pe = v(le);
						G === 0 ? A.moveTo(N, pe) : A.lineTo(N, pe), G++
					}
					let S = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,
						A = new dr,
						G = 0;
					return P.getAttribute("points").replace(S, b), A.currentPath.autoClose = !0, A
				}

				function u(P) {
					function b(J, $, le) {
						let N = v($),
							pe = v(le);
						G === 0 ? A.moveTo(N, pe) : A.lineTo(N, pe), G++
					}
					let S = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,
						A = new dr,
						G = 0;
					return P.getAttribute("points").replace(S, b), A.currentPath.autoClose = !1, A
				}

				function h(P) {
					let b = v(P.getAttribute("cx") || 0),
						S = v(P.getAttribute("cy") || 0),
						A = v(P.getAttribute("r") || 0),
						G = new Br;
					G.absarc(b, S, A, 0, Math.PI * 2);
					let J = new dr;
					return J.subPaths.push(G), J
				}

				function f(P) {
					let b = v(P.getAttribute("cx") || 0),
						S = v(P.getAttribute("cy") || 0),
						A = v(P.getAttribute("rx") || 0),
						G = v(P.getAttribute("ry") || 0),
						J = new Br;
					J.absellipse(b, S, A, G, 0, Math.PI * 2);
					let $ = new dr;
					return $.subPaths.push(J), $
				}

				function m(P) {
					let b = v(P.getAttribute("x1") || 0),
						S = v(P.getAttribute("y1") || 0),
						A = v(P.getAttribute("x2") || 0),
						G = v(P.getAttribute("y2") || 0),
						J = new dr;
					return J.moveTo(b, S), J.lineTo(A, G), J.currentPath.autoClose = !1, J
				}

				function g(P, b) {
					b = Object.assign({}, b);
					let S = {};
					if (P.hasAttribute("class")) {
						let $ = P.getAttribute("class").split(/\s/).filter(Boolean).map(le => le.trim());
						for (let le = 0; le < $.length; le++) S = Object.assign(S, F["." + $[le]])
					}
					P.hasAttribute("id") && (S = Object.assign(S, F["#" + P.getAttribute("id")]));

					function A($, le, N) {
						N === void 0 && (N = function(Q) {
							return Q.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), Q
						}), P.hasAttribute($) && (b[le] = N(P.getAttribute($))), S[$] && (b[le] = N(S[$])), P.style && P.style[$] !== "" && (b[le] = N(P.style[$]))
					}

					function G($) {
						return Math.max(0, Math.min(1, v($)))
					}

					function J($) {
						return Math.max(0, v($))
					}
					return A("fill", "fill"), A("fill-opacity", "fillOpacity", G), A("fill-rule", "fillRule"), A("opacity", "opacity", G), A("stroke", "stroke"), A("stroke-opacity", "strokeOpacity", G), A("stroke-width", "strokeWidth", J), A("stroke-linejoin", "strokeLineJoin"), A("stroke-linecap", "strokeLineCap"), A("stroke-miterlimit", "strokeMiterLimit", J), A("visibility", "visibility"), b
				}

				function y(P, b) {
					return P - (b - P)
				}

				function d(P, b, S) {
					if (typeof P != "string") throw new TypeError("Invalid input: " + typeof P);
					let A = {
							SEPARATOR: /[ \t\r\n\,.\-+]/,
							WHITESPACE: /[ \t\r\n]/,
							DIGIT: /[\d]/,
							SIGN: /[-+]/,
							POINT: /\./,
							COMMA: /,/,
							EXP: /e/i,
							FLAGS: /[01]/
						},
						G = 0,
						J = 1,
						$ = 2,
						le = 3,
						N = G,
						pe = !0,
						Q = "",
						he = "",
						ye = [];

					function Ee(Pe, Ke, R) {
						let E = new SyntaxError('Unexpected character "' + Pe + '" at index ' + Ke + ".");
						throw E.partial = R, E
					}

					function ie() {
						Q !== "" && (he === "" ? ye.push(Number(Q)) : ye.push(Number(Q) * Math.pow(10, Number(he)))), Q = "", he = ""
					}
					let q, Me = P.length;
					for (let Pe = 0; Pe < Me; Pe++) {
						if (q = P[Pe], Array.isArray(b) && b.includes(ye.length % S) && A.FLAGS.test(q)) {
							N = J, Q = q, ie();
							continue
						}
						if (N === G) {
							if (A.WHITESPACE.test(q)) continue;
							if (A.DIGIT.test(q) || A.SIGN.test(q)) {
								N = J, Q = q;
								continue
							}
							if (A.POINT.test(q)) {
								N = $, Q = q;
								continue
							}
							A.COMMA.test(q) && (pe && Ee(q, Pe, ye), pe = !0)
						}
						if (N === J) {
							if (A.DIGIT.test(q)) {
								Q += q;
								continue
							}
							if (A.POINT.test(q)) {
								Q += q, N = $;
								continue
							}
							if (A.EXP.test(q)) {
								N = le;
								continue
							}
							A.SIGN.test(q) && Q.length === 1 && A.SIGN.test(Q[0]) && Ee(q, Pe, ye)
						}
						if (N === $) {
							if (A.DIGIT.test(q)) {
								Q += q;
								continue
							}
							if (A.EXP.test(q)) {
								N = le;
								continue
							}
							A.POINT.test(q) && Q[Q.length - 1] === "." && Ee(q, Pe, ye)
						}
						if (N === le) {
							if (A.DIGIT.test(q)) {
								he += q;
								continue
							}
							if (A.SIGN.test(q)) {
								if (he === "") {
									he += q;
									continue
								}
								he.length === 1 && A.SIGN.test(he) && Ee(q, Pe, ye)
							}
						}
						A.WHITESPACE.test(q) ? (ie(), N = G, pe = !1) : A.COMMA.test(q) ? (ie(), N = G, pe = !0) : A.SIGN.test(q) ? (ie(), N = J, Q = q) : A.POINT.test(q) ? (ie(), N = $, Q = q) : Ee(q, Pe, ye)
					}
					return ie(), ye
				}
				let p = ["mm", "cm", "in", "pt", "pc", "px"],
					_ = {
						mm: {
							mm: 1,
							cm: .1,
							in: 1 / 25.4,
							pt: 72 / 25.4,
							pc: 6 / 25.4,
							px: -1
						},
						cm: {
							mm: 10,
							cm: 1,
							in: 1 / 2.54,
							pt: 72 / 2.54,
							pc: 6 / 2.54,
							px: -1
						},
						in: {
							mm: 25.4,
							cm: 2.54,
							in: 1,
							pt: 72,
							pc: 6,
							px: -1
						},
						pt: {
							mm: 25.4 / 72,
							cm: 2.54 / 72,
							in: 1 / 72,
							pt: 1,
							pc: 6 / 72,
							px: -1
						},
						pc: {
							mm: 25.4 / 6,
							cm: 2.54 / 6,
							in: 1 / 6,
							pt: 72 / 6,
							pc: 1,
							px: -1
						},
						px: {
							px: 1
						}
					};

				function v(P) {
					let b = "px";
					if (typeof P == "string" || P instanceof String)
						for (let A = 0, G = p.length; A < G; A++) {
							let J = p[A];
							if (P.endsWith(J)) {
								b = J, P = P.substring(0, P.length - J.length);
								break
							}
						}
					let S;
					return b === "px" && t.defaultUnit !== "px" ? S = _.in[t.defaultUnit] / t.defaultDPI : (S = _[b][t.defaultUnit], S < 0 && (S = _[b].in * t.defaultDPI)), S * parseFloat(P)
				}

				function x(P) {
					if (!(P.hasAttribute("transform") || P.nodeName === "use" && (P.hasAttribute("x") || P.hasAttribute("y")))) return null;
					let b = M(P);
					return U.length > 0 && b.premultiply(U[U.length - 1]), te.copy(b), U.push(b), b
				}

				function M(P) {
					let b = new pt,
						S = K;
					if (P.nodeName === "use" && (P.hasAttribute("x") || P.hasAttribute("y"))) {
						let A = v(P.getAttribute("x")),
							G = v(P.getAttribute("y"));
						b.translate(A, G)
					}
					if (P.hasAttribute("transform")) {
						let A = P.getAttribute("transform").split(")");
						for (let G = A.length - 1; G >= 0; G--) {
							let J = A[G].trim();
							if (J === "") continue;
							let $ = J.indexOf("("),
								le = J.length;
							if ($ > 0 && $ < le) {
								let N = J.slice(0, $),
									pe = d(J.slice($ + 1));
								switch (S.identity(), N) {
									case "translate":
										if (pe.length >= 1) {
											let Q = pe[0],
												he = 0;
											pe.length >= 2 && (he = pe[1]), S.translate(Q, he)
										}
										break;
									case "rotate":
										if (pe.length >= 1) {
											let Q = 0,
												he = 0,
												ye = 0;
											Q = pe[0] * Math.PI / 180, pe.length >= 3 && (he = pe[1], ye = pe[2]), Z.makeTranslation(-he, -ye), Y.makeRotation(Q), H.multiplyMatrices(Y, Z), Z.makeTranslation(he, ye), S.multiplyMatrices(Z, H)
										}
										break;
									case "scale":
										if (pe.length >= 1) {
											let Q = pe[0],
												he = Q;
											pe.length >= 2 && (he = pe[1]), S.scale(Q, he)
										}
										break;
									case "skewX":
										pe.length === 1 && S.set(1, Math.tan(pe[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
										break;
									case "skewY":
										pe.length === 1 && S.set(1, 0, 0, Math.tan(pe[0] * Math.PI / 180), 1, 0, 0, 0, 1);
										break;
									case "matrix":
										pe.length === 6 && S.set(pe[0], pe[2], pe[4], pe[1], pe[3], pe[5], 0, 0, 1);
										break
								}
							}
							b.premultiply(S)
						}
					}
					return b
				}

				function I(P, b) {
					function S($) {
						de.set($.x, $.y, 1).applyMatrix3(b), $.set(de.x, de.y)
					}

					function A($) {
						let le = $.xRadius,
							N = $.yRadius,
							pe = Math.cos($.aRotation),
							Q = Math.sin($.aRotation),
							he = new re(le * pe, le * Q, 0),
							ye = new re(-N * Q, N * pe, 0),
							Ee = he.applyMatrix3(b),
							ie = ye.applyMatrix3(b),
							q = K.set(Ee.x, ie.x, 0, Ee.y, ie.y, 0, 0, 0, 1),
							Me = Z.copy(q).invert(),
							R = Y.copy(Me).transpose().multiply(Me).elements,
							E = V(R[0], R[1], R[4]),
							B = Math.sqrt(E.rt1),
							ne = Math.sqrt(E.rt2);
						if ($.xRadius = 1 / B, $.yRadius = 1 / ne, $.aRotation = Math.atan2(E.sn, E.cs), !(($.aEndAngle - $.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {
							let ae = Z.set(B, 0, 0, 0, ne, 0, 0, 0, 1),
								ge = Y.set(E.cs, E.sn, 0, -E.sn, E.cs, 0, 0, 0, 1),
								ue = ae.multiply(ge).multiply(q),
								se = _e => {
									let {
										x: Se,
										y: Ne
									} = new re(Math.cos(_e), Math.sin(_e), 0).applyMatrix3(ue);
									return Math.atan2(Ne, Se)
								};
							$.aStartAngle = se($.aStartAngle), $.aEndAngle = se($.aEndAngle), w(b) && ($.aClockwise = !$.aClockwise)
						}
					}

					function G($) {
						let le = T(b),
							N = C(b);
						$.xRadius *= le, $.yRadius *= N;
						let pe = le > Number.EPSILON ? Math.atan2(b.elements[1], b.elements[0]) : Math.atan2(-b.elements[3], b.elements[4]);
						$.aRotation += pe, w(b) && ($.aStartAngle *= -1, $.aEndAngle *= -1, $.aClockwise = !$.aClockwise)
					}
					let J = P.subPaths;
					for (let $ = 0, le = J.length; $ < le; $++) {
						let pe = J[$].curves;
						for (let Q = 0; Q < pe.length; Q++) {
							let he = pe[Q];
							he.isLineCurve ? (S(he.v1), S(he.v2)) : he.isCubicBezierCurve ? (S(he.v0), S(he.v1), S(he.v2), S(he.v3)) : he.isQuadraticBezierCurve ? (S(he.v0), S(he.v1), S(he.v2)) : he.isEllipseCurve && (oe.set(he.aX, he.aY), S(oe), he.aX = oe.x, he.aY = oe.y, L(b) ? A(he) : G(he))
						}
					}
				}

				function w(P) {
					let b = P.elements;
					return b[0] * b[4] - b[1] * b[3] < 0
				}

				function L(P) {
					let b = P.elements,
						S = b[0] * b[3] + b[1] * b[4];
					if (S === 0) return !1;
					let A = T(P),
						G = C(P);
					return Math.abs(S / (A * G)) > Number.EPSILON
				}

				function T(P) {
					let b = P.elements;
					return Math.sqrt(b[0] * b[0] + b[1] * b[1])
				}

				function C(P) {
					let b = P.elements;
					return Math.sqrt(b[3] * b[3] + b[4] * b[4])
				}

				function V(P, b, S) {
					let A, G, J, $, le, N = P + S,
						pe = P - S,
						Q = Math.sqrt(pe * pe + 4 * b * b);
					return N > 0 ? (A = .5 * (N + Q), le = 1 / A, G = P * le * S - b * le * b) : N < 0 ? G = .5 * (N - Q) : (A = .5 * Q, G = -.5 * Q), pe > 0 ? J = pe + Q : J = pe - Q, Math.abs(J) > 2 * Math.abs(b) ? (le = -2 * b / J, $ = 1 / Math.sqrt(1 + le * le), J = le * $) : Math.abs(b) === 0 ? (J = 1, $ = 0) : (le = -.5 * J / b, J = 1 / Math.sqrt(1 + le * le), $ = le * J), pe > 0 && (le = J, J = -$, $ = le), {
						rt1: A,
						rt2: G,
						cs: J,
						sn: $
					}
				}
				let k = [],
					F = {},
					U = [],
					K = new pt,
					Z = new pt,
					Y = new pt,
					H = new pt,
					oe = new Ce,
					de = new re,
					te = new pt,
					fe = new DOMParser().parseFromString(e, "image/svg+xml");
				return n(fe.documentElement, {
					fill: "#000",
					fillOpacity: 1,
					strokeOpacity: 1,
					strokeWidth: 1,
					strokeLineJoin: "miter",
					strokeLineCap: "butt",
					strokeMiterLimit: 4
				}), {
					paths: k,
					xml: fe.documentElement
				}
			}
			static createShapes(e) {
				let n = {
						ORIGIN: 0,
						DESTINATION: 1,
						BETWEEN: 2,
						LEFT: 3,
						RIGHT: 4,
						BEHIND: 5,
						BEYOND: 6
					},
					i = {
						loc: n.ORIGIN,
						t: 0
					};

				function s(y, d, p, _) {
					let v = y.x,
						x = d.x,
						M = p.x,
						I = _.x,
						w = y.y,
						L = d.y,
						T = p.y,
						C = _.y,
						V = (I - M) * (w - T) - (C - T) * (v - M),
						k = (x - v) * (w - T) - (L - w) * (v - M),
						F = (C - T) * (x - v) - (I - M) * (L - w),
						U = V / F,
						K = k / F;
					if (F === 0 && V !== 0 || U <= 0 || U >= 1 || K < 0 || K > 1) return null;
					if (V === 0 && F === 0) {
						for (let Z = 0; Z < 2; Z++)
							if (o(Z === 0 ? p : _, y, d), i.loc == n.ORIGIN) {
								let Y = Z === 0 ? p : _;
								return {
									x: Y.x,
									y: Y.y,
									t: i.t
								}
							} else if (i.loc == n.BETWEEN) {
							let Y = +(v + i.t * (x - v)).toPrecision(10),
								H = +(w + i.t * (L - w)).toPrecision(10);
							return {
								x: Y,
								y: H,
								t: i.t
							}
						}
						return null
					} else {
						for (let H = 0; H < 2; H++)
							if (o(H === 0 ? p : _, y, d), i.loc == n.ORIGIN) {
								let oe = H === 0 ? p : _;
								return {
									x: oe.x,
									y: oe.y,
									t: i.t
								}
							} let Z = +(v + U * (x - v)).toPrecision(10),
							Y = +(w + U * (L - w)).toPrecision(10);
						return {
							x: Z,
							y: Y,
							t: U
						}
					}
				}

				function o(y, d, p) {
					let _ = p.x - d.x,
						v = p.y - d.y,
						x = y.x - d.x,
						M = y.y - d.y,
						I = _ * M - x * v;
					if (y.x === d.x && y.y === d.y) {
						i.loc = n.ORIGIN, i.t = 0;
						return
					}
					if (y.x === p.x && y.y === p.y) {
						i.loc = n.DESTINATION, i.t = 1;
						return
					}
					if (I < -Number.EPSILON) {
						i.loc = n.LEFT;
						return
					}
					if (I > Number.EPSILON) {
						i.loc = n.RIGHT;
						return
					}
					if (_ * x < 0 || v * M < 0) {
						i.loc = n.BEHIND;
						return
					}
					if (Math.sqrt(_ * _ + v * v) < Math.sqrt(x * x + M * M)) {
						i.loc = n.BEYOND;
						return
					}
					let w;
					_ !== 0 ? w = x / _ : w = M / v, i.loc = n.BETWEEN, i.t = w
				}

				function a(y, d) {
					let p = [],
						_ = [];
					for (let v = 1; v < y.length; v++) {
						let x = y[v - 1],
							M = y[v];
						for (let I = 1; I < d.length; I++) {
							let w = d[I - 1],
								L = d[I],
								T = s(x, M, w, L);
							T !== null && p.find(C => C.t <= T.t + Number.EPSILON && C.t >= T.t - Number.EPSILON) === void 0 && (p.push(T), _.push(new Ce(T.x, T.y)))
						}
					}
					return _
				}

				function l(y, d, p) {
					let _ = new Ce;
					d.getCenter(_);
					let v = [];
					return p.forEach(x => {
						x.boundingBox.containsPoint(_) && a(y, x.points).forEach(I => {
							v.push({
								identifier: x.identifier,
								isCW: x.isCW,
								point: I
							})
						})
					}), v.sort((x, M) => x.point.x - M.point.x), v
				}

				function c(y, d, p, _, v) {
					(v == null || v === "") && (v = "nonzero");
					let x = new Ce;
					y.boundingBox.getCenter(x);
					let M = [new Ce(p, x.y), new Ce(_, x.y)],
						I = l(M, y.boundingBox, d);
					I.sort((k, F) => k.point.x - F.point.x);
					let w = [],
						L = [];
					I.forEach(k => {
						k.identifier === y.identifier ? w.push(k) : L.push(k)
					});
					let T = w[0].point.x,
						C = [],
						V = 0;
					for (; V < L.length && L[V].point.x < T;) C.length > 0 && C[C.length - 1] === L[V].identifier ? C.pop() : C.push(L[V].identifier), V++;
					if (C.push(y.identifier), v === "evenodd") {
						let k = C.length % 2 === 0,
							F = C[C.length - 2];
						return {
							identifier: y.identifier,
							isHole: k,
							for: F
						}
					} else if (v === "nonzero") {
						let k = !0,
							F = null,
							U = null;
						for (let K = 0; K < C.length; K++) {
							let Z = C[K];
							k ? (U = d[Z].isCW, k = !1, F = Z) : U !== d[Z].isCW && (U = d[Z].isCW, k = !0)
						}
						return {
							identifier: y.identifier,
							isHole: k,
							for: F
						}
					} else console.warn('fill-rule: "' + v + '" is currently not implemented.')
				}
				let u = 999999999,
					h = -999999999,
					f = e.subPaths.map(y => {
						let d = y.getPoints(),
							p = -999999999,
							_ = 999999999,
							v = -999999999,
							x = 999999999;
						for (let M = 0; M < d.length; M++) {
							let I = d[M];
							I.y > p && (p = I.y), I.y < _ && (_ = I.y), I.x > v && (v = I.x), I.x < x && (x = I.x)
						}
						return h <= v && (h = v + 1), u >= x && (u = x - 1), {
							curves: y.curves,
							points: d,
							isCW: lr.isClockWise(d),
							identifier: -1,
							boundingBox: new Uu(new Ce(x, _), new Ce(v, p))
						}
					});
				f = f.filter(y => y.points.length > 1);
				for (let y = 0; y < f.length; y++) f[y].identifier = y;
				let m = f.map(y => c(y, f, u, h, e.userData ? e.userData.style.fillRule : void 0)),
					g = [];
				return f.forEach(y => {
					if (!m[y.identifier].isHole) {
						let p = new ss;
						p.curves = y.curves, m.filter(v => v.isHole && v.for === y.identifier).forEach(v => {
							let x = f[v.identifier],
								M = new Br;
							M.curves = x.curves, p.holes.push(M)
						}), g.push(p)
					}
				}), g
			}
			static getStrokeStyle(e, t, n, i, s) {
				return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : "#000", n = n !== void 0 ? n : "miter", i = i !== void 0 ? i : "butt", s = s !== void 0 ? s : 4, {
					strokeColor: t,
					strokeWidth: e,
					strokeLineJoin: n,
					strokeLineCap: i,
					strokeMiterLimit: s
				}
			}
			static pointsToStroke(e, t, n, i) {
				let s = [],
					o = [],
					a = [];
				if (r.pointsToStrokeWithBuffers(e, t, n, i, s, o, a) === 0) return null;
				let l = new St;
				return l.setAttribute("position", new ze(s, 3)), l.setAttribute("normal", new ze(o, 3)), l.setAttribute("uv", new ze(a, 2)), l
			}
			static pointsToStrokeWithBuffers(e, t, n, i, s, o, a, l) {
				let c = new Ce,
					u = new Ce,
					h = new Ce,
					f = new Ce,
					m = new Ce,
					g = new Ce,
					y = new Ce,
					d = new Ce,
					p = new Ce,
					_ = new Ce,
					v = new Ce,
					x = new Ce,
					M = new Ce,
					I = new Ce,
					w = new Ce,
					L = new Ce,
					T = new Ce;
				n = n !== void 0 ? n : 12, i = i !== void 0 ? i : .001, l = l !== void 0 ? l : 0, e = pe(e);
				let C = e.length;
				if (C < 2) return 0;
				let V = e[0].equals(e[C - 1]),
					k, F = e[0],
					U, K = t.strokeWidth / 2,
					Z = 1 / (C - 1),
					Y = 0,
					H, oe, de, te, fe = !1,
					me = 0,
					P = l * 3,
					b = l * 2;
				S(e[0], e[1], c).multiplyScalar(K), d.copy(e[0]).sub(c), p.copy(e[0]).add(c), _.copy(d), v.copy(p);
				for (let Q = 1; Q < C; Q++) {
					k = e[Q], Q === C - 1 ? V ? U = e[1] : U = void 0 : U = e[Q + 1];
					let he = c;
					if (S(F, k, he), h.copy(he).multiplyScalar(K), x.copy(k).sub(h), M.copy(k).add(h), H = Y + Z, oe = !1, U !== void 0) {
						S(k, U, u), h.copy(u).multiplyScalar(K), I.copy(k).sub(h), w.copy(k).add(h), de = !0, h.subVectors(U, F), he.dot(h) < 0 && (de = !1), Q === 1 && (fe = de), h.subVectors(U, k), h.normalize();
						let ye = Math.abs(he.dot(h));
						if (ye > Number.EPSILON) {
							let Ee = K / ye;
							h.multiplyScalar(-Ee), f.subVectors(k, F), m.copy(f).setLength(Ee).add(h), L.copy(m).negate();
							let ie = m.length(),
								q = f.length();
							f.divideScalar(q), g.subVectors(U, k);
							let Me = g.length();
							switch (g.divideScalar(Me), f.dot(L) < q && g.dot(L) < Me && (oe = !0), T.copy(m).add(k), L.add(k), te = !1, oe ? de ? (w.copy(L), M.copy(L)) : (I.copy(L), x.copy(L)) : J(), t.strokeLineJoin) {
								case "bevel":
									$(de, oe, H);
									break;
								case "round":
									le(de, oe), de ? G(k, x, I, H, 0) : G(k, w, M, H, 1);
									break;
								case "miter":
								case "miter-clip":
								default:
									let Pe = K * t.strokeMiterLimit / ie;
									if (Pe < 1)
										if (t.strokeLineJoin !== "miter-clip") {
											$(de, oe, H);
											break
										} else le(de, oe), de ? (g.subVectors(T, x).multiplyScalar(Pe).add(x), y.subVectors(T, I).multiplyScalar(Pe).add(I), A(x, H, 0), A(g, H, 0), A(k, H, .5), A(k, H, .5), A(g, H, 0), A(y, H, 0), A(k, H, .5), A(y, H, 0), A(I, H, 0)) : (g.subVectors(T, M).multiplyScalar(Pe).add(M), y.subVectors(T, w).multiplyScalar(Pe).add(w), A(M, H, 1), A(g, H, 1), A(k, H, .5), A(k, H, .5), A(g, H, 1), A(y, H, 1), A(k, H, .5), A(y, H, 1), A(w, H, 1));
									else oe ? (de ? (A(p, Y, 1), A(d, Y, 0), A(T, H, 0), A(p, Y, 1), A(T, H, 0), A(L, H, 1)) : (A(p, Y, 1), A(d, Y, 0), A(T, H, 1), A(d, Y, 0), A(L, H, 0), A(T, H, 1)), de ? I.copy(T) : w.copy(T)) : de ? (A(x, H, 0), A(T, H, 0), A(k, H, .5), A(k, H, .5), A(T, H, 0), A(I, H, 0)) : (A(M, H, 1), A(T, H, 1), A(k, H, .5), A(k, H, .5), A(T, H, 1), A(w, H, 1)), te = !0;
									break
							}
						} else J()
					} else J();
					!V && Q === C - 1 && N(e[0], _, v, de, !0, Y), Y = H, F = k, d.copy(I), p.copy(w)
				}
				if (!V) N(k, x, M, de, !1, H);
				else if (oe && s) {
					let Q = T,
						he = L;
					fe !== de && (Q = L, he = T), de ? (te || fe) && (he.toArray(s, 0 * 3), he.toArray(s, 3 * 3), te && Q.toArray(s, 1 * 3)) : (te || !fe) && (he.toArray(s, 1 * 3), he.toArray(s, 3 * 3), te && Q.toArray(s, 0 * 3))
				}
				return me;

				function S(Q, he, ye) {
					return ye.subVectors(he, Q), ye.set(-ye.y, ye.x).normalize()
				}

				function A(Q, he, ye) {
					s && (s[P] = Q.x, s[P + 1] = Q.y, s[P + 2] = 0, o && (o[P] = 0, o[P + 1] = 0, o[P + 2] = 1), P += 3, a && (a[b] = he, a[b + 1] = ye, b += 2)), me += 3
				}

				function G(Q, he, ye, Ee, ie) {
					c.copy(he).sub(Q).normalize(), u.copy(ye).sub(Q).normalize();
					let q = Math.PI,
						Me = c.dot(u);
					Math.abs(Me) < 1 && (q = Math.abs(Math.acos(Me))), q /= n, h.copy(he);
					for (let Pe = 0, Ke = n - 1; Pe < Ke; Pe++) f.copy(h).rotateAround(Q, q), A(h, Ee, ie), A(f, Ee, ie), A(Q, Ee, .5), h.copy(f);
					A(f, Ee, ie), A(ye, Ee, ie), A(Q, Ee, .5)
				}

				function J() {
					A(p, Y, 1), A(d, Y, 0), A(x, H, 0), A(p, Y, 1), A(x, H, 1), A(M, H, 0)
				}

				function $(Q, he, ye) {
					he ? Q ? (A(p, Y, 1), A(d, Y, 0), A(x, H, 0), A(p, Y, 1), A(x, H, 0), A(L, H, 1), A(x, ye, 0), A(I, ye, 0), A(L, ye, .5)) : (A(p, Y, 1), A(d, Y, 0), A(M, H, 1), A(d, Y, 0), A(L, H, 0), A(M, H, 1), A(M, ye, 1), A(w, ye, 0), A(L, ye, .5)) : Q ? (A(x, ye, 0), A(I, ye, 0), A(k, ye, .5)) : (A(M, ye, 1), A(w, ye, 0), A(k, ye, .5))
				}

				function le(Q, he) {
					he && (Q ? (A(p, Y, 1), A(d, Y, 0), A(x, H, 0), A(p, Y, 1), A(x, H, 0), A(L, H, 1), A(x, Y, 0), A(k, H, .5), A(L, H, 1), A(k, H, .5), A(I, Y, 0), A(L, H, 1)) : (A(p, Y, 1), A(d, Y, 0), A(M, H, 1), A(d, Y, 0), A(L, H, 0), A(M, H, 1), A(M, Y, 1), A(L, H, 0), A(k, H, .5), A(k, H, .5), A(L, H, 0), A(w, Y, 1)))
				}

				function N(Q, he, ye, Ee, ie, q) {
					switch (t.strokeLineCap) {
						case "round":
							ie ? G(Q, ye, he, q, .5) : G(Q, he, ye, q, .5);
							break;
						case "square":
							if (ie) c.subVectors(he, Q), u.set(c.y, -c.x), h.addVectors(c, u).add(Q), f.subVectors(u, c).add(Q), Ee ? (h.toArray(s, 1 * 3), f.toArray(s, 0 * 3), f.toArray(s, 3 * 3)) : (h.toArray(s, 1 * 3), h.toArray(s, 3 * 3), f.toArray(s, 0 * 3));
							else {
								c.subVectors(ye, Q), u.set(c.y, -c.x), h.addVectors(c, u).add(Q), f.subVectors(u, c).add(Q);
								let Me = s.length;
								Ee ? (h.toArray(s, Me - 1 * 3), f.toArray(s, Me - 2 * 3), f.toArray(s, Me - 4 * 3)) : (h.toArray(s, Me - 2 * 3), f.toArray(s, Me - 1 * 3), f.toArray(s, Me - 4 * 3))
							}
							break;
						case "butt":
						default:
							break
					}
				}

				function pe(Q) {
					let he = !1;
					for (let Ee = 1, ie = Q.length - 1; Ee < ie; Ee++)
						if (Q[Ee].distanceTo(Q[Ee + 1]) < i) {
							he = !0;
							break
						} if (!he) return Q;
					let ye = [];
					ye.push(Q[0]);
					for (let Ee = 1, ie = Q.length - 1; Ee < ie; Ee++) Q[Ee].distanceTo(Q[Ee + 1]) >= i && ye.push(Q[Ee]);
					return ye.push(Q[Q.length - 1]), ye
				}
			}
		};
	var uh = class extends Zi {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "svg"
		}
		GetUpDirection() {
			return ht.Z
		}
		CreateLoader(e) {
			return new $l(e)
		}
		GetMainObject(e) {
			function t(o) {
				let a = o.userData.style;
				return !(a.fill === void 0 || a.fill === "none")
			}

			function n(o, a, l) {
				let c = null;
				for (let u of o)
					if (u.style === a && u.opacity === l) {
						c = u.material;
						break
					} return c === null && (c = new Xt({
					color: new qe().setStyle(a),
					opacity: l,
					transparent: l < 1
				}), o.push({
					style: a,
					opacity: l,
					material: c
				})), c
			}
			let i = [],
				s = new Rt;
			s.rotation.x = Math.PI;
			for (let o of e.paths) {
				let a = $l.createShapes(o);
				if (t(o)) {
					let l = o.userData.style,
						c = n(i, l.fill, l.opacity);
					for (let u of a) {
						let h = new Iu(u, {
								depth: 10,
								bevelEnabled: !1
							}),
							f = new Nt(h, c);
						f.name = o.userData.node.id, s.add(f)
					}
				}
			}
			return s
		}
	};
	var Ql = class {
			constructor() {
				this.name = null, this.material = null
			}
			SetName(e) {
				return this.name = e, this
			}
			SetMaterial(e) {
				return this.material = e, this
			}
		},
		xs = class {
			constructor(e) {
				this.params = e || new Ql, this.mesh = new $t, this.params.name !== null && this.mesh.SetName(this.params.name), this.curve = null
			}
			GetMesh() {
				return this.mesh
			}
			AddVertex(e, t, n) {
				let i = new He(e, t, n);
				return this.mesh.AddVertex(i)
			}
			AddVertices(e) {
				let t = [];
				for (let n = 0; n < e.length; n++) {
					let i = e[n];
					t.push(this.AddVertex(i.x, i.y, i.z))
				}
				return t
			}
			SetCurve(e) {
				this.curve = e
			}
			ResetCurve() {
				this.curve = null
			}
			AddTriangle(e, t, n) {
				let i = new Ht(e, t, n);
				return this.params.material !== null && (i.mat = this.params.material), this.curve !== null && i.SetCurve(this.curve), this.mesh.AddTriangle(i)
			}
			AddTriangleInverted(e, t, n) {
				this.AddTriangle(e, n, t)
			}
			AddConvexPolygon(e) {
				for (let t = 0; t < e.length - 2; t++) this.AddTriangle(e[0], e[t + 1], e[t + 2])
			}
			AddConvexPolygonInverted(e) {
				for (let t = 0; t < e.length - 2; t++) this.AddTriangleInverted(e[0], e[t + 1], e[t + 2])
			}
		},
		Ga = class {
			constructor(e) {
				this.generator = e
			}
			GenerateSurfaceBetweenPolygons(e, t) {
				if (e.length !== t.length) return;
				let n = e.length;
				for (let i = 0; i < n; i++) {
					let s = i,
						o = i < n - 1 ? s + 1 : 0;
					this.generator.AddConvexPolygon([e[s], e[o], t[o], t[s]])
				}
			}
			GenerateTriangleFan(e, t) {
				let n = e.length;
				for (let i = 0; i < n; i++) {
					let s = i,
						o = i < n - 1 ? s + 1 : 0;
					this.generator.AddTriangle(t, e[s], e[o])
				}
			}
		};

	function S0(r, e) {
		return new wt(r * Math.cos(e), r * Math.sin(e))
	}

	function A0(r, e, t, n) {
		if (!gi(e) || !gi(t) || !gi(n)) return null;
		let i = new xs(r);
		return i.AddVertex(0, 0, 0), i.AddVertex(e, 0, 0), i.AddVertex(e, t, 0), i.AddVertex(0, t, 0), i.AddVertex(0, 0, n), i.AddVertex(e, 0, n), i.AddVertex(e, t, n), i.AddVertex(0, t, n), i.AddConvexPolygon([0, 3, 2, 1]), i.AddConvexPolygon([0, 1, 5, 4]), i.AddConvexPolygon([1, 2, 6, 5]), i.AddConvexPolygon([2, 3, 7, 6]), i.AddConvexPolygon([3, 0, 4, 7]), i.AddConvexPolygon([4, 5, 6, 7]), i.GetMesh()
	}

	function Xd(r, e, t, n, i, s) {
		if (Tr(e) || Tr(t) || !gi(n) || i < 3) return null;
		let o = Ms(e),
			a = Ms(t);
		if (o && a) return null;
		let l = new xs(r),
			c = new Ga(l),
			u = 2 * Math.PI / i,
			h = s ? 1 : null,
			f = [];
		if (o) f.push(l.AddVertex(0, 0, n));
		else
			for (let g = 0; g < i; g++) {
				let y = S0(e, g * u);
				f.push(l.AddVertex(y.x, y.y, n))
			}
		let m = [];
		if (a) m.push(l.AddVertex(0, 0, 0));
		else
			for (let g = 0; g < i; g++) {
				let y = S0(t, g * u);
				m.push(l.AddVertex(y.x, y.y, 0))
			}
		return o ? (l.SetCurve(h), c.GenerateTriangleFan(m, f[0]), l.ResetCurve(), l.AddConvexPolygonInverted(m)) : a ? (l.SetCurve(h), c.GenerateTriangleFan(f.slice().reverse(), m[0]), l.ResetCurve(), l.AddConvexPolygon(f)) : (l.SetCurve(h), c.GenerateSurfaceBetweenPolygons(m, f), l.ResetCurve(), l.AddConvexPolygonInverted(m), l.AddConvexPolygon(f)), l.GetMesh()
	}

	function w0(r, e, t, n, i) {
		return Xd(r, e, e, t, n, i)
	}

	function C0(r, e, t, n) {
		function i(m, g, y) {
			return new He(m * Math.sin(g) * Math.cos(y), m * Math.sin(g) * Math.sin(y), m * Math.cos(g))
		}
		if (!gi(e) || t < 3) return null;
		let s = new xs(r),
			o = new Ga(s);
		s.SetCurve(n ? 1 : null);
		let a = [],
			l = t + 1,
			c = Math.PI / t,
			u = 2 * Math.PI / t;
		for (let m = 1; m < l - 1; m++) {
			let g = [],
				y = m * c;
			for (let d = 0; d < t; d++) {
				let p = d * u,
					_ = i(e, y, -p);
				g.push(s.AddVertex(_.x, _.y, _.z))
			}
			m > 1 && o.GenerateSurfaceBetweenPolygons(a[a.length - 1], g), a.push(g)
		}
		let h = s.AddVertex(0, 0, e),
			f = s.AddVertex(0, 0, -e);
		return o.GenerateTriangleFan(a[0].slice().reverse(), h), o.GenerateTriangleFan(a[a.length - 1], f), s.ResetCurve(), s.GetMesh()
	}

	function R0(r, e, t) {
		function n(s, o, a, l, c) {
			let u = new He(a, l, c);
			u.MultiplyScalar(o / u.Length()), s.AddVertex(u.x, u.y, u.z)
		}
		if (!gi(t)) return null;
		let i = new xs(r);
		if (e === "tetrahedron") {
			let s = 1;
			n(i, t, +s, +s, +s), n(i, t, -s, -s, +s), n(i, t, -s, +s, -s), n(i, t, +s, -s, -s), i.AddTriangle(0, 1, 3), i.AddTriangle(0, 2, 1), i.AddTriangle(0, 3, 2), i.AddTriangle(1, 2, 3)
		} else if (e === "hexahedron") {
			let s = 1;
			n(i, t, +s, +s, +s), n(i, t, +s, +s, -s), n(i, t, +s, -s, +s), n(i, t, +s, -s, -s), n(i, t, -s, +s, +s), n(i, t, -s, +s, -s), n(i, t, -s, -s, +s), n(i, t, -s, -s, -s), i.AddConvexPolygon([0, 1, 5, 4]), i.AddConvexPolygon([0, 2, 3, 1]), i.AddConvexPolygon([0, 4, 6, 2]), i.AddConvexPolygon([1, 3, 7, 5]), i.AddConvexPolygon([2, 6, 7, 3]), i.AddConvexPolygon([4, 5, 7, 6])
		} else if (e === "octahedron") {
			let s = 1,
				o = 0;
			n(i, t, +s, +o, +o), n(i, t, -s, +o, +o), n(i, t, +o, +s, +o), n(i, t, +o, -s, +o), n(i, t, +o, +o, +s), n(i, t, +o, +o, -s), i.AddTriangle(0, 2, 4), i.AddTriangle(0, 3, 5), i.AddTriangle(0, 4, 3), i.AddTriangle(0, 5, 2), i.AddTriangle(1, 2, 5), i.AddTriangle(1, 3, 4), i.AddTriangle(1, 4, 2), i.AddTriangle(1, 5, 3)
		} else if (e === "dodecahedron") {
			let s = 1,
				o = 0,
				a = (1 + Math.sqrt(5)) / 2,
				l = 1 / a;
			n(i, t, +s, +s, +s), n(i, t, +s, +s, -s), n(i, t, +s, -s, +s), n(i, t, -s, +s, +s), n(i, t, +s, -s, -s), n(i, t, -s, +s, -s), n(i, t, -s, -s, +s), n(i, t, -s, -s, -s), n(i, t, +o, +l, +a), n(i, t, +o, +l, -a), n(i, t, +o, -l, +a), n(i, t, +o, -l, -a), n(i, t, +l, +a, +o), n(i, t, +l, -a, +o), n(i, t, -l, +a, +o), n(i, t, -l, -a, +o), n(i, t, +a, +o, +l), n(i, t, -a, +o, +l), n(i, t, +a, +o, -l), n(i, t, -a, +o, -l), i.AddConvexPolygon([0, 8, 10, 2, 16]), i.AddConvexPolygon([0, 16, 18, 1, 12]), i.AddConvexPolygon([0, 12, 14, 3, 8]), i.AddConvexPolygon([1, 9, 5, 14, 12]), i.AddConvexPolygon([1, 18, 4, 11, 9]), i.AddConvexPolygon([2, 10, 6, 15, 13]), i.AddConvexPolygon([2, 13, 4, 18, 16]), i.AddConvexPolygon([3, 14, 5, 19, 17]), i.AddConvexPolygon([3, 17, 6, 10, 8]), i.AddConvexPolygon([4, 13, 15, 7, 11]), i.AddConvexPolygon([5, 9, 11, 7, 19]), i.AddConvexPolygon([6, 17, 19, 7, 15])
		} else if (e === "icosahedron") {
			let s = 1,
				o = 0,
				a = (1 + Math.sqrt(5)) / 2;
			n(i, t, +o, +s, +a), n(i, t, +o, +s, -a), n(i, t, +o, -s, +a), n(i, t, +o, -s, -a), n(i, t, +s, +a, +o), n(i, t, +s, -a, +o), n(i, t, -s, +a, +o), n(i, t, -s, -a, +o), n(i, t, +a, +o, +s), n(i, t, +a, +o, -s), n(i, t, -a, +o, +s), n(i, t, -a, +o, -s), i.AddTriangle(0, 2, 8), i.AddTriangle(0, 4, 6), i.AddTriangle(0, 6, 10), i.AddTriangle(0, 8, 4), i.AddTriangle(0, 10, 2), i.AddTriangle(1, 3, 11), i.AddTriangle(1, 4, 9), i.AddTriangle(1, 6, 4), i.AddTriangle(1, 9, 3), i.AddTriangle(1, 11, 6), i.AddTriangle(2, 5, 8), i.AddTriangle(2, 7, 5), i.AddTriangle(2, 10, 7), i.AddTriangle(3, 5, 7), i.AddTriangle(3, 7, 11), i.AddTriangle(3, 9, 5), i.AddTriangle(4, 8, 9), i.AddTriangle(5, 9, 8), i.AddTriangle(6, 11, 10), i.AddTriangle(7, 10, 11)
		}
		return i.GetMesh()
	}

	function qd(r, e, t) {
		let n = Wn(r, e),
			i = Wn(e, t),
			s = Wn(r, t),
			o = (n + i + s) / 2,
			a = o * (o - n) * (o - i) * (o - s);
		return a < 0 ? 0 : Math.sqrt(a)
	}

	function jd(r, e, t) {
		return nl(r, Li(e, t)) / 6
	}

	function Yd(r) {
		if (r instanceof or) {
			let e = 0;
			return r.EnumerateMeshInstances(t => {
				e += Yd(t)
			}), e
		} else {
			let e = 0;
			return r.EnumerateTriangleVertices((t, n, i) => {
				e += jd(t, n, i)
			}), e
		}
	}

	function I0(r) {
		let e = 0;
		return r.EnumerateTriangleVertices((t, n, i) => {
			e += qd(t, n, i)
		}), e
	}
	var zn = {
			Perspective: 1,
			Orthographic: 2
		},
		yr = class r {
			constructor(e, t, n, i) {
				this.eye = e, this.center = t, this.up = n, this.fov = i
			}
			Clone() {
				return new r(this.eye.Clone(), this.center.Clone(), this.up.Clone(), this.fov)
			}
		};

	function hh(r, e) {
		return li(r.eye, e.eye) && li(r.center, e.center) && li(r.up, e.up) && It(r.fov, e.fov)
	}

	function fh(r, e) {
		function t(n, i) {
			for (let s of n) s.polygonOffset = i, s.polygonOffsetUnit = 1, s.polygonOffsetFactor = 1
		}
		t(r.material, e), r.userData.threeMaterials && t(r.userData.threeMaterials, e)
	}
	var _s = class {
			constructor(e) {
				this.scene = e, this.rootObject = null
			}
			IsEmpty() {
				return this.rootObject === null
			}
			SetRootObject(e) {
				this.rootObject !== null && this.Clear(), this.rootObject = e, this.scene.add(this.rootObject)
			}
			GetRootObject() {
				return this.rootObject
			}
			AddObject(e) {
				if (this.rootObject === null) {
					let t = new Rt;
					this.SetRootObject(t)
				}
				this.rootObject.add(e)
			}
			Traverse(e) {
				this.rootObject !== null && this.rootObject.traverse(t => {
					e(t)
				})
			}
			UpdateWorldMatrix() {
				this.rootObject !== null && this.rootObject.updateWorldMatrix(!0, !0)
			}
			Clear() {
				Xu(this.rootObject), this.scene.remove(this.rootObject), this.rootObject = null
			}
		},
		eo = class r {
			constructor(e, t, n) {
				this.showEdges = e, this.edgeColor = t, this.edgeThreshold = n
			}
			Clone() {
				return new r(this.showEdges, this.edgeColor.Clone(), this.edgeThreshold)
			}
		},
		Va = class {
			constructor(e) {
				this.scene = e, this.mainModel = new _s(this.scene), this.edgeModel = new _s(this.scene), this.edgeSettings = new eo(!1, new Et(0, 0, 0), 1)
			}
			SetMainObject(e) {
				this.mainModel.SetRootObject(e), this.edgeSettings.showEdges && this.GenerateEdgeModel()
			}
			UpdateWorldMatrix() {
				this.mainModel.UpdateWorldMatrix(), this.edgeModel.UpdateWorldMatrix()
			}
			SetEdgeSettings(e) {
				let t = !1;
				if (e.showEdges && (!this.edgeSettings.showEdges || this.edgeSettings.edgeThreshold !== e.edgeThreshold) && (t = !0), this.edgeSettings = e, !this.mainModel.IsEmpty())
					if (this.edgeSettings.showEdges)
						if (t) this.ClearEdgeModel(), this.GenerateEdgeModel();
						else {
							let n = On(this.edgeSettings.edgeColor);
							this.EnumerateEdges(i => {
								i.material.color = n
							})
						}
				else this.ClearEdgeModel()
			}
			GenerateEdgeModel() {
				let e = On(this.edgeSettings.edgeColor);
				this.UpdateWorldMatrix(), this.EnumerateMeshes(t => {
					fh(t, !0);
					let n = new Ru(t.geometry, this.edgeSettings.edgeThreshold),
						i = new ls(n, new Ei({
							color: e
						}));
					i.applyMatrix4(t.matrixWorld), i.userData = t.userData, i.visible = t.visible, this.edgeModel.AddObject(i)
				})
			}
			GetBoundingBox(e) {
				let t = !1,
					n = new Bi;
				return this.EnumerateMeshes(i => {
					e(i.userData) && (n.union(new Bi().setFromObject(i)), t = !0)
				}), t ? n : null
			}
			GetBoundingSphere(e) {
				let t = this.GetBoundingBox(e);
				if (t === null) return null;
				let n = new Gi;
				return t.getBoundingSphere(n), n
			}
			Clear() {
				this.mainModel.Clear(), this.ClearEdgeModel()
			}
			ClearEdgeModel() {
				this.edgeModel.IsEmpty() || (this.EnumerateMeshes(e => {
					fh(e, !1)
				}), this.edgeModel.Clear())
			}
			EnumerateMeshes(e) {
				this.mainModel.Traverse(t => {
					t.isMesh && e(t)
				})
			}
			EnumerateEdges(e) {
				this.edgeModel.Traverse(t => {
					t.isLineSegments && e(t)
				})
			}
			GetMeshIntersectionUnderMouse(e, t, n, i) {
				if (this.mainModel.IsEmpty() || e.x < 0 || e.x > n || e.y < 0 || e.y > i) return null;
				let s = new Fu,
					o = new Ce;
				o.x = e.x / n * 2 - 1, o.y = -(e.y / i) * 2 + 1, s.setFromCamera(o, t);
				let a = s.intersectObject(this.mainModel.GetRootObject(), !0);
				for (let l = 0; l < a.length; l++) {
					let c = a[l];
					if (c.object.isMesh && c.object.visible) return c
				}
				return null
			}
		};
	var on = {
			IntegerToString(r) {
				return r.toString()
			},
			StringToInteger(r) {
				return parseInt(r, 10)
			},
			NumberToString(r) {
				let e = 5;
				return r.toFixed(e)
			},
			StringToNumber(r) {
				return parseFloat(r)
			},
			ModelUrlsToString: function(r) {
				return r === null ? null : r.join(",")
			},
			StringToModelUrls: function(r) {
				return r === null || r.length === 0 ? null : r.split(",")
			},
			CameraToString: function(r) {
				return r === null ? null : [this.NumberToString(r.eye.x), this.NumberToString(r.eye.y), this.NumberToString(r.eye.z), this.NumberToString(r.center.x), this.NumberToString(r.center.y), this.NumberToString(r.center.z), this.NumberToString(r.up.x), this.NumberToString(r.up.y), this.NumberToString(r.up.z), this.NumberToString(r.fov)].join(",")
			},
			CameraModeToString: function(r) {
				return r === zn.Perspective ? "perspective" : r === zn.Orthographic ? "orthographic" : null
			},
			StringToCamera: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				if (e.length !== 9 && e.length !== 10) return null;
				let t = 45;
				return e.length >= 10 && (t = this.StringToNumber(e[9])), new yr(new He(this.StringToNumber(e[0]), this.StringToNumber(e[1]), this.StringToNumber(e[2])), new He(this.StringToNumber(e[3]), this.StringToNumber(e[4]), this.StringToNumber(e[5])), new He(this.StringToNumber(e[6]), this.StringToNumber(e[7]), this.StringToNumber(e[8])), t)
			},
			StringToCameraMode: function(r) {
				return r === "perspective" ? zn.Perspective : r === "orthographic" ? zn.Orthographic : null
			},
			RGBColorToString: function(r) {
				return r === null ? null : [this.IntegerToString(r.r), this.IntegerToString(r.g), this.IntegerToString(r.b)].join(",")
			},
			RGBAColorToString: function(r) {
				return r === null ? null : [this.IntegerToString(r.r), this.IntegerToString(r.g), this.IntegerToString(r.b), this.IntegerToString(r.a)].join(",")
			},
			StringToRGBColor: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				return e.length !== 3 ? null : new Et(this.StringToInteger(e[0]), this.StringToInteger(e[1]), this.StringToInteger(e[2]))
			},
			StringToRGBAColor: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				if (e.length !== 3 && e.length !== 4) return null;
				let t = new Er(this.StringToInteger(e[0]), this.StringToInteger(e[1]), this.StringToInteger(e[2]), 255);
				return e.length === 4 && (t.a = this.StringToInteger(e[3])), t
			},
			EnvironmentSettingsToString(r) {
				return r === null ? null : [r.environmentMapName, r.backgroundIsEnvMap ? "on" : "off"].join(",")
			},
			StringToEnvironmentSettings: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				return e.length !== 2 ? null : {
					environmentMapName: e[0],
					backgroundIsEnvMap: e[1] === "on"
				}
			},
			EdgeSettingsToString: function(r) {
				return r === null ? null : [r.showEdges ? "on" : "off", this.RGBColorToString(r.edgeColor), this.IntegerToString(r.edgeThreshold)].join(",")
			},
			StringToEdgeSettings: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				return e.length !== 5 ? null : new eo(e[0] === "on", new Et(this.StringToInteger(e[1]), this.StringToInteger(e[2]), this.StringToInteger(e[3])), this.StringToInteger(e[4]))
			}
		},
		ec = class {
			constructor(e) {
				this.separator = e, this.paramList = ""
			}
			AddModelUrls(e) {
				return this.AddUrlPart("model", on.ModelUrlsToString(e)), this
			}
			AddCamera(e) {
				return this.AddUrlPart("camera", on.CameraToString(e)), this
			}
			AddCameraMode(e) {
				return this.AddUrlPart("cameramode", on.CameraModeToString(e)), this
			}
			AddEnvironmentSettings(e) {
				return this.AddUrlPart("envsettings", on.EnvironmentSettingsToString(e)), this
			}
			AddBackgroundColor(e) {
				return this.AddUrlPart("backgroundcolor", on.RGBAColorToString(e)), this
			}
			AddDefaultColor(e) {
				return this.AddUrlPart("defaultcolor", on.RGBColorToString(e)), this
			}
			AddEdgeSettings(e) {
				return this.AddUrlPart("edgesettings", on.EdgeSettingsToString(e)), this
			}
			AddUrlPart(e, t) {
				e === null || t === null || (this.paramList.length > 0 && (this.paramList += this.separator), this.paramList += e + "=" + t)
			}
			GetParameterList() {
				return this.paramList
			}
		},
		tc = class {
			constructor(e, t) {
				this.separator = t, this.paramList = e
			}
			GetModelUrls() {
				if (this.paramList.indexOf("=") === -1) return this.paramList.split(",");
				let e = this.GetKeywordParams("model");
				return on.StringToModelUrls(e)
			}
			GetCamera() {
				let e = this.GetKeywordParams("camera");
				return on.StringToCamera(e)
			}
			GetCameraMode() {
				let e = this.GetKeywordParams("cameramode");
				return on.StringToCameraMode(e)
			}
			GetEnvironmentSettings() {
				let e = this.GetKeywordParams("envsettings");
				return on.StringToEnvironmentSettings(e)
			}
			GetBackgroundColor() {
				let e = this.GetKeywordParams("backgroundcolor");
				return on.StringToRGBAColor(e)
			}
			GetDefaultColor() {
				let e = this.GetKeywordParams("defaultcolor");
				return on.StringToRGBColor(e)
			}
			GetEdgeSettings() {
				let e = this.GetKeywordParams("edgesettings");
				return on.StringToEdgeSettings(e)
			}
			GetKeywordParams(e) {
				if (this.paramList === null || this.paramList.length === 0) return null;
				let t = e + "=",
					n = this.paramList.split(this.separator);
				for (let i = 0; i < n.length; i++) {
					let s = n[i];
					if (s.startsWith(t)) return s.substring(t.length)
				}
				return null
			}
		};

	function Kd() {
		return new ec("$")
	}

	function P0(r) {
		return new tc(r, "$")
	}

	function L0(r) {
		let e = Kd();
		return e.AddModelUrls(r), e.GetParameterList()
	}
	var za = class {
			constructor() {
				this.forceMediumpForMaterials = !1
			}
		},
		Ha = class {
			constructor() {
				this.defaultMaterial = null, this.objectUrls = []
			}
		},
		nc = class {
			constructor(e) {
				this.callbacks = e, this.texturesNeeded = 0, this.texturesLoaded = 0, this.threeObject = null
			}
			OnTextureNeeded() {
				this.texturesNeeded += 1
			}
			OnTextureLoaded() {
				this.texturesLoaded += 1, this.callbacks.onTextureLoaded(), this.Finish()
			}
			OnModelLoaded(e) {
				this.threeObject = e, this.Finish()
			}
			Finish() {
				this.threeObject !== null && this.texturesNeeded === this.texturesLoaded && this.callbacks.onModelLoaded(this.threeObject)
			}
		},
		ic = class {
			constructor(e, t) {
				this.model = e, this.threeNodeItems = [], this.AddNode(e.GetRootNode(), t)
			}
			AddNode(e, t) {
				let n = e.GetTransformation().GetMatrix(),
					i = new Je().fromArray(n.Get());
				t.applyMatrix4(i);
				for (let s of e.GetChildNodes()) {
					let o = new Rt;
					t.add(o), this.AddNode(s, o)
				}
				for (let s of e.GetMeshIndices()) {
					let o = new yi(e.GetId(), s),
						a = this.model.GetMesh(s);
					this.threeNodeItems.push({
						meshInstance: new br(o, e, a),
						threeNode: t
					})
				}
			}
			GetNodeItems() {
				return this.threeNodeItems
			}
		};

	function dh(r, e, t, n) {
		function i(f, m, g, y, d, p) {
			function _(T, C) {
				C.wrapS = Qt, C.wrapT = Qt, C.rotation = T.rotation, C.offset.x = T.offset.x, C.offset.y = T.offset.y, C.repeat.x = T.scale.x, C.repeat.y = T.scale.y
			}

			function v(T, C, V, k, F) {
				if (V === null || !V.IsValid()) return;
				let U = new bi;
				T.OnTextureNeeded();
				let K = null;
				V.mimeType !== null ? K = Rc(V.buffer, V.mimeType) : K = ws(V.buffer), k.objectUrls.push(K), U.load(K, Z => {
					_(V, Z), C.needsUpdate = !0, F(Z), T.OnTextureLoaded()
				}, null, Z => {
					T.OnTextureLoaded()
				})
			}
			let x = m.GetMaterial(g),
				M = On(x.color);
			x.vertexColors && M.setRGB(1, 1, 1);
			let I = {
				color: M,
				vertexColors: x.vertexColors,
				opacity: x.opacity,
				transparent: x.transparent,
				alphaTest: x.alphaTest,
				side: wn
			};
			d.forceMediumpForMaterials && (I.precision = "mediump");
			let w = null;
			if (y === Vn.Phong) {
				if (w = new Xt(I), x.type === In.Phong) {
					let T = On(x.specular);
					It(x.shininess, 0) && T.setRGB(0, 0, 0), w.specular = T, w.shininess = x.shininess * 100, v(f, w, x.specularMap, p, C => {
						w.specularMap = C
					})
				}
			} else y === Vn.Physical && (w = new cs(I), x.type === In.Physical && (w.metalness = x.metalness, w.roughness = x.roughness, v(f, w, x.metalnessMap, p, T => {
				w.metalness = 1, w.roughness = 1, w.metalnessMap = T, w.roughnessMap = T
			})));
			let L = On(x.emissive);
			return w.emissive = L, v(f, w, x.diffuseMap, p, T => {
				x.multiplyDiffuseMap || w.color.setRGB(1, 1, 1), w.map = T
			}), v(f, w, x.bumpMap, p, T => {
				w.bumpMap = T
			}), v(f, w, x.normalMap, p, T => {
				w.normalMap = T
			}), v(f, w, x.emissiveMap, p, T => {
				w.emissiveMap = T
			}), x.isDefault && (p.defaultMaterial = w), w
		}

		function s(f, m) {
			let g = f.mesh,
				y = g.TriangleCount(),
				d = [];
			for (let F = 0; F < y; F++) d.push(F);
			d.sort((F, U) => {
				let K = g.GetTriangle(F),
					Z = g.GetTriangle(U);
				return K.mat - Z.mat
			});
			let p = new St,
				_ = [],
				v = [],
				x = new Map,
				M = [],
				I = [],
				w = [],
				L = [],
				T = [];
			T.push({
				start: 0,
				end: -1
			});
			let C = g.VertexColorCount() > 0,
				V = g.TextureUVCount() > 0;
			for (let F = 0; F < d.length; F++) {
				let U = d[F],
					K = g.GetTriangle(U),
					Z = g.GetVertex(K.v0),
					Y = g.GetVertex(K.v1),
					H = g.GetVertex(K.v2);
				if (M.push(Z.x, Z.y, Z.z, Y.x, Y.y, Y.z, H.x, H.y, H.z), K.HasVertexColors()) {
					let me = On(g.GetVertexColor(K.c0)),
						P = On(g.GetVertexColor(K.c1)),
						b = On(g.GetVertexColor(K.c2));
					I.push(me.r, me.g, me.b, P.r, P.g, P.b, b.r, b.g, b.b)
				} else C && I.push(0, 0, 0, 0, 0, 0, 0, 0, 0);
				let oe = g.GetNormal(K.n0),
					de = g.GetNormal(K.n1),
					te = g.GetNormal(K.n2);
				if (w.push(oe.x, oe.y, oe.z, de.x, de.y, de.z, te.x, te.y, te.z), K.HasTextureUVs()) {
					let me = g.GetTextureUV(K.u0),
						P = g.GetTextureUV(K.u1),
						b = g.GetTextureUV(K.u2);
					L.push(me.x, me.y, P.x, P.y, b.x, b.y)
				} else V && L.push(0, 0, 0, 0, 0, 0);
				let fe = K.mat;
				x.has(fe) || (x.set(fe, _.length), _.push(m[fe]), v.push(fe), F > 0 && (T[T.length - 1].end = F - 1, T.push({
					start: T[T.length - 1].end + 1,
					end: -1
				})))
			}
			T[T.length - 1].end = y - 1, p.setAttribute("position", new ze(M, 3)), I.length !== 0 && p.setAttribute("color", new ze(I, 3)), p.setAttribute("normal", new ze(w, 3)), L.length !== 0 && p.setAttribute("uv", new ze(L, 2));
			for (let F = 0; F < T.length; F++) {
				let U = T[F];
				p.addGroup(U.start * 3, (U.end - U.start + 1) * 3, F)
			}
			let k = new Nt(p, _);
			return k.name = g.GetName(), k.userData = {
				originalMeshInstance: f,
				originalMaterials: v,
				threeMaterials: null
			}, k
		}

		function o(f, m, g) {
			if (Kr(m.mesh) === ir.TriangleMesh) {
				let d = s(m, g);
				f.add(d)
			}
		}

		function a(f, m, g, y) {
			let p = new ic(m, f).GetNodeItems();
			xc(p.length, 100, {
				runTask: (_, v, x) => {
					for (let M = _; M <= v; M++) {
						let I = p[M];
						o(I.threeNode, I.meshInstance, g)
					}
					x()
				},
				onReady: () => {
					y.OnModelLoaded(f)
				}
			})
		}
		let l = new nc(n),
			c = Wu(r),
			u = [];
		for (let f = 0; f < r.MaterialCount(); f++) {
			let m = i(l, r, f, c, e, t);
			u.push(m)
		}
		let h = new Rt;
		a(h, r, u, l)
	}
	var Wa = class {
		constructor() {
			this.importer = new Ba, this.inProgress = !1, this.defaultMaterial = null, this.objectUrls = null, this.hasHighpDriverIssue = Hu()
		}
		InProgress() {
			return this.inProgress
		}
		LoadModel(e, t, n) {
			this.inProgress || (this.inProgress = !0, this.RevokeObjectUrls(), this.importer.ImportFiles(e, t, {
				onLoadStart: () => {
					n.onLoadStart()
				},
				onFileListProgress: (i, s) => {
					n.onFileListProgress(i, s)
				},
				onFileLoadProgress: (i, s) => {
					n.onFileLoadProgress(i, s)
				},
				onImportStart: () => {
					n.onImportStart()
				},
				onSelectMainFile: (i, s) => {
					n.onSelectMainFile ? n.onSelectMainFile(i, s) : s(0)
				},
				onImportSuccess: i => {
					n.onVisualizationStart();
					let s = new za;
					s.forceMediumpForMaterials = this.hasHighpDriverIssue;
					let o = new Ha;
					dh(i.model, s, o, {
						onTextureLoaded: () => {
							n.onTextureLoaded()
						},
						onModelLoaded: a => {
							if (this.defaultMaterial = o.defaultMaterial, this.objectUrls = o.objectUrls, i.upVector === ht.X) {
								let l = new yn().setFromAxisAngle(new re(0, 0, 1), Math.PI / 2);
								a.quaternion.multiply(l)
							} else if (i.upVector === ht.Z) {
								let l = new yn().setFromAxisAngle(new re(1, 0, 0), -Math.PI / 2);
								a.quaternion.multiply(l)
							}
							n.onModelFinished(i, a), this.inProgress = !1
						}
					})
				},
				onImportError: i => {
					n.onLoadError(i), this.inProgress = !1
				}
			}))
		}
		GetImporter() {
			return this.importer
		}
		GetDefaultMaterial() {
			return this.defaultMaterial
		}
		ReplaceDefaultMaterialColor(e) {
			this.defaultMaterial !== null && !this.defaultMaterial.vertexColors && (this.defaultMaterial.color = On(e))
		}
		RevokeObjectUrls() {
			if (this.objectUrls !== null) {
				for (let e of this.objectUrls) Ic(e);
				this.objectUrls = null
			}
		}
		Destroy() {
			this.RevokeObjectUrls(), this.importer = null
		}
	};

	function Cn(r) {
		return Math.round(parseFloat(r))
	}

	function ph(r) {
		let e = Cn(r.paddingLeft) + Cn(r.paddingRight),
			t = Cn(r.borderLeftWidth) + Cn(r.borderRightWidth),
			n = Cn(r.marginLeft) + Cn(r.marginRight);
		return e + t + n
	}

	function mh(r) {
		let e = Cn(r.paddingTop) + Cn(r.paddingBottom),
			t = Cn(r.borderTopWidth) + Cn(r.borderBottomWidth),
			n = Cn(r.marginTop) + Cn(r.marginBottom);
		return e + t + n
	}

	function gh(r, e, t) {
		let n = getComputedStyle(r),
			i = e - ph(n),
			s = t - mh(n);
		return {
			width: i,
			height: s
		}
	}

	function Wr(r, e, t) {
		if (r.getBoundingClientRect) {
			let n = r.getBoundingClientRect();
			e -= n.left, t -= n.top
		}
		return window.pageXOffset && window.pageYOffset && (e += window.pageXOffset, t += window.pageYOffset), new wt(e, t)
	}

	function yh(r, e, t) {
		let n = document.createElement(r);
		return e && (n.className = e), t && (n.innerHTML = t), n
	}

	function Zd(r, e, t, n) {
		let i = yh(e, t, n);
		return r.appendChild(i), i
	}

	function N0(r, e, t) {
		return Zd(r, "div", e, t)
	}

	function O0(r) {
		for (; r.firstChild;) r.removeChild(r.firstChild)
	}

	function D0(r, e) {
		e.parentNode.insertBefore(r, e)
	}

	function F0(r, e) {
		e.parentNode.insertBefore(r, e.nextSibling)
	}

	function U0(r, e) {
		e ? r.style.display = "block" : r.style.display = "none"
	}

	function k0(r) {
		return r.offsetParent !== null
	}

	function Jd(r, e) {
		r.style.width = e.toString() + "px"
	}

	function $d(r, e) {
		r.style.height = e.toString() + "px"
	}

	function B0(r) {
		let e = getComputedStyle(r);
		return r.offsetWidth + Cn(e.marginLeft) + Cn(e.marginRight)
	}

	function G0(r) {
		let e = getComputedStyle(r);
		return r.offsetHeight + Cn(e.marginTop) + Cn(e.marginBottom)
	}

	function V0(r, e) {
		let t = getComputedStyle(r);
		Jd(r, e - ph(t))
	}

	function z0(r, e) {
		let t = getComputedStyle(r);
		$d(r, e - mh(t))
	}

	function H0(r, e) {
		return yh("div", r, e)
	}
	var rc = class {
			constructor() {
				this.prev = new wt(0, 0), this.curr = new wt(0, 0), this.diff = new wt(0, 0), this.buttons = []
			}
			Down(e, t) {
				this.buttons.push(t.which), this.curr = this.GetPositionFromEvent(e, t), this.prev = this.curr.Clone()
			}
			Move(e, t) {
				this.curr = this.GetPositionFromEvent(e, t), this.diff = Qa(this.curr, this.prev), this.prev = this.curr.Clone()
			}
			Up(e, t) {
				let n = this.buttons.indexOf(t.which);
				n !== -1 && this.buttons.splice(n, 1), this.curr = this.GetPositionFromEvent(e, t)
			}
			Leave(e, t) {
				this.buttons = [], this.curr = this.GetPositionFromEvent(e, t)
			}
			IsButtonDown() {
				return this.buttons.length > 0
			}
			GetButton() {
				let e = this.buttons.length;
				return e === 0 ? 0 : this.buttons[e - 1]
			}
			GetPosition() {
				return this.curr
			}
			GetMoveDiff() {
				return this.diff
			}
			GetPositionFromEvent(e, t) {
				return Wr(e, t.clientX, t.clientY)
			}
		},
		sc = class {
			constructor() {
				this.prevPos = new wt(0, 0), this.currPos = new wt(0, 0), this.diffPos = new wt(0, 0), this.prevDist = 0, this.currDist = 0, this.diffDist = 0, this.fingers = 0
			}
			Start(e, t) {
				t.touches.length !== 0 && (this.fingers = t.touches.length, this.currPos = this.GetPositionFromEvent(e, t), this.prevPos = this.currPos.Clone(), this.currDist = this.GetTouchDistanceFromEvent(e, t), this.prevDist = this.currDist)
			}
			Move(e, t) {
				t.touches.length !== 0 && (this.currPos = this.GetPositionFromEvent(e, t), this.diffPos = Qa(this.currPos, this.prevPos), this.prevPos = this.currPos.Clone(), this.currDist = this.GetTouchDistanceFromEvent(e, t), this.diffDist = this.currDist - this.prevDist, this.prevDist = this.currDist)
			}
			End(e, t) {
				t.touches.length !== 0 && (this.fingers = 0, this.currPos = this.GetPositionFromEvent(e, t), this.currDist = this.GetTouchDistanceFromEvent(e, t))
			}
			IsFingerDown() {
				return this.fingers !== 0
			}
			GetFingerCount() {
				return this.fingers
			}
			GetPosition() {
				return this.currPos
			}
			GetMoveDiff() {
				return this.diffPos
			}
			GetDistanceDiff() {
				return this.diffDist
			}
			GetPositionFromEvent(e, t) {
				let n = null;
				if (t.touches.length !== 0) {
					let i = t.touches[0];
					n = Wr(e, i.pageX, i.pageY)
				}
				return n
			}
			GetTouchDistanceFromEvent(e, t) {
				if (t.touches.length !== 2) return 0;
				let n = t.touches[0],
					i = t.touches[1];
				return el(Wr(e, n.pageX, n.pageY), Wr(e, i.pageX, i.pageY))
			}
		},
		oc = class {
			constructor() {
				this.isClick = !1, this.startPosition = null
			}
			Start(e) {
				this.isClick = !0, this.startPosition = e
			}
			Move(e) {
				this.isClick && (this.startPosition !== null ? el(this.startPosition, e) > 3 && this.Cancel() : this.Cancel())
			}
			End() {
				this.startPosition = null
			}
			Cancel() {
				this.isClick = !1, this.startPosition = null
			}
			IsClick() {
				return this.isClick
			}
		},
		Kn = {
			None: 0,
			Orbit: 1,
			Pan: 2,
			Zoom: 3
		},
		Xa = class {
			constructor(e, t, n) {
				this.canvas = e, this.camera = t, this.callbacks = n, this.fixUpVector = !0, this.mouse = new rc, this.touch = new sc, this.clickDetector = new oc, this.onMouseClick = null, this.onMouseMove = null, this.onContext = null, this.canvas.addEventListener && (this.canvas.addEventListener("mousedown", this.OnMouseDown.bind(this)), this.canvas.addEventListener("wheel", this.OnMouseWheel.bind(this)), this.canvas.addEventListener("touchstart", this.OnTouchStart.bind(this)), this.canvas.addEventListener("touchmove", this.OnTouchMove.bind(this)), this.canvas.addEventListener("touchcancel", this.OnTouchEnd.bind(this)), this.canvas.addEventListener("touchend", this.OnTouchEnd.bind(this)), this.canvas.addEventListener("contextmenu", this.OnContextMenu.bind(this))), document.addEventListener && (document.addEventListener("mousemove", this.OnMouseMove.bind(this)), document.addEventListener("mouseup", this.OnMouseUp.bind(this)), document.addEventListener("mouseleave", this.OnMouseLeave.bind(this)))
			}
			SetMouseClickHandler(e) {
				this.onMouseClick = e
			}
			SetMouseMoveHandler(e) {
				this.onMouseMove = e
			}
			SetContextMenuHandler(e) {
				this.onContext = e
			}
			IsFixUpVector() {
				return this.fixUpVector
			}
			SetFixUpVector(e) {
				this.fixUpVector = e
			}
			GetCamera() {
				return this.camera
			}
			SetCamera(e) {
				this.camera = e
			}
			MoveCamera(e, t) {
				function n(i, s, o, a) {
					i.camera.eye = s.eye[a], i.camera.center = s.center[a], i.camera.up = s.up[a], i.Update(), a < o - 1 && requestAnimationFrame(() => {
						n(i, s, o, a + 1)
					})
				}
				if (e !== null) {
					if (t === 0 || hh(this.camera, e)) this.camera = e;
					else {
						let i = Fc,
							s = {
								eye: wo(this.camera.eye, e.eye, t, i),
								center: wo(this.camera.center, e.center, t, i),
								up: wo(this.camera.up, e.up, t, i)
							};
						requestAnimationFrame(() => {
							n(this, s, t, 0)
						})
					}
					this.Update()
				}
			}
			GetFitToSphereCamera(e, t) {
				if (Ms(t)) return null;
				let n = this.camera.Clone(),
					i = Mn(n.center, e);
				n.eye = Mn(n.eye, i), n.center = e.Clone();
				let s = Mn(n.eye, n.center).Normalize(),
					o = this.camera.fov / 2;
				this.canvas.width < this.canvas.height && (o = o * this.canvas.width / this.canvas.height);
				let a = t / Math.sin(o * tr);
				return n.eye = n.center.Clone().Offset(s, a), n
			}
			OnMouseDown(e) {
				e.preventDefault(), this.mouse.Down(this.canvas, e), this.clickDetector.Start(this.mouse.GetPosition())
			}
			OnMouseMove(e) {
				if (this.mouse.Move(this.canvas, e), this.clickDetector.Move(this.mouse.GetPosition()), this.onMouseMove) {
					let s = Wr(this.canvas, e.clientX, e.clientY);
					this.onMouseMove(s)
				}
				if (!this.mouse.IsButtonDown()) return;
				let t = this.mouse.GetMoveDiff(),
					n = this.mouse.GetButton(),
					i = Kn.None;
				if (n === 1 ? e.ctrlKey ? i = Kn.Zoom : e.shiftKey ? i = Kn.Pan : i = Kn.Orbit : (n === 2 || n === 3) && (i = Kn.Pan), i === Kn.Orbit) {
					let s = .5;
					this.Orbit(t.x * s, t.y * s)
				} else if (i === Kn.Pan) {
					let o = .001 * Wn(this.camera.eye, this.camera.center);
					this.Pan(t.x * o, t.y * o)
				} else if (i === Kn.Zoom) {
					let s = .005;
					this.Zoom(-t.y * s)
				}
				this.Update()
			}
			OnMouseUp(e) {
				if (this.mouse.Up(this.canvas, e), this.clickDetector.End(), this.clickDetector.IsClick()) {
					let t = this.mouse.GetPosition();
					this.Click(e.which, t)
				}
			}
			OnMouseLeave(e) {
				this.mouse.Leave(this.canvas, e), this.clickDetector.Cancel()
			}
			OnTouchStart(e) {
				e.preventDefault(), this.touch.Start(this.canvas, e), this.clickDetector.Start(this.touch.GetPosition())
			}
			OnTouchMove(e) {
				if (e.preventDefault(), this.touch.Move(this.canvas, e), this.clickDetector.Move(this.touch.GetPosition()), !this.touch.IsFingerDown()) return;
				let t = this.touch.GetMoveDiff(),
					n = this.touch.GetDistanceDiff(),
					i = this.touch.GetFingerCount(),
					s = Kn.None;
				if (i === 1 ? s = Kn.Orbit : i === 2 && (s = Kn.Pan), s === Kn.Orbit) {
					let o = .5;
					this.Orbit(t.x * o, t.y * o)
				} else if (s === Kn.Pan) {
					let o = .005;
					this.Zoom(n * o);
					let a = .001 * Wn(this.camera.eye, this.camera.center);
					this.Pan(t.x * a, t.y * a)
				}
				this.Update()
			}
			OnTouchEnd(e) {
				if (e.preventDefault(), this.touch.End(this.canvas, e), this.clickDetector.End(), this.clickDetector.IsClick()) {
					let t = this.touch.GetPosition();
					this.touch.GetFingerCount() === 1 && this.Click(1, t)
				}
			}
			OnMouseWheel(e) {
				let t = e || window.event;
				t.preventDefault();
				let n = -t.deltaY / 40,
					i = .1;
				n < 0 && (i = i * -1), this.Zoom(i), this.Update()
			}
			OnContextMenu(e) {
				e.preventDefault(), this.clickDetector.IsClick() && (this.Context(e.clientX, e.clientY), this.clickDetector.Cancel())
			}
			Orbit(e, t) {
				let n = e * tr,
					i = t * tr,
					s = Mn(this.camera.center, this.camera.eye).Normalize(),
					o = Li(s, this.camera.up).Normalize();
				if (this.fixUpVector) {
					let l = Cc(s, this.camera.up) + i;
					Sc(l, 0) && lo(l, Math.PI) && this.camera.eye.Rotate(o, -i, this.camera.center), this.camera.eye.Rotate(this.camera.up, -n, this.camera.center)
				} else {
					let a = Li(o, s).Normalize();
					this.camera.eye.Rotate(o, -i, this.camera.center), this.camera.eye.Rotate(a, -n, this.camera.center), this.camera.up = a
				}
			}
			Pan(e, t) {
				let n = Mn(this.camera.center, this.camera.eye).Normalize(),
					i = Li(n, this.camera.up).Normalize(),
					s = Li(i, n).Normalize();
				this.camera.eye.Offset(i, -e), this.camera.center.Offset(i, -e), this.camera.eye.Offset(s, t), this.camera.center.Offset(s, t)
			}
			Zoom(e) {
				let t = Mn(this.camera.center, this.camera.eye),
					i = t.Length() * e;
				this.camera.eye.Offset(t, i)
			}
			Update() {
				this.callbacks.onUpdate()
			}
			Click(e, t) {
				this.onMouseClick && this.onMouseClick(e, t)
			}
			Context(e, t) {
				if (this.onContext) {
					let n = {
							x: e,
							y: t
						},
						i = Wr(this.canvas, e, t);
					this.onContext(n, i)
				}
			}
		};
	var to = class r {
			constructor(e, t) {
				this.textureNames = e, this.backgroundIsEnvMap = t
			}
			Clone() {
				let e = null;
				if (this.textureNames !== null) {
					e = [];
					for (let t of this.textureNames) e.push(t)
				}
				return new r(e, this.backgroundIsEnvMap)
			}
		},
		qa = class {
			constructor(e) {
				this.scene = e, this.type = Vn.Phong, this.cameraMode = zn.Perspective, this.ambientLight = new fr(8947848), this.directionalLight = new hr(8947848), this.environmentSettings = new to(null, !1), this.environment = null, this.scene.add(this.ambientLight), this.scene.add(this.directionalLight)
			}
			SetShadingType(e) {
				this.type = e, this.UpdateShading()
			}
			SetCameraMode(e) {
				this.cameraMode = e, this.UpdateShading()
			}
			UpdateShading() {
				this.type === Vn.Phong ? (this.ambientLight.color.set(8947848), this.directionalLight.color.set(8947848), this.scene.environment = null) : this.type === Vn.Physical && (this.ambientLight.color.set(0), this.directionalLight.color.set(5592405), this.scene.environment = this.environment), this.environmentSettings.backgroundIsEnvMap && this.cameraMode === zn.Perspective ? this.scene.background = this.environment : this.scene.background = null
			}
			SetEnvironmentMapSettings(e, t) {
				let n = new Ou;
				this.environment = n.load(e.textureNames, i => {
					i.colorSpace = Bn, t()
				}), this.environmentSettings = e
			}
			UpdateByCamera(e) {
				let t = Mn(e.eye, e.center);
				this.directionalLight.position.set(t.x, t.y, t.z)
			}
			CreateHighlightMaterial(e, t) {
				let n = null;
				return this.type === Vn.Phong ? n = new Xt({
					color: On(e),
					side: wn
				}) : this.type === Vn.Physical && (n = new cs({
					color: On(e),
					side: wn
				})), n !== null && t && (n.polygonOffset = !0, n.polygonOffsetUnit = 1, n.polygonOffsetFactor = 1), n
			}
		};

	function vh(r) {
		let e = 45;
		return r === ht.X ? new yr(new He(2, -3, 1.5), new He(0, 0, 0), new He(1, 0, 0), e) : r === ht.Y ? new yr(new He(-1.5, 2, 3), new He(0, 0, 0), new He(0, 1, 0), e) : r === ht.Z ? new yr(new He(-1.5, -3, 2), new He(0, 0, 0), new He(0, 0, 1), e) : null
	}

	function xh(r, e) {
		if (!e(r)) return !1;
		for (let t of r.children)
			if (!xh(t, e)) return !1;
		return !0
	}

	function Qd(r) {
		let e = null;
		return xh(r, t => {
			if (t.isMesh)
				for (let n of t.material) return n.type === "MeshPhongMaterial" ? e = Vn.Phong : n.type === "MeshStandardMaterial" && (e = Vn.Physical), !1;
			return !0
		}), e
	}
	var ac = class {
			constructor() {
				this.eyeCenterDistance = 0, this.forceUpdate = !0
			}
			ForceUpdate() {
				this.forceUpdate = !0
			}
			ValidatePerspective() {
				return this.forceUpdate ? (this.forceUpdate = !1, !1) : !0
			}
			ValidateOrthographic(e) {
				return this.forceUpdate || !It(this.eyeCenterDistance, e) ? (this.eyeCenterDistance = e, this.forceUpdate = !1, !1) : !0
			}
		},
		lc = class {
			constructor() {
				this.direction = ht.Y, this.isFixed = !0, this.isFlipped = !1
			}
			SetDirection(e, t) {
				this.direction = e, this.isFlipped = !1;
				let n = vh(this.direction),
					i = Mn(n.eye, n.center),
					s = Wn(t.center, t.eye),
					o = t.center.Clone().Offset(i, s),
					a = t.Clone();
				return this.direction === ht.X ? (a.up = new He(1, 0, 0), a.eye = o) : this.direction === ht.Y ? (a.up = new He(0, 1, 0), a.eye = o) : this.direction === ht.Z && (a.up = new He(0, 0, 1), a.eye = o), a
			}
			SetFixed(e, t) {
				return this.isFixed = e, this.isFixed ? this.SetDirection(this.direction, t) : null
			}
			Flip(e) {
				this.isFlipped = !this.isFlipped;
				let t = e.Clone();
				return t.up.MultiplyScalar(-1), t
			}
		},
		ja = class {
			constructor() {
				hi.enabled = !1, this.canvas = null, this.renderer = null, this.scene = null, this.mainModel = null, this.extraModel = null, this.camera = null, this.cameraMode = null, this.cameraValidator = null, this.shadingModel = null, this.navigation = null, this.upVector = null, this.settings = {
					animationSteps: 40
				}
			}
			Init(e) {
				this.canvas = e, this.canvas.id = "viewer";
				let t = {
					canvas: this.canvas,
					antialias: !0
				};
				this.renderer = new qs(t), this.renderer.outputColorSpace = Bn, window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setClearColor("#ffffff", 1), this.renderer.setSize(this.canvas.width, this.canvas.height), this.scene = new ur, this.mainModel = new Va(this.scene), this.extraModel = new _s(this.scene), this.InitNavigation(), this.InitShading(), this.Render()
			}
			SetMouseClickHandler(e) {
				this.navigation.SetMouseClickHandler(e)
			}
			SetMouseMoveHandler(e) {
				this.navigation.SetMouseMoveHandler(e)
			}
			SetContextMenuHandler(e) {
				this.navigation.SetContextMenuHandler(e)
			}
			SetEdgeSettings(e) {
				let t = e.Clone();
				this.mainModel.SetEdgeSettings(t), this.Render()
			}
			SetEnvironmentMapSettings(e) {
				let t = e.Clone();
				this.shadingModel.SetEnvironmentMapSettings(t, () => {
					this.Render()
				}), this.shadingModel.UpdateShading(), this.Render()
			}
			SetBackgroundColor(e) {
				let t = new qe(bs(e.r), bs(e.g), bs(e.b)),
					n = bs(e.a);
				this.renderer.setClearColor(t, n), this.Render()
			}
			GetCanvas() {
				return this.canvas
			}
			GetCamera() {
				return this.navigation.GetCamera()
			}
			GetCameraMode() {
				return this.cameraMode
			}
			SetCamera(e) {
				this.navigation.SetCamera(e), this.cameraValidator.ForceUpdate(), this.Render()
			}
			SetCameraMode(e) {
				this.cameraMode !== e && (this.scene.remove(this.camera), e === zn.Perspective ? this.camera = new Yt(45, 1, .1, 1e3) : e === zn.Orthographic && (this.camera = new cr(-1, 1, 1, -1, .1, 1e3)), this.scene.add(this.camera), this.cameraMode = e, this.shadingModel.SetCameraMode(e), this.cameraValidator.ForceUpdate(), this.AdjustClippingPlanes(), this.Render())
			}
			Resize(e, t) {
				let n = gh(this.canvas, e, t);
				this.ResizeRenderer(n.width, n.height)
			}
			ResizeRenderer(e, t) {
				window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(e, t), this.cameraValidator.ForceUpdate(), this.Render()
			}
			FitSphereToWindow(e, t) {
				if (e === null) return;
				let n = new He(e.center.x, e.center.y, e.center.z),
					i = e.radius,
					s = this.navigation.GetFitToSphereCamera(n, i);
				this.navigation.MoveCamera(s, t ? this.settings.animationSteps : 0)
			}
			AdjustClippingPlanes() {
				let e = this.GetBoundingSphere(t => !0);
				this.AdjustClippingPlanesToSphere(e)
			}
			AdjustClippingPlanesToSphere(e) {
				e !== null && (e.radius < 10 ? (this.camera.near = .01, this.camera.far = 100) : e.radius < 100 ? (this.camera.near = .1, this.camera.far = 1e3) : e.radius < 1e3 ? (this.camera.near = 10, this.camera.far = 1e4) : (this.camera.near = 100, this.camera.far = 1e6), this.cameraValidator.ForceUpdate(), this.Render())
			}
			IsFixUpVector() {
				return this.navigation.IsFixUpVector()
			}
			SetFixUpVector(e) {
				let t = this.navigation.GetCamera(),
					n = this.upVector.SetFixed(e, t);
				this.navigation.SetFixUpVector(e), n !== null && this.navigation.MoveCamera(n, this.settings.animationSteps), this.Render()
			}
			SetUpVector(e, t) {
				let n = this.navigation.GetCamera(),
					i = this.upVector.SetDirection(e, n),
					s = t ? this.settings.animationSteps : 0;
				this.navigation.MoveCamera(i, s), this.Render()
			}
			FlipUpVector() {
				let e = this.navigation.GetCamera(),
					t = this.upVector.Flip(e);
				this.navigation.MoveCamera(t, 0), this.Render()
			}
			Render() {
				let e = this.navigation.GetCamera();
				if (this.camera.position.set(e.eye.x, e.eye.y, e.eye.z), this.camera.up.set(e.up.x, e.up.y, e.up.z), this.camera.lookAt(new re(e.center.x, e.center.y, e.center.z)), this.cameraMode === zn.Perspective) this.cameraValidator.ValidatePerspective() || (this.camera.aspect = this.canvas.width / this.canvas.height, this.camera.fov = e.fov, this.camera.updateProjectionMatrix());
				else if (this.cameraMode === zn.Orthographic) {
					let t = Wn(e.eye, e.center);
					if (!this.cameraValidator.ValidateOrthographic(t)) {
						let n = this.canvas.width / this.canvas.height,
							s = Wn(e.eye, e.center) * Math.tan(.5 * e.fov * tr);
						this.camera.left = -s * n, this.camera.right = s * n, this.camera.top = s, this.camera.bottom = -s, this.camera.updateProjectionMatrix()
					}
				}
				this.shadingModel.UpdateByCamera(e), this.renderer.render(this.scene, this.camera)
			}
			SetMainObject(e) {
				let t = Qd(e);
				this.mainModel.SetMainObject(e), this.shadingModel.SetShadingType(t), this.Render()
			}
			AddExtraObject(e) {
				this.extraModel.AddObject(e), this.Render()
			}
			Clear() {
				this.mainModel.Clear(), this.extraModel.Clear(), this.Render()
			}
			ClearExtra() {
				this.extraModel.Clear(), this.Render()
			}
			SetMeshesVisibility(e) {
				this.mainModel.EnumerateMeshes(t => {
					let n = e(t.userData);
					t.visible !== n && (t.visible = n)
				}), this.mainModel.EnumerateEdges(t => {
					let n = e(t.userData);
					t.visible !== n && (t.visible = n)
				}), this.Render()
			}
			SetMeshesHighlight(e, t) {
				function n(s, o) {
					let a = [];
					for (let l = 0; l < s.length; l++) a.push(o);
					return a
				}
				let i = this.CreateHighlightMaterial(e);
				this.mainModel.EnumerateMeshes(s => {
					t(s.userData) ? s.userData.threeMaterials === null && (s.userData.threeMaterials = s.material, s.material = n(s.material, i)) : s.userData.threeMaterials !== null && (s.material = s.userData.threeMaterials, s.userData.threeMaterials = null)
				}), this.Render()
			}
			CreateHighlightMaterial(e) {
				let t = this.mainModel.edgeSettings.showEdges;
				return this.shadingModel.CreateHighlightMaterial(e, t)
			}
			GetMeshUserDataUnderMouse(e) {
				let t = this.GetMeshIntersectionUnderMouse(e);
				return t === null ? null : t.object.userData
			}
			GetMeshIntersectionUnderMouse(e) {
				let t = this.GetCanvasSize(),
					n = this.mainModel.GetMeshIntersectionUnderMouse(e, this.camera, t.width, t.height);
				return n === null ? null : n
			}
			GetBoundingBox(e) {
				return this.mainModel.GetBoundingBox(e)
			}
			GetBoundingSphere(e) {
				return this.mainModel.GetBoundingSphere(e)
			}
			EnumerateMeshesUserData(e) {
				this.mainModel.EnumerateMeshes(t => {
					e(t.userData)
				})
			}
			InitNavigation() {
				let e = vh(ht.Y);
				this.camera = new Yt(45, 1, .1, 1e3), this.cameraMode = zn.Perspective, this.cameraValidator = new ac, this.scene.add(this.camera);
				let t = this.renderer.domElement;
				this.navigation = new Xa(t, e, {
					onUpdate: () => {
						this.Render()
					}
				}), this.upVector = new lc
			}
			InitShading() {
				this.shadingModel = new qa(this.scene)
			}
			GetShadingType() {
				return this.shadingModel.type
			}
			GetImageSize() {
				let e = new Ce;
				return this.renderer.getSize(e), {
					width: parseInt(e.x, 10),
					height: parseInt(e.y, 10)
				}
			}
			GetCanvasSize() {
				let e = this.canvas.width,
					t = this.canvas.height;
				return window.devicePixelRatio && (e /= window.devicePixelRatio, t /= window.devicePixelRatio), {
					width: e,
					height: t
				}
			}
			GetImageAsDataUrl(e, t, n) {
				let i = this.GetImageSize(),
					s = e,
					o = t;
				window.devicePixelRatio && (s /= window.devicePixelRatio, o /= window.devicePixelRatio);
				let a = this.renderer.getClearAlpha();
				n && this.renderer.setClearAlpha(0), this.ResizeRenderer(s, o), this.Render();
				let l = this.renderer.domElement.toDataURL();
				return this.ResizeRenderer(i.width, i.height), this.renderer.setClearAlpha(a), l
			}
			Destroy() {
				this.Clear(), this.renderer.dispose()
			}
		};
	var Ya = class {
		constructor(e, t) {
			this.parentElement = e, this.parameters = {}, so(t) && (this.parameters = t), this.canvas = document.createElement("canvas"), this.parentElement.appendChild(this.canvas), this.viewer = new ja, this.viewer.Init(this.canvas);
			let n = this.parentElement.clientWidth,
				i = this.parentElement.clientHeight;
			this.viewer.Resize(n, i), this.parameters.cameraMode && this.viewer.SetCameraMode(this.parameters.cameraMode), this.parameters.backgroundColor && this.viewer.SetBackgroundColor(this.parameters.backgroundColor), this.parameters.edgeSettings && this.viewer.SetEdgeSettings(this.parameters.edgeSettings), this.parameters.environmentSettings && this.viewer.SetEnvironmentMapSettings(this.parameters.environmentSettings), this.model = null, this.modelLoader = new Wa, window.addEventListener("resize", () => {
				this.Resize()
			})
		}
		LoadModelFromUrlList(e) {
			bc(e);
			let t = Uc(e);
			this.LoadModelFromInputFiles(t)
		}
		LoadModelFromFileList(e) {
			let t = kc(e);
			this.LoadModelFromInputFiles(t)
		}
		LoadModelFromInputFiles(e) {
			if (e === null || e.length === 0) return;
			this.viewer.Clear();
			let t = new ka;
			this.parameters.defaultColor && (t.defaultColor = this.parameters.defaultColor), this.model = null;
			let n = null;
			this.modelLoader.LoadModel(e, t, {
				onLoadStart: () => {
					this.canvas.style.display = "none", n = document.createElement("div"), n.innerHTML = "Loading model...", this.parentElement.appendChild(n)
				},
				onFileListProgress: (i, s) => {},
				onFileLoadProgress: (i, s) => {},
				onImportStart: () => {
					n.innerHTML = "Importing model..."
				},
				onVisualizationStart: () => {
					n.innerHTML = "Visualizing model..."
				},
				onModelFinished: (i, s) => {
					this.parentElement.removeChild(n), this.canvas.style.display = "inherit", this.viewer.SetMainObject(s);
					let o = this.viewer.GetBoundingSphere(a => !0);
					this.viewer.AdjustClippingPlanesToSphere(o), this.parameters.camera ? this.viewer.SetCamera(this.parameters.camera) : (this.viewer.SetUpVector(ht.Y, !1), this.viewer.FitSphereToWindow(o, !1)), this.model = i.model, this.parameters.onModelLoaded && this.parameters.onModelLoaded()
				},
				onTextureLoaded: () => {
					this.viewer.Render()
				},
				onLoadError: i => {
					let s = "Unknown error.";
					i.code === gr.NoImportableFile ? s = "No importable file found." : i.code === gr.FailedToLoadFile ? s = "Failed to load file for import." : i.code === gr.ImportFailed && (s = "Failed to import model."), i.message !== null && (s += " (" + i.message + ")"), n.innerHTML = s
				}
			})
		}
		GetViewer() {
			return this.viewer
		}
		GetModel() {
			return this.model
		}
		Resize() {
			let e = this.parentElement.clientWidth,
				t = this.parentElement.clientHeight;
			this.viewer.Resize(e, t)
		}
		Destroy() {
			this.modelLoader.Destroy(), this.viewer.Destroy(), this.model = null
		}
	};

	function ep(r, e, t) {
		let n = new Ya(r, t);
		return n.LoadModelFromUrlList(e), n
	}

	function W0(r, e, t) {
		let n = new Ya(r, t);
		return n.LoadModelFromFileList(e), n
	}

	function X0(r) {
		function e(i) {
			let s = null,
				o = i.getAttribute("camera");
			o && (s = on.StringToCamera(o));
			let a = null,
				l = i.getAttribute("cameramode");
			l && (a = on.StringToCameraMode(l));
			let c = null,
				u = i.getAttribute("backgroundcolor");
			u && (c = on.StringToRGBAColor(u));
			let h = null,
				f = i.getAttribute("defaultcolor");
			f && (h = on.StringToRGBColor(f));
			let m = null,
				g = i.getAttribute("edgesettings");
			g && (m = on.StringToEdgeSettings(g));
			let y = null,
				d = i.getAttribute("environmentmap");
			if (d) {
				let v = d.split(",");
				if (v.length === 6) {
					let x = !1,
						M = i.getAttribute("environmentmapbg");
					M && M === "true" && (x = !0), y = new to(v, x)
				}
			}
			let p = null,
				_ = i.getAttribute("model");
			return _ && (p = on.StringToModelUrls(_)), ep(i, p, {
				camera: s,
				cameraMode: a,
				backgroundColor: c,
				defaultColor: h,
				edgeSettings: m,
				environmentSettings: y
			})
		}
		let t = [],
			n = document.getElementsByClassName("online_3d_viewer");
		for (let i = 0; i < n.length; i++) {
			let s = n[i],
				o = e(s);
			t.push(o)
		}
		return t
	}
	return Q0(nS);
})();
/*! Bundled license information:

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2023 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

three/examples/jsm/libs/fflate.module.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.6.9
  *)

three/examples/jsm/libs/chevrotain.module.min.js:
  (*! chevrotain - v9.0.1 *)
*/